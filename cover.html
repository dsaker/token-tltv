
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">talkliketv.click/tltv/api/audio.go (63.7%)</option>
				
				<option value="file1">talkliketv.click/tltv/api/server.go (55.1%)</option>
				
				<option value="file2">talkliketv.click/tltv/api/templates.go (77.8%)</option>
				
				<option value="file3">talkliketv.click/tltv/api/views.go (0.0%)</option>
				
				<option value="file4">talkliketv.click/tltv/internal/audio/audiofile/audiofile.go (78.0%)</option>
				
				<option value="file5">talkliketv.click/tltv/internal/audio/pattern/pattern.go (40.0%)</option>
				
				<option value="file6">talkliketv.click/tltv/internal/config/config.go (47.8%)</option>
				
				<option value="file7">talkliketv.click/tltv/internal/mock/amazonclients.go (56.7%)</option>
				
				<option value="file8">talkliketv.click/tltv/internal/mock/audiofile.go (100.0%)</option>
				
				<option value="file9">talkliketv.click/tltv/internal/mock/googleclients.go (96.2%)</option>
				
				<option value="file10">talkliketv.click/tltv/internal/mock/models.go (16.7%)</option>
				
				<option value="file11">talkliketv.click/tltv/internal/mock/tokens.go (100.0%)</option>
				
				<option value="file12">talkliketv.click/tltv/internal/mock/translates.go (61.1%)</option>
				
				<option value="file13">talkliketv.click/tltv/internal/models/models.go (0.0%)</option>
				
				<option value="file14">talkliketv.click/tltv/internal/models/tokens.go (0.0%)</option>
				
				<option value="file15">talkliketv.click/tltv/internal/oapi/tltv.gen.go (63.8%)</option>
				
				<option value="file16">talkliketv.click/tltv/internal/test/test_util.go (81.8%)</option>
				
				<option value="file17">talkliketv.click/tltv/internal/translates/amazonclients.go (31.8%)</option>
				
				<option value="file18">talkliketv.click/tltv/internal/translates/googleclients.go (37.8%)</option>
				
				<option value="file19">talkliketv.click/tltv/internal/translates/translates.go (39.2%)</option>
				
				<option value="file20">talkliketv.click/tltv/internal/util/helpers.go (34.1%)</option>
				
				<option value="file21">talkliketv.click/tltv/internal/validator/validator.go (0.0%)</option>
				
				<option value="file22">talkliketv.click/tltv/main.go (0.0%)</option>
				
				<option value="file23">talkliketv.click/tltv/scripts/go/coinsfirestore/coinsfirestore.go (0.0%)</option>
				
				<option value="file24">talkliketv.click/tltv/scripts/go/generatecoins/generatecoins.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "errors"
        "fmt"
        "github.com/labstack/echo/v4"
        "net/http"
        "os"
        "slices"
        "strconv"
        "strings"
        "talkliketv.click/tltv/internal/audio/audiofile"
        "talkliketv.click/tltv/internal/models"
        "talkliketv.click/tltv/internal/test"
)

// ParseFile takes a file and parses it into the phrases that will be used to
// create the audio mp3 files.
// This allows the user to check to make sure the phrases are parsed correctly
// before uploading the file.
func (s *Server) ParseFile(e echo.Context) error <span class="cov0" title="0">{
        stringsSlice, err := s.parseFile(e)
        if err != nil </span><span class="cov0" title="0">{
                return e.Render(http.StatusInternalServerError, "parse.gohtml", map[string]interface{}{
                        "MaxPhrases": s.config.MaxNumPhrases,
                        "Error":      err.Error(),
                })
        }</span>

        // Get file handler for filename, size and headers
        <span class="cov0" title="0">fh, err := e.FormFile("file_path")
        if err != nil </span><span class="cov0" title="0">{
                return e.Render(http.StatusBadRequest, "parse.gohtml", map[string]interface{}{
                        "MaxPhrases": s.config.MaxNumPhrases,
                        "Error":      err.Error(),
                })
        }</span>

        <span class="cov0" title="0">zippedFile, err := s.zipStringsSlice(e, stringsSlice, fh.Filename)
        if err != nil </span><span class="cov0" title="0">{
                return e.Render(http.StatusInternalServerError, "parse.gohtml", map[string]interface{}{
                        "MaxPhrases": s.config.MaxNumPhrases,
                        "Error":      err.Error(),
                })
        }</span>
        <span class="cov0" title="0">return e.Attachment(zippedFile.Name(), fh.Filename+"_parsed.zip")</span>
}

// AudioFromFile accepts a file in srt, phrase per line, or paragraph form and
// sends a zip file of mp3 audio tracks for learning a language that you choose
func (s *Server) AudioFromFile(e echo.Context) error <span class="cov8" title="1">{
        token := e.FormValue("token")
        // check token
        if err := s.tokens.CheckToken(e.Request().Context(), token); err != nil </span><span class="cov8" title="1">{
                e.Logger().Error(err)
                return e.Render(http.StatusForbidden, "audio.gohtml", newTemplateData(err.Error()))
        }</span>

        <span class="cov8" title="1">title, err := validateAudioRequest(e)
        if err != nil </span><span class="cov8" title="1">{
                return e.Render(http.StatusBadRequest, "audio.gohtml", newTemplateData(err.Error()))
        }</span>

        // TODO put limit on characters
        <span class="cov8" title="1">phrases, phraseZipFile, err := s.processFile(e, title.Name)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrTooManyPhrases) </span><span class="cov8" title="1">{
                        return e.Attachment(phraseZipFile.Name(), "TooManyPhrasesUseTheseFiles")
                }</span>
                <span class="cov8" title="1">e.Logger().Error(err)
                if strings.Contains(err.Error(), "unable to parse file") </span><span class="cov8" title="1">{
                        return e.Render(http.StatusBadRequest, "audio.gohtml", newTemplateData(err.Error()))
                }</span>
                <span class="cov0" title="0">return e.Render(http.StatusInternalServerError, "audio.gohtml", newTemplateData(err.Error()))</span>
        }

        <span class="cov8" title="1">title.TitlePhrases = phrases

        zipFile, err := s.createAudioFromTitle(e, *title)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return e.Render(http.StatusInternalServerError, "audio.gohtml", newTemplateData(err.Error()))
        }</span>

        // change token status to Used
        <span class="cov8" title="1">err = s.tokens.UpdateField(e.Request().Context(), token, "UploadUsed", "true")
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return e.Render(http.StatusInternalServerError, "audio.gohtml", newTemplateData(err.Error()))
        }</span>

        // TODO change Id's to language codes
        <span class="cov8" title="1">titleName := title.Name + "." + strconv.Itoa(title.FromVoiceId) + "-" + strconv.Itoa(title.ToVoiceId) + ".zip"
        return e.Attachment(zipFile.Name(), titleName)</span>
}

func (s *Server) parseFile(e echo.Context) ([]string, error) <span class="cov8" title="1">{
        // Get file handler for filename, size and headers
        fh, err := e.FormFile("file_path")
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, audiofile.ErrUnableToParseFile(err)
        }</span>

        // Check if file size is too large 64000 == 8KB ~ approximately 4 pages of text
        <span class="cov8" title="1">if fh.Size &gt; s.config.FileUploadLimit </span><span class="cov8" title="1">{
                rString := fmt.Sprintf("file too large (%d &gt; %d)", fh.Size, s.config.FileUploadLimit)
                return nil, audiofile.ErrUnableToParseFile(errors.New(rString))
        }</span>
        <span class="cov8" title="1">src, err := fh.Open()
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer src.Close()

        // get an array of all the phrases from the uploaded file
        stringsSlice, err := s.af.GetLines(e, src)
        if err != nil </span><span class="cov0" title="0">{
                return nil, audiofile.ErrUnableToParseFile(err)
        }</span>

        <span class="cov8" title="1">return stringsSlice, nil</span>
}

func (s *Server) zipStringsSlice(e echo.Context, slice []string, name string) (*os.File, error) <span class="cov0" title="0">{
        chunkedPhrases := slices.Chunk(slice, s.config.MaxNumPhrases)
        phrasesBasePath := s.config.TTSBasePath + name + "/"
        // create zip of phrases files of maxNumPhrases for user to use instead of uploaded file
        zipFile, err := s.af.CreatePhrasesZip(e, chunkedPhrases, phrasesBasePath, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return zipFile, nil</span>
}

func (s *Server) processFile(e echo.Context, titleName string) ([]models.Phrase, *os.File, error) <span class="cov8" title="1">{
        stringsSlice, err := s.parseFile(e)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        // send back zip of split files of phrase that requester can use if too big
        <span class="cov8" title="1">if len(stringsSlice) &gt; s.config.MaxNumPhrases </span><span class="cov8" title="1">{
                chunkedPhrases := slices.Chunk(stringsSlice, s.config.MaxNumPhrases)
                phrasesBasePath := s.config.TTSBasePath + titleName + "/"
                // create zip of phrases files of maxNumPhrases for user to use instead of uploaded file
                zipFile, err := s.af.CreatePhrasesZip(e, chunkedPhrases, phrasesBasePath, titleName)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">return nil, zipFile, models.ErrTooManyPhrases</span>
        }

        // make an array of phrases with id so we can match all the translates and text-to-speech
        <span class="cov8" title="1">phrases := make([]models.Phrase, len(stringsSlice))
        for i := range stringsSlice </span><span class="cov8" title="1">{
                phrases[i] = models.Phrase{
                        ID:   i,
                        Text: stringsSlice[i],
                }
        }</span>
        <span class="cov8" title="1">return phrases, nil, nil</span>
}

// createAudioFromTitle is a helper function that performs the tasks shared by
// AudioFromFile and AudioFromTitle
func (s *Server) createAudioFromTitle(e echo.Context, title models.Title) (*os.File, error) <span class="cov8" title="1">{
        // TODO if you don't want these files to persist then you need to defer removing them from calling function
        audioBasePath := s.config.TTSBasePath + title.Name

        fromAudioBasePath := fmt.Sprintf("%s/%d/", audioBasePath, title.FromVoiceId)
        toAudioBasePath := fmt.Sprintf("%s/%d/", audioBasePath, title.ToVoiceId)

        _, err := s.translate.CreateTTS(e, title, title.FromVoiceId, fromAudioBasePath)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                // if error remove all the text-to-speech created up to that point
                osErr := os.RemoveAll(audioBasePath)
                if osErr != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(osErr)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">toPhrases, err := s.translate.CreateTTS(e, title, title.ToVoiceId, toAudioBasePath)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                osErr := os.RemoveAll(audioBasePath)
                if osErr != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(osErr)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">title.ToPhrases = toPhrases

        // get pause path string to build the full pause file path
        pausePath, ok := audiofile.AudioPauseFilePath[title.Pause]
        if !ok </span><span class="cov0" title="0">{
                e.Logger().Error(models.ErrPauseNotFound)
                return nil, models.ErrPauseNotFound
        }</span>
        <span class="cov8" title="1">fullPausePath := s.config.TTSBasePath + pausePath

        // create a temporary directory for building all the files
        tmpDirPath := fmt.Sprintf("%s%s-%s/", s.config.TTSBasePath, title.Name, test.RandomString(4))
        err = os.MkdirAll(tmpDirPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = s.af.BuildAudioInputFiles(e, title, fullPausePath, fromAudioBasePath, toAudioBasePath, tmpDirPath); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.af.CreateMp3Zip(e, title, tmpDirPath)</span>
}

func validateAudioRequest(e echo.Context) (*models.Title, error) <span class="cov8" title="1">{
        // get values from multipart form
        titleName := e.FormValue("title_name")
        // convert strings from multipart form to int
        fileLangId, err := strconv.Atoi(e.FormValue("file_language_id"))
        if err != nil </span><span class="cov8" title="1">{
                e.Logger().Error(err)
                return nil, fmt.Errorf("error converting file_language_id to int: %s", err.Error())
        }</span>

        // validate fileLangId
        <span class="cov8" title="1">_, ok := models.Languages[fileLangId]

        if !ok </span><span class="cov8" title="1">{
                e.Logger().Error(models.ErrLanguageIdInvalid)
                return nil, models.ErrLanguageIdInvalid
        }</span>
        <span class="cov8" title="1">toVoiceId, err := strconv.Atoi(e.FormValue("to_voice_id"))
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, fmt.Errorf("error converting to_voice_id to int: %s", err.Error())
        }</span>
        // validate toVoiceId
        <span class="cov8" title="1">_, ok = models.Voices[toVoiceId]
        if !ok </span><span class="cov8" title="1">{
                e.Logger().Error(models.ErrVoiceIdInvalid)
                return nil, models.ErrVoiceIdInvalid
        }</span>
        <span class="cov8" title="1">fromVoiceId, err := strconv.Atoi(e.FormValue("from_voice_id"))
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, fmt.Errorf("error converting from_voice_id to int: %s", err.Error())
        }</span>
        // valid fromVoiceId
        <span class="cov8" title="1">_, ok = models.Voices[fromVoiceId]
        if !ok </span><span class="cov0" title="0">{
                e.Logger().Error(models.ErrVoiceIdInvalid)
                return nil, models.ErrVoiceIdInvalid
        }</span>

        <span class="cov8" title="1">pause, err := strconv.Atoi(e.FormValue("pause"))
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, fmt.Errorf("error converting pause to int: %s", err.Error())
        }</span>
        // validate pause
        <span class="cov8" title="1">if pause &lt; 3 || pause &gt; 10 </span><span class="cov8" title="1">{
                pauseError := errors.New("pause must be between 3 and 10")
                e.Logger().Error(pauseError)
                return nil, pauseError
        }</span>

        // pattern is the pattern used to build the audio files at /internal/pattern
        <span class="cov8" title="1">pattern, err := strconv.Atoi(e.FormValue("pattern"))
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, fmt.Errorf("error converting pattern to int: %s", err.Error())
        }</span>
        // validate pause
        <span class="cov8" title="1">if pattern &lt; 1 || pattern &gt; 3 </span><span class="cov8" title="1">{
                patternError := errors.New("pattern must be between 1 and 3")
                e.Logger().Error(patternError)
                return nil, patternError
        }</span>

        <span class="cov8" title="1">return &amp;models.Title{
                Name:         titleName,
                TitleLangId:  fileLangId,
                ToVoiceId:    toVoiceId,
                FromVoiceId:  fromVoiceId,
                Pause:        pause,
                TitlePhrases: nil,
                ToPhrases:    nil,
                Pattern:      pattern,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "fmt"
        "github.com/getkin/kin-openapi/openapi3"
        "github.com/labstack/echo/v4"
        echomw "github.com/labstack/echo/v4/middleware"
        middleware "github.com/oapi-codegen/echo-middleware"
        "golang.org/x/time/rate"
        "log"
        "os"
        "sync"
        "talkliketv.click/tltv/internal/audio"
        "talkliketv.click/tltv/internal/audio/audiofile"
        "talkliketv.click/tltv/internal/config"
        "talkliketv.click/tltv/internal/models"
        "talkliketv.click/tltv/internal/oapi"
        "talkliketv.click/tltv/internal/translates"
        "talkliketv.click/tltv/internal/util"
)

type Server struct {
        sync.RWMutex
        translate translates.TranslateX
        af        audiofile.AudioFileX
        tokens    models.TokensX
        config    config.Config
}

// NewServer creates a new HTTP server and sets up routing.
func NewServer(c config.Config, t translates.TranslateX, af audiofile.AudioFileX, tok models.TokensX) *echo.Echo <span class="cov8" title="1">{
        e := echo.New()
        // make sure silence mp3s exist in your base path
        initSilence(c)

        // create maps of voices and languages depending on platform
        if translates.GlobalPlatform == translates.Google </span><span class="cov8" title="1">{
                models.MakeGoogleMaps()
        }</span> else<span class="cov0" title="0"> {
                models.MakeAmazonMaps()
        }</span>

        <span class="cov8" title="1">tempC, err := newTemplateCache()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">e.Renderer = &amp;TemplateRegistry{templates: tempC}

        // add middleware
        e.Use(echomw.RateLimiter(echomw.NewRateLimiterMemoryStore(rate.Limit(5))))
        e.Use(echomw.Logger())
        e.Use(echomw.Recover())

        // Use our validation middleware to check all requests against the OpenAPI schema.
        apiGrp := e.Group("/v1")
        spec, err := oapi.GetSwagger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("loading spec: %w", err)
        }</span>
        <span class="cov8" title="1">spec.Servers = openapi3.Servers{&amp;openapi3.Server{URL: "/v1"}}
        apiGrp.Use(middleware.OapiRequestValidatorWithOptions(spec,
                &amp;middleware.Options{
                        SilenceServersWarning: true,
                }))

        srv := &amp;Server{
                translate: t,
                config:    c,
                af:        af,
                tokens:    tok,
        }

        uiGrp := e.Group("")
        uiGrp.Static("/static", "ui/static")
        uiGrp.GET("/", homeView)
        uiGrp.GET("/audio", audioView)
        uiGrp.GET("/parse", srv.parseView)

        oapi.RegisterHandlersWithBaseURL(apiGrp, srv, "")
        return e</span>
}

// Make sure we conform to ServerInterface
var _ oapi.ServerInterface = (*Server)(nil)

// initSilence copies the silence mp3's from the embedded filesystem to the config TTSBasePath
func initSilence(cfg config.Config) <span class="cov8" title="1">{
        // check if silence mp3s exist in your base path
        silencePath := cfg.TTSBasePath + audiofile.AudioPauseFilePath[4]
        exists, err := util.PathExists(silencePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // if it doesn't exist copy it from embedded FS to TTSBasePath
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                err = os.MkdirAll(cfg.TTSBasePath+"silence/", 0777)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">for key, value := range audiofile.AudioPauseFilePath </span><span class="cov0" title="0">{
                        fmt.Printf("%d", key)
                        pause, err := audio.Silence.ReadFile(value)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        // Create a new file
                        <span class="cov0" title="0">file, err := os.Create(cfg.TTSBasePath + value)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">defer file.Close()
                        // Write to the file
                        _, err = file.Write(pause)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        // Ensure data is written to disk
                        <span class="cov0" title="0">err = file.Sync()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "errors"
        "github.com/labstack/echo/v4"
        "html/template"
        "io"
        "io/fs"
        "path/filepath"
        "talkliketv.click/tltv/internal/models"
        "talkliketv.click/tltv/ui"
)

type templateData struct {
        Languages map[int]models.Language
        Voices    map[int]models.Voice
        Error     string
}

type TemplateRegistry struct {
        templates map[string]*template.Template
}

// Render Implement e.Renderer interface
func (t *TemplateRegistry) Render(w io.Writer, name string, data interface{}, c echo.Context) error <span class="cov8" title="1">{
        tmpl, ok := t.templates[name]
        if !ok </span><span class="cov0" title="0">{
                err := errors.New("Template not found -&gt; " + name)
                return err
        }</span>
        <span class="cov8" title="1">return tmpl.ExecuteTemplate(w, "base", data)</span>
}

func newTemplateCache() (map[string]*template.Template, error) <span class="cov8" title="1">{
        cache := map[string]*template.Template{}

        // Use fs.Glob() to get a slice of all filepaths in the ui.Files embedded
        // filesystem which match the pattern 'html/pages/*.tmpl'. This essentially
        // gives us a slice of all the 'page' templates for the application.
        pages, err := fs.Glob(ui.Files, "html/pages/*.gohtml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, page := range pages </span><span class="cov8" title="1">{
                name := filepath.Base(page)

                // Create a slice containing the filepath patterns for the templates we
                // want to parse.
                patterns := []string{
                        "html/base.gohtml",
                        "html/common/*.gohtml",
                        page,
                }

                // Use ParseFS() instead of ParseFiles() to parse the template files
                // from the ui.Files embedded filesystem.
                ts, err := template.New(name).ParseFS(ui.Files, patterns...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">cache[name] = ts</span>
        }

        <span class="cov8" title="1">return cache, nil</span>
}

// newTemplateDatachecks if the user is authenticated and adds the base data needed for the templates
func newTemplateData(err string) *templateData <span class="cov8" title="1">{
        return &amp;templateData{
                Languages: models.Languages,
                Voices:    models.Voices,
                Error:     err,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "github.com/labstack/echo/v4"
        "net/http"
)

func homeView(e echo.Context) error <span class="cov0" title="0">{
        return e.Render(http.StatusOK, "home.gohtml", nil)
}</span>

// audioView renders the frontend html page to upload a file for mp3 creation
func audioView(e echo.Context) error <span class="cov0" title="0">{
        return e.Render(http.StatusOK, "audio.gohtml", newTemplateData(""))
}</span>

// parseView renders the frontend html page to upload a file to parse it
func (s *Server) parseView(e echo.Context) error <span class="cov0" title="0">{
        return e.Render(http.StatusOK, "parse.gohtml", map[string]interface{}{
                "MaxPhrases": s.config.MaxNumPhrases,
        })
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package audiofile

import (
        "archive/zip"
        "bufio"
        "errors"
        "fmt"
        "io"
        "iter"
        "mime/multipart"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "slices"
        "strconv"
        "strings"
        "talkliketv.click/tltv/internal/models"
        "talkliketv.click/tltv/internal/util"
        "unicode"

        "github.com/labstack/echo/v4"
        audio "talkliketv.click/tltv/internal/audio/pattern"
)

// AudioPauseFilePath is a map to the silence mp3's of the embedded FS in
// internal/audio/silence/efs.go and after application startup will be stored
// at config.TTSBasePath
var AudioPauseFilePath = map[int]string{
        3:  "silence/3SecSilence.mp3",
        4:  "silence/4SecSilence.mp3",
        5:  "silence/5SecSilence.mp3",
        6:  "silence/6SecSilence.mp3",
        7:  "silence/7SecSilence.mp3",
        8:  "silence/8SecSilence.mp3",
        9:  "silence/9SecSilence.mp3",
        10: "silence/10SecSilence.mp3",
}

// endSentenceMap is a map to find the ending punctuation of a sentence
// TODO change endSentenceMap to work for any language
var (
        ErrOneFile           = errors.New("no need to zip one file")
        ErrUnableToParseFile = func(err error) error <span class="cov0" title="0">{
                return fmt.Errorf("unable to parse file: %s", err)
        }</span>
        endSentenceMap = map[rune]bool{
                '!': true,
                '.': true,
                '?': true,
        }
        // Use a regular expression to match punctuation characters
        reAlpha = regexp.MustCompile(`[a-zA-Z]`)
)

const (
        minimumPhraseLength = 4
        maximumPhraseLength = 10
)

type AudioFileX interface {
        GetLines(echo.Context, multipart.File) ([]string, error)
        CreateMp3Zip(echo.Context, models.Title, string) (*os.File, error)
        BuildAudioInputFiles(echo.Context, models.Title, string, string, string, string) error
        CreatePhrasesZip(echo.Context, iter.Seq[[]string], string, string) (*os.File, error)
}

type AudioFile struct {
        cmdX cmdRunnerX
}

// cmdRunnerX creates an interface to allow for unit testing without having ffmpeg installed
type cmdRunnerX interface {
        CombinedOutput(cmd *exec.Cmd) ([]byte, error)
}

func New(cmdX cmdRunnerX) *AudioFile <span class="cov8" title="1">{
        return &amp;AudioFile{cmdX: cmdX}
}</span>

type RealCmdRunner struct{}

// CombinedOutput is a wrapper function for cmd.CombinedOutput() so this function
// can be interfaced for testing (ffmpeg will not have to be installed on machine
// for unit testing)
func (r *RealCmdRunner) CombinedOutput(cmd *exec.Cmd) ([]byte, error) <span class="cov0" title="0">{
        return cmd.CombinedOutput()
}</span>

// GetLines determines if the uploaded file is an srt, in paragraph form, or one phrase per
// line and then parses the file accordingly, returning a string slice containing the
// phrases to be translated
func (a *AudioFile) GetLines(e echo.Context, f multipart.File) ([]string, error) <span class="cov8" title="1">{
        // get file type, options are srt, single line text or paragraph
        fileType := ""
        scanner := bufio.NewScanner(f)
        //start at the first line again
        _, err := f.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">count := 0
        var line string

        // verify if file is srt
        for scanner.Scan() </span><span class="cov8" title="1">{
                if fileType != "" || count &gt; 5 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">line = scanner.Text()
                // if line contains "&gt;" and doesn't contain any letters it is srt file
                if strings.Contains(line, "&gt;") </span><span class="cov8" title="1">{
                        if strings.Contains(line, "&lt;font") </span><span class="cov0" title="0">{
                                fileType = "srt"
                        }</span> else<span class="cov8" title="1"> {
                                if !reAlpha.MatchString(line) </span><span class="cov8" title="1">{
                                        fileType = "srt"
                                }</span>
                        }
                }
                <span class="cov8" title="1">count++</span>
        }
        //start at the first line again
        <span class="cov8" title="1">_, err = f.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">count = 0
        scanner = bufio.NewScanner(f)
        // verify if file is in paragraph form
        for scanner.Scan() </span><span class="cov8" title="1">{
                if fileType != "" || count &gt; 4 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">line = scanner.Text()
                // Split on punctuation characters
                re := regexp.MustCompile(`[.!?]`)
                result := re.Split(line, -1)
                if len(result) &gt; 3 </span><span class="cov8" title="1">{
                        fileType = "paragraph"
                }</span>
                <span class="cov8" title="1">count++</span>
        }
        // TODO verify single phrase per line form (these can be multiple sentences per line)
        <span class="cov8" title="1">_, err = f.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">var stringsSlice []string
        if fileType == "srt" </span><span class="cov8" title="1">{
                stringsSlice = parseSrt(f)
        }</span>
        <span class="cov8" title="1">if fileType == "paragraph" </span><span class="cov8" title="1">{
                stringsSlice = parseParagraph(f)
        }</span>
        <span class="cov8" title="1">if fileType == "" </span><span class="cov8" title="1">{
                stringsSlice = parseSingle(f)
        }</span>
        <span class="cov8" title="1">if len(stringsSlice) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("unable to parse file")
        }</span>

        // remove strings longer than 150 characters and duplicates from stringsSlice
        <span class="cov8" title="1">return util.RemoveLongStr(util.RemoveDuplicateStr(stringsSlice)), nil</span>
}

// parseSrt takes a srt multipart file and parses it into a slice of strings
func parseSrt(f multipart.File) []string <span class="cov8" title="1">{
        var stringsSlice []string
        scanner := bufio.NewScanner(f)
        scanner.Scan()
        var line string
        for scanner.Scan() </span><span class="cov8" title="1">{
                line = strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if line[0] &gt;= '0' &amp;&amp; line[0] &lt;= '9' </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if line[0] == '[' &amp;&amp; line[len(line)-1] == ']' </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if strings.Contains(line, "&lt;font") || strings.Contains(line, "font&gt;") </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        // if the next line following subtitle is not new line it is more dialogue so combine it
                        scanner.Scan()
                        nextLine := scanner.Text()
                        if nextLine != "" </span><span class="cov8" title="1">{
                                line = strings.ReplaceAll(line, "\n", "")
                                line = line + " " + nextLine
                                line = replaceFmt(line)
                        }</span> else<span class="cov0" title="0"> {
                                line = replaceFmt(line)
                        }</span>
                }

                <span class="cov8" title="1">phrases := splitLongPhrases(line)
                stringsSlice = append(stringsSlice, phrases...)</span>
        }

        <span class="cov8" title="1">return stringsSlice</span>
}

func splitLongPhrases(line string) []string <span class="cov8" title="1">{
        var splitString []string

        words := strings.Fields(line)
        // if phrase is too short don't keep it
        if len(words) &lt;= minimumPhraseLength </span><span class="cov8" title="1">{
                return []string{}
        }</span> else<span class="cov8" title="1"> if len(words) &lt; maximumPhraseLength </span><span class="cov8" title="1">{
                // if phrase isn't too long don't split it
                return []string{line}
        }</span> else<span class="cov8" title="1"> {
                // split into an array of strings along punctuation
                last := 0
                for i, word := range words </span><span class="cov8" title="1">{
                        if unicode.IsPunct(rune(word[len(word)-1])) </span><span class="cov8" title="1">{
                                nextString := ""
                                for j := last; j &lt;= i; j++ </span><span class="cov8" title="1">{
                                        nextString = nextString + words[j] + " "
                                }</span>
                                <span class="cov8" title="1">splitString = append(splitString, nextString)
                                last = i + 1</span>
                        }
                }
                // if last word does not end in punctuation add that string
                <span class="cov8" title="1">if last &lt; len(words) </span><span class="cov8" title="1">{
                        splitString = append(splitString, strings.Join(words[last:], " "))
                }</span>
                // if long phrase has punctuation split on punctuation
                <span class="cov8" title="1">if len(splitString) &gt; 1 </span><span class="cov8" title="1">{
                        // combine any strings that are less than the minimumPhraseLength with the string after it
                        i := 0
                        for i &lt; len(splitString)-1 </span><span class="cov8" title="1">{
                                // if phrase is small combine it with the next one
                                wordsInString := strings.Fields(splitString[i])
                                if len(wordsInString) &lt; minimumPhraseLength </span><span class="cov8" title="1">{
                                        splitString[i] = splitString[i] + " " + splitString[i+1]
                                        // remove the next index of split string
                                        splitString = append(splitString[:i+1], splitString[i+2:]...)
                                }</span> else<span class="cov8" title="1"> {
                                        // if both combined are less than maximum than concat
                                        next := splitString[i] + " " + splitString[i+1]
                                        nextWordCount := strings.Fields(next)
                                        if len(nextWordCount) &lt;= maximumPhraseLength </span><span class="cov8" title="1">{
                                                splitString[i] = next
                                                splitString = append(splitString[:i+1], splitString[i+2:]...)
                                        }</span>
                                }
                                // else continue
                                <span class="cov8" title="1">i++</span>
                        }

                        // now check the last index and pen ultimate of the split string and combine if shorter than minimumPhraseLength
                        <span class="cov8" title="1">if len(splitString) &gt; 1 </span><span class="cov8" title="1">{
                                lastElem := len(splitString) - 1
                                lastElemCount := len(strings.Fields(splitString[lastElem]))
                                penUltimateElemCount := len(strings.Fields(splitString[lastElem-1]))
                                if lastElemCount &lt; minimumPhraseLength || penUltimateElemCount &lt; minimumPhraseLength </span><span class="cov8" title="1">{
                                        lastString := splitString[lastElem-1] + " " + splitString[lastElem]
                                        splitString[lastElem] = lastString
                                        splitString = splitString[:lastElem-1]
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        return []string{line}
                }</span>
        }

        <span class="cov8" title="1">for i := range splitString </span><span class="cov8" title="1">{
                splitString[i] = strings.ReplaceAll(splitString[i], "  ", " ")
                splitString[i] = strings.TrimSpace(splitString[i])
        }</span>
        <span class="cov8" title="1">return splitString</span>
}

// parseParagraph takes a txt multipart file in paragraph form and returns a slice of strings
func parseParagraph(f multipart.File) []string <span class="cov8" title="1">{
        var stringsSlice []string
        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                // Split on punctuation characters
                last := 0
                for i, c := range line </span><span class="cov8" title="1">{
                        if i == len(line)-1 </span><span class="cov8" title="1">{
                                sentence := strings.TrimSpace(line[last : i+1])
                                last = i + 1
                                words := strings.Fields(sentence)
                                if len(words) &gt; 3 </span><span class="cov8" title="1">{
                                        stringsSlice = append(stringsSlice, line)
                                }</span>
                        } else<span class="cov8" title="1"> if endSentenceMap[c] </span><span class="cov8" title="1">{
                                sentence := strings.TrimSpace(line[last : i+1])
                                last = i + 1
                                phrases := splitLongPhrases(sentence)
                                stringsSlice = append(stringsSlice, phrases...)
                        }</span>
                }
        }

        <span class="cov8" title="1">return stringsSlice</span>
}

// parseSingle takes a txt multipart file with one phrase per line and parses it
// into a slice of strings
func parseSingle(f multipart.File) []string <span class="cov8" title="1">{
        var stringsSlice []string
        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                phrases := splitLongPhrases(line)
                stringsSlice = append(stringsSlice, phrases...)
        }</span>

        <span class="cov8" title="1">return stringsSlice</span>
}

// replaceFmt is a helper function for parseSrt that replaces characters that are not part
// of the phrase like descriptions or tags
func replaceFmt(line string) string <span class="cov8" title="1">{
        // remove any characters between brackets and brackets [...] or {...} or &lt;...&gt;
        re := regexp.MustCompile("\\[.*?]") //nolint:gosimple
        line = re.ReplaceAllString(line, "")
        re = regexp.MustCompile("\\{.*?}") //nolint:gosimple
        line = re.ReplaceAllString(line, "")
        re = regexp.MustCompile("&lt;.*?&gt;")
        line = re.ReplaceAllString(line, "")
        line = strings.ReplaceAll(line, "-", "")
        line = strings.ReplaceAll(line, "♪", "")
        line = strings.ReplaceAll(line, "\"", "")
        line = strings.TrimSpace(line)

        return line
}</span>

// CreateMp3Zip takes the input txt files created with BuildAudioInputFiles and uses ffmpeg
// to build an output mp3's file and the zips them into a single file to be returned to the
// requester
func (a *AudioFile) CreateMp3Zip(e echo.Context, t models.Title, tmpDir string) (*os.File, error) <span class="cov8" title="1">{
        // get a list of files from the temp directory
        files, err := os.ReadDir(tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("no files found in CreateMp3Zip")
        }</span>
        // create outputs folder to hold all the mp3's to zip
        <span class="cov8" title="1">outDirPath := tmpDir + "outputs"
        err = os.MkdirAll(outDirPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">for i, f := range files </span><span class="cov8" title="1">{
                // ffmpeg -f concat -safe 0 -i ffmpeg_input.txt -c copy output.mp3
                outputString := fmt.Sprintf("%s/%s-%d.mp3", outDirPath, t.Name, i)
                cmd := exec.Command("ffmpeg", "-f", "concat", "-safe", "0", "-i", tmpDir+f.Name(), "-c", "copy", outputString) //nolint:gosec

                //Execute the command and get the output
                output, err := a.cmdX.CombinedOutput(cmd)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        e.Logger().Error("combined output: " + string(output))
                        return nil, err
                }</span>
        }

        // add a text files of the translated phrases, this is useful studying
        <span class="cov8" title="1">if t.ToPhrases != nil </span><span class="cov0" title="0">{
                // Create file to write all the translated phrases to
                f, err := os.Create(outDirPath + "/" + t.Name + "-translates.txt")
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer f.Close()
                for _, text := range t.ToPhrases </span><span class="cov0" title="0">{
                        _, err = f.WriteString(text.Text + "\n")
                        if err != nil </span><span class="cov0" title="0">{
                                e.Logger().Error(err)
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return createZipFile(e, tmpDir, t.Name, outDirPath)</span>
}

// addFileToZip is a helper function for CreateMp3Zip that adds each file to
// the zip.Writer
func addFileToZip(e echo.Context, zipWriter *zip.Writer, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        <span class="cov8" title="1">header, err := zip.FileInfoHeader(fInfo)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        <span class="cov8" title="1">header.Name = filepath.Base(filename)
        header.Method = zip.Deflate

        writer, err := zipWriter.CreateHeader(header)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = io.Copy(writer, file)
        e.Logger().Info("wrote file: %s", file.Name())
        return err</span>
}

// BuildAudioInputFiles creates a file with the filepaths of the mp3's used to construct
// the output files with ffmpeg in CreateMp3Zip
func (a *AudioFile) BuildAudioInputFiles(e echo.Context, t models.Title, pause, from, to, tmpDir string) error <span class="cov8" title="1">{
        maxP := len(t.TitlePhrases) - 1

        pattern := audio.GetPattern(t.Pattern)
        if pattern == nil </span><span class="cov0" title="0">{
                e.Logger().Error("error getting pattern from audio file")
                return errors.New("no pattern")
        }</span>
        // create chunks of []Audio pattern to split up audio files into ~15 minute lengths
        <span class="cov8" title="1">chunkedSlice := slices.Chunk(pattern, 125)
        count := 1
        last := false
        for chunk := range chunkedSlice </span><span class="cov8" title="1">{
                // you must pad the count for them to be read in the correct order when building mp3 files
                inputString := fmt.Sprintf("%s-input-%02d", t.Name, count)
                count++
                f, err := os.Create(tmpDir + inputString)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">defer f.Close()

                // start audiofile with silence
                _, err = f.WriteString(fmt.Sprintf("file '%s'\n", pause))
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">for _, audioFloat := range chunk </span><span class="cov8" title="1">{
                        // convert float representation of phrase id and whether speech should be native or translated
                        // it is represented in /internal/pattern as "phraseId"."native_boolean" as a float32 to save space
                        stringFloat := strconv.FormatFloat(float64(audioFloat), 'f', -1, 32)
                        phraseNative := strings.Split(stringFloat, ".")
                        // if when you split the string the length is 1 that means the float ended in .0 which means audio
                        // should be translated; if length is 2 that means float ended in .1 which indicates it should be
                        // native
                        native := false
                        if len(phraseNative) == 2 </span><span class="cov8" title="1">{
                                native = true
                        }</span>
                        <span class="cov8" title="1">phraseId, err := strconv.Atoi(phraseNative[0])
                        if err != nil </span><span class="cov0" title="0">{
                                e.Logger().Error(err)
                                return err
                        }</span>
                        // if: we have reached the highest phrase id then this will be the last audio block
                        // else if: skip if phraseId does not exist (is greater than maxP)
                        // else if: native language then we add filepath for from audio mp3
                        // else: add audio filepath for language you want to learn
                        <span class="cov8" title="1">if phraseId == maxP </span><span class="cov8" title="1">{
                                last = true
                        }</span>
                        <span class="cov8" title="1">if native </span><span class="cov8" title="1">{
                                _, err = f.WriteString(fmt.Sprintf("file '%s%d'\n", from, phraseId))
                                if err != nil </span><span class="cov0" title="0">{
                                        e.Logger().Error(err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">_, err = f.WriteString(fmt.Sprintf("file '%s'\n", pause))
                                if err != nil </span><span class="cov0" title="0">{
                                        e.Logger().Error(err)
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                _, err = f.WriteString(fmt.Sprintf("file '%s%d'\n", to, phraseId))
                                if err != nil </span><span class="cov0" title="0">{
                                        e.Logger().Error(err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">_, err = f.WriteString(fmt.Sprintf("file '%s'\n", pause))
                                if err != nil </span><span class="cov0" title="0">{
                                        e.Logger().Error(err)
                                        return err
                                }</span>
                        }
                }
                // end audiofile with silence
                <span class="cov8" title="1">_, err = f.WriteString(fmt.Sprintf("file '%s'\n", pause))
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">if last </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// CreatePhrasesZip creates a zipped file of txt files from the file the user uploaded if it contains
// more phrases than the limit of config.MaxNumPhrases. It takes a iter.Seq of strings and outputs them
// to files, each chunk containing config.MaxNumPhrases and than zips them up. Sending them back to the
// user
func (a *AudioFile) CreatePhrasesZip(e echo.Context, chunkedPhrases iter.Seq[[]string], tmpPath, filename string) (*os.File, error) <span class="cov8" title="1">{
        // create outputs folder to hold all the txt files to zip
        err := os.MkdirAll(tmpPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">count := 0
        for chunk := range chunkedPhrases </span><span class="cov8" title="1">{
                file := fmt.Sprintf("%s-phrases-%d.txt", filename, count)
                count++
                f, err := os.Create(tmpPath + file)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer f.Close()

                for _, phrase := range chunk </span><span class="cov8" title="1">{
                        _, err = f.WriteString(phrase + "\n")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return createZipFile(e, tmpPath, filename, tmpPath)</span>
}

// createZipFile takes a tmpDir which is the directory containing the files you want to zip.
// filename which is the name that you want the zipped files to have as their base name
// and outDirPath which is where the zip file will be stored and zips up the files
func createZipFile(e echo.Context, tmpDir, filename, outDirPath string) (*os.File, error) <span class="cov8" title="1">{
        // TODO add txt file of the phrases
        zipFile, err := os.Create(tmpDir + filename + ".zip")
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer zipFile.Close()

        zipWriter := zip.NewWriter(zipFile)
        defer zipWriter.Close()

        // get a list of files from the output directory
        files, err := os.ReadDir(outDirPath)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if !strings.HasSuffix(file.Name(), ".zip") </span><span class="cov8" title="1">{
                        err = addFileToZip(e, zipWriter, outDirPath+"/"+file.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return zipFile, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package audio

func GetPattern(i int) []float32 <span class="cov8" title="1">{
        switch i </span>{
        case 1:<span class="cov8" title="1">
                return Intermediate</span>
        case 2:<span class="cov0" title="0">
                return Advanced</span>
        case 3:<span class="cov0" title="0">
                return Review</span>
        default:<span class="cov0" title="0">
                return Intermediate</span>
        }
}

// Intermediate is the pattern used to build the mp3 audio files.
// The program used to generate it is at https://github.com/dsaker/audio-pattern-builder/blob/main/main.go
// The pattern stored here can build audio for up to 200 phrases.
// Frequency of repetition can be adjusted in the program
// This pattern is set with multi = 15 at https://github.com/dsaker/audio-pattern-builder/blob/c577c22826aad34906f4eb944ff92c9693f9b4c4/main.go#L26
// Intermediate multi = 15
var Intermediate = []float32{0.1, 0.0, 0.0, 1.1, 1.0, 1.0, 2.1, 2.0, 2.0, 3.1, 3.0, 3.0, 4.1, 4.0, 4.0, 5.1, 5.0, 5.0, 0.1, 0.0, 6.1, 6.0, 6.0, 1.1, 1.0, 7.1, 7.0, 7.0, 2.1, 2.0, 8.1, 8.0, 8.0, 3.1, 3.0, 9.1, 9.0, 9.0, 4.1, 4.0, 5.1, 5.0, 10.1, 10.0, 10.0, 6.1, 6.0, 11.1, 11.0, 11.0, 7.1, 7.0, 12.1, 12.0, 12.0, 8.1, 8.0, 13.1, 13.0, 13.0, 9.1, 9.0, 14.1, 14.0, 14.0, 10.1, 10.0, 15.1, 15.0, 15.0, 11.1, 11.0, 16.1, 16.0, 16.0, 12.1, 12.0, 17.1, 17.0, 17.0, 13.1, 13.0, 18.1, 18.0, 18.0, 14.1, 14.0, 19.1, 19.0, 19.0, 15.1, 15.0, 20.1, 20.0, 20.0, 16.1, 16.0, 21.1, 21.0, 21.0, 17.1, 17.0, 22.1, 22.0, 22.0, 18.1, 18.0, 0.1, 0.0, 19.1, 19.0, 1.1, 1.0, 20.1, 20.0, 2.1, 2.0, 21.1, 21.0, 3.1, 3.0, 22.1, 22.0, 4.1, 4.0, 5.1, 5.0, 23.1, 23.0, 23.0, 6.1, 6.0, 24.1, 24.0, 24.0, 7.1, 7.0, 25.1, 25.0, 25.0, 8.1, 8.0, 26.1, 26.0, 26.0, 9.1, 9.0, 27.1, 27.0, 27.0, 10.1, 10.0, 23.1, 23.0, 11.1, 11.0, 24.1, 24.0, 12.1, 12.0, 25.1, 25.0, 13.1, 13.0, 26.1, 26.0, 27.1, 27.0, 14.1, 14.0, 28.1, 28.0, 28.0, 15.1, 15.0, 29.1, 29.0, 29.0, 16.1, 16.0, 30.1, 30.0, 30.0, 17.1, 17.0, 31.1, 31.0, 31.0, 18.1, 18.0, 32.1, 32.0, 32.0, 19.1, 19.0, 28.1, 28.0, 20.1, 20.0, 29.1, 29.0, 21.1, 21.0, 30.1, 30.0, 22.1, 22.0, 31.1, 31.0, 32.1, 32.0, 33.1, 33.0, 33.0, 34.1, 34.0, 34.0, 35.1, 35.0, 35.0, 36.1, 36.0, 36.0, 37.1, 37.0, 37.0, 38.1, 38.0, 38.0, 23.1, 23.0, 33.1, 33.0, 24.1, 24.0, 34.1, 34.0, 25.1, 25.0, 35.1, 35.0, 26.1, 26.0, 27.1, 27.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 39.1, 39.0, 39.0, 40.1, 40.0, 40.0, 41.1, 41.0, 41.0, 42.1, 42.0, 42.0, 28.1, 28.0, 43.1, 43.0, 43.0, 29.1, 29.0, 44.1, 44.0, 44.0, 30.1, 30.0, 39.1, 39.0, 31.1, 31.0, 32.1, 32.0, 0.1, 0.0, 40.1, 40.0, 1.1, 1.0, 41.1, 41.0, 2.1, 2.0, 42.1, 42.0, 3.1, 3.0, 43.1, 43.0, 4.1, 4.0, 5.1, 5.0, 44.1, 44.0, 6.1, 6.0, 33.1, 33.0, 7.1, 7.0, 34.1, 34.0, 8.1, 8.0, 35.1, 35.0, 9.1, 9.0, 36.1, 36.0, 37.1, 37.0, 10.1, 10.0, 38.1, 38.0, 11.1, 11.0, 45.1, 45.0, 45.0, 12.1, 12.0, 46.1, 46.0, 46.0, 13.1, 13.0, 47.1, 47.0, 47.0, 14.1, 14.0, 48.1, 48.0, 48.0, 15.1, 15.0, 39.1, 39.0, 16.1, 16.0, 45.1, 45.0, 17.1, 17.0, 40.1, 40.0, 18.1, 18.0, 41.1, 41.0, 19.1, 19.0, 42.1, 42.0, 20.1, 20.0, 43.1, 43.0, 21.1, 21.0, 44.1, 44.0, 22.1, 22.0, 46.1, 46.0, 47.1, 47.0, 48.1, 48.0, 49.1, 49.0, 49.0, 50.1, 50.0, 50.0, 51.1, 51.0, 51.0, 52.1, 52.0, 52.0, 53.1, 53.0, 53.0, 23.1, 23.0, 54.1, 54.0, 54.0, 24.1, 24.0, 49.1, 49.0, 25.1, 25.0, 50.1, 50.0, 26.1, 26.0, 27.1, 27.0, 51.1, 51.0, 45.1, 45.0, 52.1, 52.0, 53.1, 53.0, 54.1, 54.0, 55.1, 55.0, 55.0, 56.1, 56.0, 56.0, 28.1, 28.0, 57.1, 57.0, 57.0, 29.1, 29.0, 58.1, 58.0, 58.0, 30.1, 30.0, 59.1, 59.0, 59.0, 31.1, 31.0, 32.1, 32.0, 46.1, 46.0, 47.1, 47.0, 48.1, 48.0, 55.1, 55.0, 56.1, 56.0, 57.1, 57.0, 58.1, 58.0, 59.1, 59.0, 60.1, 60.0, 60.0, 33.1, 33.0, 61.1, 61.0, 61.0, 34.1, 34.0, 49.1, 49.0, 35.1, 35.0, 50.1, 50.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 51.1, 51.0, 52.1, 52.0, 53.1, 53.0, 54.1, 54.0, 60.1, 60.0, 61.1, 61.0, 62.1, 62.0, 62.0, 39.1, 39.0, 63.1, 63.0, 63.0, 64.1, 64.0, 64.0, 40.1, 40.0, 65.1, 65.0, 65.0, 41.1, 41.0, 66.1, 66.0, 66.0, 42.1, 42.0, 62.1, 62.0, 43.1, 43.0, 55.1, 55.0, 44.1, 44.0, 56.1, 56.0, 57.1, 57.0, 58.1, 58.0, 59.1, 59.0, 63.1, 63.0, 64.1, 64.0, 65.1, 65.0, 66.1, 66.0, 67.1, 67.0, 67.0, 68.1, 68.0, 68.0, 69.1, 69.0, 69.0, 70.1, 70.0, 70.0, 71.1, 71.0, 71.0, 60.1, 60.0, 61.1, 61.0, 0.1, 0.0, 67.1, 67.0, 1.1, 1.0, 45.1, 45.0, 2.1, 2.0, 68.1, 68.0, 3.1, 3.0, 69.1, 69.0, 4.1, 4.0, 5.1, 5.0, 62.1, 62.0, 6.1, 6.0, 70.1, 70.0, 7.1, 7.0, 71.1, 71.0, 8.1, 8.0, 72.1, 72.0, 72.0, 9.1, 9.0, 73.1, 73.0, 73.0, 46.1, 46.0, 10.1, 10.0, 47.1, 47.0, 11.1, 11.0, 48.1, 48.0, 12.1, 12.0, 63.1, 63.0, 13.1, 13.0, 64.1, 64.0, 65.1, 65.0, 14.1, 14.0, 66.1, 66.0, 15.1, 15.0, 49.1, 49.0, 16.1, 16.0, 50.1, 50.0, 17.1, 17.0, 67.1, 67.0, 18.1, 18.0, 51.1, 51.0, 19.1, 19.0, 52.1, 52.0, 20.1, 20.0, 53.1, 53.0, 21.1, 21.0, 54.1, 54.0, 22.1, 22.0, 68.1, 68.0, 69.1, 69.0, 70.1, 70.0, 71.1, 71.0, 72.1, 72.0, 73.1, 73.0, 74.1, 74.0, 74.0, 55.1, 55.0, 75.1, 75.0, 75.0, 56.1, 56.0, 23.1, 23.0, 57.1, 57.0, 24.1, 24.0, 58.1, 58.0, 25.1, 25.0, 59.1, 59.0, 26.1, 26.0, 27.1, 27.0, 74.1, 74.0, 75.1, 75.0, 76.1, 76.0, 76.0, 77.1, 77.0, 77.0, 78.1, 78.0, 78.0, 60.1, 60.0, 61.1, 61.0, 28.1, 28.0, 79.1, 79.0, 79.0, 29.1, 29.0, 76.1, 76.0, 30.1, 30.0, 77.1, 77.0, 31.1, 31.0, 32.1, 32.0, 78.1, 78.0, 72.1, 72.0, 62.1, 62.0, 73.1, 73.0, 79.1, 79.0, 80.1, 80.0, 80.0, 81.1, 81.0, 81.0, 82.1, 82.0, 82.0, 33.1, 33.0, 83.1, 83.0, 83.0, 34.1, 34.0, 84.1, 84.0, 84.0, 35.1, 35.0, 80.1, 80.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 63.1, 63.0, 64.1, 64.0, 65.1, 65.0, 66.1, 66.0, 74.1, 74.0, 75.1, 75.0, 81.1, 81.0, 82.1, 82.0, 39.1, 39.0, 67.1, 67.0, 76.1, 76.0, 77.1, 77.0, 40.1, 40.0, 78.1, 78.0, 41.1, 41.0, 83.1, 83.0, 42.1, 42.0, 84.1, 84.0, 43.1, 43.0, 79.1, 79.0, 44.1, 44.0, 68.1, 68.0, 69.1, 69.0, 70.1, 70.0, 71.1, 71.0, 85.1, 85.0, 85.0, 86.1, 86.0, 86.0, 80.1, 80.0, 87.1, 87.0, 87.0, 88.1, 88.0, 88.0, 89.1, 89.0, 89.0, 90.1, 90.0, 90.0, 85.1, 85.0, 86.1, 86.0, 91.1, 91.0, 91.0, 87.1, 87.0, 81.1, 81.0, 82.1, 82.0, 88.1, 88.0, 45.1, 45.0, 89.1, 89.0, 90.1, 90.0, 91.1, 91.0, 92.1, 92.0, 92.0, 83.1, 83.0, 93.1, 93.0, 93.0, 84.1, 84.0, 94.1, 94.0, 94.0, 95.1, 95.0, 95.0, 96.1, 96.0, 96.0, 92.1, 92.0, 46.1, 46.0, 72.1, 72.0, 47.1, 47.0, 73.1, 73.0, 48.1, 48.0, 93.1, 93.0, 94.1, 94.0, 95.1, 95.0, 96.1, 96.0, 97.1, 97.0, 97.0, 85.1, 85.0, 49.1, 49.0, 86.1, 86.0, 50.1, 50.0, 87.1, 87.0, 98.1, 98.0, 98.0, 88.1, 88.0, 51.1, 51.0, 89.1, 89.0, 52.1, 52.0, 90.1, 90.0, 53.1, 53.0, 91.1, 91.0, 54.1, 54.0, 74.1, 74.0, 75.1, 75.0, 97.1, 97.0, 98.1, 98.0, 99.1, 99.0, 99.0, 92.1, 92.0, 76.1, 76.0, 77.1, 77.0, 78.1, 78.0, 55.1, 55.0, 100.1, 100.0, 100.0, 56.1, 56.0, 93.1, 93.0, 57.1, 57.0, 79.1, 79.0, 58.1, 58.0, 94.1, 94.0, 59.1, 59.0, 95.1, 95.0, 96.1, 96.0, 99.1, 99.0, 100.1, 100.0, 80.1, 80.0, 101.1, 101.0, 101.0, 102.1, 102.0, 102.0, 103.1, 103.0, 103.0, 60.1, 60.0, 61.1, 61.0, 104.1, 104.0, 104.0, 105.1, 105.0, 105.0, 101.1, 101.0, 81.1, 81.0, 82.1, 82.0, 97.1, 97.0, 0.1, 0.0, 98.1, 98.0, 1.1, 1.0, 62.1, 62.0, 2.1, 2.0, 102.1, 102.0, 3.1, 3.0, 83.1, 83.0, 4.1, 4.0, 5.1, 5.0, 84.1, 84.0, 6.1, 6.0, 103.1, 103.0, 7.1, 7.0, 104.1, 104.0, 8.1, 8.0, 105.1, 105.0, 9.1, 9.0, 99.1, 99.0, 100.1, 100.0, 10.1, 10.0, 63.1, 63.0, 11.1, 11.0, 64.1, 64.0, 12.1, 12.0, 65.1, 65.0, 13.1, 13.0, 66.1, 66.0, 85.1, 85.0, 14.1, 14.0, 67.1, 67.0, 15.1, 15.0, 86.1, 86.0, 16.1, 16.0, 87.1, 87.0, 17.1, 17.0, 88.1, 88.0, 18.1, 18.0, 89.1, 89.0, 19.1, 19.0, 90.1, 90.0, 20.1, 20.0, 68.1, 68.0, 21.1, 21.0, 69.1, 69.0, 22.1, 22.0, 70.1, 70.0, 71.1, 71.0, 91.1, 91.0, 92.1, 92.0, 93.1, 93.0, 101.1, 101.0, 94.1, 94.0, 102.1, 102.0, 95.1, 95.0, 96.1, 96.0, 23.1, 23.0, 103.1, 103.0, 24.1, 24.0, 104.1, 104.0, 25.1, 25.0, 105.1, 105.0, 26.1, 26.0, 27.1, 27.0, 106.1, 106.0, 106.0, 107.1, 107.0, 107.0, 108.1, 108.0, 108.0, 109.1, 109.0, 109.0, 110.1, 110.0, 110.0, 97.1, 97.0, 111.1, 111.0, 111.0, 28.1, 28.0, 98.1, 98.0, 29.1, 29.0, 106.1, 106.0, 30.1, 30.0, 72.1, 72.0, 31.1, 31.0, 32.1, 32.0, 73.1, 73.0, 107.1, 107.0, 108.1, 108.0, 109.1, 109.0, 110.1, 110.0, 111.1, 111.0, 112.1, 112.0, 112.0, 99.1, 99.0, 33.1, 33.0, 100.1, 100.0, 34.1, 34.0, 113.1, 113.0, 113.0, 35.1, 35.0, 114.1, 114.0, 114.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 74.1, 74.0, 75.1, 75.0, 112.1, 112.0, 113.1, 113.0, 114.1, 114.0, 76.1, 76.0, 77.1, 77.0, 78.1, 78.0, 39.1, 39.0, 106.1, 106.0, 115.1, 115.0, 115.0, 40.1, 40.0, 79.1, 79.0, 41.1, 41.0, 107.1, 107.0, 42.1, 42.0, 108.1, 108.0, 43.1, 43.0, 109.1, 109.0, 44.1, 44.0, 80.1, 80.0, 110.1, 110.0, 111.1, 111.0, 115.1, 115.0, 101.1, 101.0, 116.1, 116.0, 116.0, 102.1, 102.0, 117.1, 117.0, 117.0, 118.1, 118.0, 118.0, 103.1, 103.0, 81.1, 81.0, 82.1, 82.0, 104.1, 104.0, 105.1, 105.0, 112.1, 112.0, 113.1, 113.0, 114.1, 114.0, 116.1, 116.0, 117.1, 117.0, 83.1, 83.0, 45.1, 45.0, 118.1, 118.0, 84.1, 84.0, 119.1, 119.0, 119.0, 120.1, 120.0, 120.0, 121.1, 121.0, 121.0, 122.1, 122.0, 122.0, 123.1, 123.0, 123.0, 124.1, 124.0, 124.0, 119.1, 119.0, 125.1, 125.0, 125.0, 46.1, 46.0, 115.1, 115.0, 47.1, 47.0, 120.1, 120.0, 48.1, 48.0, 121.1, 121.0, 85.1, 85.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 86.1, 86.0, 125.1, 125.0, 87.1, 87.0, 49.1, 49.0, 88.1, 88.0, 50.1, 50.0, 89.1, 89.0, 90.1, 90.0, 116.1, 116.0, 51.1, 51.0, 117.1, 117.0, 52.1, 52.0, 118.1, 118.0, 53.1, 53.0, 126.1, 126.0, 126.0, 54.1, 54.0, 127.1, 127.0, 127.0, 91.1, 91.0, 92.1, 92.0, 93.1, 93.0, 106.1, 106.0, 94.1, 94.0, 119.1, 119.0, 95.1, 95.0, 55.1, 55.0, 96.1, 96.0, 56.1, 56.0, 107.1, 107.0, 57.1, 57.0, 108.1, 108.0, 58.1, 58.0, 109.1, 109.0, 59.1, 59.0, 110.1, 110.0, 111.1, 111.0, 120.1, 120.0, 121.1, 121.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 97.1, 97.0, 125.1, 125.0, 60.1, 60.0, 61.1, 61.0, 98.1, 98.0, 112.1, 112.0, 113.1, 113.0, 114.1, 114.0, 126.1, 126.0, 127.1, 127.0, 128.1, 128.0, 128.0, 129.1, 129.0, 129.0, 62.1, 62.0, 130.1, 130.0, 130.0, 131.1, 131.0, 131.0, 99.1, 99.0, 132.1, 132.0, 132.0, 100.1, 100.0, 128.1, 128.0, 129.1, 129.0, 133.1, 133.0, 133.0, 130.1, 130.0, 134.1, 134.0, 134.0, 115.1, 115.0, 131.1, 131.0, 132.1, 132.0, 63.1, 63.0, 135.1, 135.0, 135.0, 64.1, 64.0, 133.1, 133.0, 65.1, 65.0, 134.1, 134.0, 66.1, 66.0, 136.1, 136.0, 136.0, 67.1, 67.0, 135.1, 135.0, 137.1, 137.0, 137.0, 138.1, 138.0, 138.0, 116.1, 116.0, 126.1, 126.0, 117.1, 117.0, 127.1, 127.0, 118.1, 118.0, 136.1, 136.0, 68.1, 68.0, 137.1, 137.0, 69.1, 69.0, 138.1, 138.0, 70.1, 70.0, 71.1, 71.0, 101.1, 101.0, 128.1, 128.0, 102.1, 102.0, 119.1, 119.0, 129.1, 129.0, 103.1, 103.0, 130.1, 130.0, 131.1, 131.0, 104.1, 104.0, 105.1, 105.0, 132.1, 132.0, 133.1, 133.0, 134.1, 134.0, 139.1, 139.0, 139.0, 140.1, 140.0, 140.0, 120.1, 120.0, 121.1, 121.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 135.1, 135.0, 125.1, 125.0, 139.1, 139.0, 140.1, 140.0, 136.1, 136.0, 141.1, 141.0, 141.0, 137.1, 137.0, 142.1, 142.0, 142.0, 138.1, 138.0, 72.1, 72.0, 143.1, 143.0, 143.0, 144.1, 144.0, 144.0, 73.1, 73.0, 141.1, 141.0, 145.1, 145.0, 145.0, 142.1, 142.0, 146.1, 146.0, 146.0, 147.1, 147.0, 147.0, 143.1, 143.0, 144.1, 144.0, 148.1, 148.0, 148.0, 145.1, 145.0, 149.1, 149.0, 149.0, 146.1, 146.0, 147.1, 147.0, 0.1, 0.0, 150.1, 150.0, 150.0, 1.1, 1.0, 74.1, 74.0, 2.1, 2.0, 75.1, 75.0, 3.1, 3.0, 139.1, 139.0, 4.1, 4.0, 5.1, 5.0, 76.1, 76.0, 6.1, 6.0, 77.1, 77.0, 7.1, 7.0, 78.1, 78.0, 8.1, 8.0, 79.1, 79.0, 9.1, 9.0, 106.1, 106.0, 107.1, 107.0, 10.1, 10.0, 108.1, 108.0, 11.1, 11.0, 80.1, 80.0, 12.1, 12.0, 109.1, 109.0, 13.1, 13.0, 110.1, 110.0, 111.1, 111.0, 14.1, 14.0, 126.1, 126.0, 15.1, 15.0, 127.1, 127.0, 16.1, 16.0, 81.1, 81.0, 17.1, 17.0, 82.1, 82.0, 18.1, 18.0, 112.1, 112.0, 19.1, 19.0, 113.1, 113.0, 20.1, 20.0, 114.1, 114.0, 21.1, 21.0, 83.1, 83.0, 22.1, 22.0, 128.1, 128.0, 84.1, 84.0, 129.1, 129.0, 130.1, 130.0, 131.1, 131.0, 132.1, 132.0, 133.1, 133.0, 115.1, 115.0, 134.1, 134.0, 135.1, 135.0, 136.1, 136.0, 23.1, 23.0, 137.1, 137.0, 24.1, 24.0, 138.1, 138.0, 25.1, 25.0, 140.1, 140.0, 26.1, 26.0, 27.1, 27.0, 85.1, 85.0, 141.1, 141.0, 142.1, 142.0, 86.1, 86.0, 87.1, 87.0, 116.1, 116.0, 88.1, 88.0, 117.1, 117.0, 89.1, 89.0, 28.1, 28.0, 90.1, 90.0, 29.1, 29.0, 118.1, 118.0, 30.1, 30.0, 139.1, 139.0, 31.1, 31.0, 32.1, 32.0, 143.1, 143.0, 91.1, 91.0, 92.1, 92.0, 93.1, 93.0, 119.1, 119.0, 94.1, 94.0, 144.1, 144.0, 95.1, 95.0, 145.1, 145.0, 33.1, 33.0, 96.1, 96.0, 34.1, 34.0, 146.1, 146.0, 35.1, 35.0, 120.1, 120.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 121.1, 121.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 125.1, 125.0, 97.1, 97.0, 147.1, 147.0, 148.1, 148.0, 39.1, 39.0, 149.1, 149.0, 98.1, 98.0, 150.1, 150.0, 40.1, 40.0, 151.1, 151.0, 151.0, 41.1, 41.0, 152.1, 152.0, 152.0, 42.1, 42.0, 153.1, 153.0, 153.0, 43.1, 43.0, 154.1, 154.0, 154.0, 44.1, 44.0, 155.1, 155.0, 155.0, 151.1, 151.0, 156.1, 156.0, 156.0, 99.1, 99.0, 152.1, 152.0, 100.1, 100.0, 153.1, 153.0, 154.1, 154.0, 157.1, 157.0, 157.0, 155.1, 155.0, 158.1, 158.0, 158.0, 156.1, 156.0, 159.1, 159.0, 159.0, 160.1, 160.0, 160.0, 140.1, 140.0, 161.1, 161.0, 161.0, 157.1, 157.0, 162.1, 162.0, 162.0, 158.1, 158.0, 141.1, 141.0, 142.1, 142.0, 148.1, 148.0, 45.1, 45.0, 149.1, 149.0, 150.1, 150.0, 159.1, 159.0, 160.1, 160.0, 161.1, 161.0, 162.1, 162.0, 163.1, 163.0, 163.0, 164.1, 164.0, 164.0, 165.1, 165.0, 165.0, 151.1, 151.0, 46.1, 46.0, 143.1, 143.0, 47.1, 47.0, 152.1, 152.0, 48.1, 48.0, 101.1, 101.0, 102.1, 102.0, 126.1, 126.0, 127.1, 127.0, 103.1, 103.0, 144.1, 144.0, 49.1, 49.0, 104.1, 104.0, 50.1, 50.0, 105.1, 105.0, 145.1, 145.0, 146.1, 146.0, 51.1, 51.0, 153.1, 153.0, 52.1, 52.0, 154.1, 154.0, 53.1, 53.0, 128.1, 128.0, 54.1, 54.0, 129.1, 129.0, 130.1, 130.0, 131.1, 131.0, 132.1, 132.0, 133.1, 133.0, 147.1, 147.0, 134.1, 134.0, 135.1, 135.0, 136.1, 136.0, 55.1, 55.0, 137.1, 137.0, 56.1, 56.0, 138.1, 138.0, 57.1, 57.0, 155.1, 155.0, 58.1, 58.0, 156.1, 156.0, 59.1, 59.0, 157.1, 157.0, 158.1, 158.0, 159.1, 159.0, 160.1, 160.0, 161.1, 161.0, 162.1, 162.0, 163.1, 163.0, 164.1, 164.0, 165.1, 165.0, 60.1, 60.0, 61.1, 61.0, 166.1, 166.0, 166.0, 139.1, 139.0, 167.1, 167.0, 167.0, 148.1, 148.0, 168.1, 168.0, 168.0, 149.1, 149.0, 150.1, 150.0, 169.1, 169.0, 169.0, 62.1, 62.0, 166.1, 166.0, 170.1, 170.0, 170.0, 167.1, 167.0, 171.1, 171.0, 171.0, 168.1, 168.0, 172.1, 172.0, 172.0, 169.1, 169.0, 151.1, 151.0, 106.1, 106.0, 107.1, 107.0, 108.1, 108.0, 152.1, 152.0, 170.1, 170.0, 63.1, 63.0, 109.1, 109.0, 64.1, 64.0, 110.1, 110.0, 65.1, 65.0, 111.1, 111.0, 66.1, 66.0, 163.1, 163.0, 67.1, 67.0, 164.1, 164.0, 165.1, 165.0, 171.1, 171.0, 112.1, 112.0, 153.1, 153.0, 113.1, 113.0, 154.1, 154.0, 114.1, 114.0, 172.1, 172.0, 166.1, 166.0, 173.1, 173.0, 173.0, 68.1, 68.0, 167.1, 167.0, 69.1, 69.0, 168.1, 168.0, 70.1, 70.0, 71.1, 71.0, 169.1, 169.0, 173.1, 173.0, 115.1, 115.0, 174.1, 174.0, 174.0, 170.1, 170.0, 175.1, 175.0, 175.0, 140.1, 140.0, 155.1, 155.0, 156.1, 156.0, 176.1, 176.0, 176.0, 141.1, 141.0, 142.1, 142.0, 157.1, 157.0, 158.1, 158.0, 159.1, 159.0, 160.1, 160.0, 116.1, 116.0, 161.1, 161.0, 117.1, 117.0, 162.1, 162.0, 171.1, 171.0, 172.1, 172.0, 174.1, 174.0, 118.1, 118.0, 175.1, 175.0, 176.1, 176.0, 177.1, 177.0, 177.0, 143.1, 143.0, 72.1, 72.0, 178.1, 178.0, 178.0, 179.1, 179.0, 179.0, 73.1, 73.0, 173.1, 173.0, 119.1, 119.0, 177.1, 177.0, 180.1, 180.0, 180.0, 144.1, 144.0, 181.1, 181.0, 181.0, 178.1, 178.0, 179.1, 179.0, 182.1, 182.0, 182.0, 145.1, 145.0, 146.1, 146.0, 120.1, 120.0, 180.1, 180.0, 181.1, 181.0, 183.1, 183.0, 183.0, 121.1, 121.0, 122.1, 122.0, 74.1, 74.0, 123.1, 123.0, 75.1, 75.0, 124.1, 124.0, 125.1, 125.0, 147.1, 147.0, 76.1, 76.0, 163.1, 163.0, 77.1, 77.0, 164.1, 164.0, 78.1, 78.0, 165.1, 165.0, 79.1, 79.0, 166.1, 166.0, 167.1, 167.0, 174.1, 174.0, 168.1, 168.0, 175.1, 175.0, 80.1, 80.0, 176.1, 176.0, 169.1, 169.0, 177.1, 177.0, 178.1, 178.0, 179.1, 179.0, 182.1, 182.0, 170.1, 170.0, 180.1, 180.0, 181.1, 181.0, 81.1, 81.0, 183.1, 183.0, 82.1, 82.0, 184.1, 184.0, 184.0, 185.1, 185.0, 185.0, 148.1, 148.0, 186.1, 186.0, 186.0, 83.1, 83.0, 149.1, 149.0, 150.1, 150.0, 84.1, 84.0, 184.1, 184.0, 185.1, 185.0, 171.1, 171.0, 172.1, 172.0, 186.1, 186.0, 187.1, 187.0, 187.0, 151.1, 151.0, 188.1, 188.0, 188.0, 189.1, 189.0, 189.0, 152.1, 152.0, 190.1, 190.0, 190.0, 173.1, 173.0, 187.1, 187.0, 182.1, 182.0, 191.1, 191.0, 191.0, 85.1, 85.0, 188.1, 188.0, 189.1, 189.0, 86.1, 86.0, 87.1, 87.0, 126.1, 126.0, 88.1, 88.0, 127.1, 127.0, 89.1, 89.0, 183.1, 183.0, 90.1, 90.0, 153.1, 153.0, 154.1, 154.0, 190.1, 190.0, 191.1, 191.0, 184.1, 184.0, 185.1, 185.0, 128.1, 128.0, 91.1, 91.0, 92.1, 92.0, 93.1, 93.0, 129.1, 129.0, 94.1, 94.0, 130.1, 130.0, 95.1, 95.0, 131.1, 131.0, 132.1, 132.0, 96.1, 96.0, 133.1, 133.0, 134.1, 134.0, 135.1, 135.0, 136.1, 136.0, 137.1, 137.0, 138.1, 138.0, 155.1, 155.0, 156.1, 156.0, 157.1, 157.0, 158.1, 158.0, 159.1, 159.0, 160.1, 160.0, 97.1, 97.0, 161.1, 161.0, 162.1, 162.0, 174.1, 174.0, 98.1, 98.0, 175.1, 175.0, 176.1, 176.0, 139.1, 139.0, 0.1, 0.0, 177.1, 177.0, 1.1, 1.0, 178.1, 178.0, 2.1, 2.0, 179.1, 179.0, 3.1, 3.0, 180.1, 180.0, 4.1, 4.0, 5.1, 5.0, 99.1, 99.0, 6.1, 6.0, 100.1, 100.0, 7.1, 7.0, 181.1, 181.0, 8.1, 8.0, 186.1, 186.0, 9.1, 9.0, 187.1, 187.0, 188.1, 188.0, 10.1, 10.0, 182.1, 182.0, 11.1, 11.0, 189.1, 189.0, 12.1, 12.0, 190.1, 190.0, 13.1, 13.0, 191.1, 191.0, 192.1, 192.0, 192.0, 14.1, 14.0, 193.1, 193.0, 193.0, 15.1, 15.0, 183.1, 183.0, 16.1, 16.0, 194.1, 194.0, 194.0, 17.1, 17.0, 163.1, 163.0, 18.1, 18.0, 164.1, 164.0, 19.1, 19.0, 165.1, 165.0, 20.1, 20.0, 166.1, 166.0, 21.1, 21.0, 167.1, 167.0, 22.1, 22.0, 168.1, 168.0, 169.1, 169.0, 184.1, 184.0, 185.1, 185.0, 101.1, 101.0, 102.1, 102.0, 170.1, 170.0, 192.1, 192.0, 103.1, 103.0, 193.1, 193.0, 23.1, 23.0, 104.1, 104.0, 24.1, 24.0, 105.1, 105.0, 25.1, 25.0, 140.1, 140.0, 26.1, 26.0, 27.1, 27.0, 141.1, 141.0, 142.1, 142.0, 194.1, 194.0, 171.1, 171.0, 172.1, 172.0, 195.1, 195.0, 195.0, 196.1, 196.0, 196.0, 28.1, 28.0, 197.1, 197.0, 197.0, 29.1, 29.0, 198.1, 198.0, 198.0, 30.1, 30.0, 199.1, 199.0, 199.0, 31.1, 31.0, 32.1, 32.0, 143.1, 143.0, 173.1, 173.0, 195.1, 195.0, 196.1, 196.0, 192.1, 192.0, 197.1, 197.0, 193.1, 193.0, 198.1, 198.0, 144.1, 144.0, 33.1, 33.0, 186.1, 186.0, 34.1, 34.0, 187.1, 187.0, 35.1, 35.0, 145.1, 145.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 146.1, 146.0, 188.1, 188.0, 189.1, 189.0, 190.1, 190.0, 191.1, 191.0, 194.1, 194.0, 199.1, 199.0, 200.1, 200.0, 200.0, 39.1, 39.0, 147.1, 147.0, 40.1, 40.0, 41.1, 41.0, 42.1, 42.0, 106.1, 106.0, 43.1, 43.0, 107.1, 107.0, 44.1, 44.0, 108.1, 108.0, 109.1, 109.0, 195.1, 195.0, 110.1, 110.0, 196.1, 196.0, 111.1, 111.0, 197.1, 197.0, 198.1, 198.0, 174.1, 174.0, 200.1, 200.0, 175.1, 175.0, 176.1, 176.0, 112.1, 112.0, 113.1, 113.0, 177.1, 177.0, 114.1, 114.0, 148.1, 148.0, 178.1, 178.0, 179.1, 179.0, 149.1, 149.0, 150.1, 150.0, 45.1, 45.0, 180.1, 180.0, 199.1, 199.0, 181.1, 181.0, 115.1, 115.0, 151.1, 151.0, 182.1, 182.0, 152.1, 152.0, 46.1, 46.0, 47.1, 47.0, 192.1, 192.0, 48.1, 48.0, 193.1, 193.0, 183.1, 183.0, 200.1, 200.0, 116.1, 116.0, 117.1, 117.0, 49.1, 49.0, 50.1, 50.0, 118.1, 118.0, 153.1, 153.0, 51.1, 51.0, 154.1, 154.0, 52.1, 52.0, 53.1, 53.0, 184.1, 184.0, 54.1, 54.0, 185.1, 185.0, 194.1, 194.0, 119.1, 119.0, 55.1, 55.0, 56.1, 56.0, 120.1, 120.0, 57.1, 57.0, 195.1, 195.0, 58.1, 58.0, 155.1, 155.0, 121.1, 121.0, 59.1, 59.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 125.1, 125.0, 156.1, 156.0, 157.1, 157.0, 158.1, 158.0, 159.1, 159.0, 160.1, 160.0, 60.1, 60.0, 61.1, 61.0, 161.1, 161.0, 162.1, 162.0, 196.1, 196.0, 197.1, 197.0, 198.1, 198.0, 199.1, 199.0, 62.1, 62.0, 186.1, 186.0, 187.1, 187.0, 188.1, 188.0, 189.1, 189.0, 190.1, 190.0, 191.1, 191.0, 63.1, 63.0, 200.1, 200.0, 64.1, 64.0, 65.1, 65.0, 66.1, 66.0, 163.1, 163.0, 67.1, 67.0, 164.1, 164.0, 165.1, 165.0, 166.1, 166.0, 167.1, 167.0, 168.1, 168.0, 169.1, 169.0, 68.1, 68.0, 69.1, 69.0, 70.1, 70.0, 71.1, 71.0, 126.1, 126.0, 170.1, 170.0, 127.1, 127.0, 128.1, 128.0, 171.1, 171.0, 172.1, 172.0, 129.1, 129.0, 130.1, 130.0, 131.1, 131.0, 132.1, 132.0, 133.1, 133.0, 134.1, 134.0, 135.1, 135.0, 136.1, 136.0, 137.1, 137.0, 138.1, 138.0, 72.1, 72.0, 173.1, 173.0, 192.1, 192.0, 73.1, 73.0, 193.1, 193.0, 139.1, 139.0, 74.1, 74.0, 194.1, 194.0, 75.1, 75.0, 76.1, 76.0, 77.1, 77.0, 78.1, 78.0, 79.1, 79.0, 195.1, 195.0, 80.1, 80.0, 174.1, 174.0, 175.1, 175.0, 81.1, 81.0, 176.1, 176.0, 82.1, 82.0, 177.1, 177.0, 178.1, 178.0, 179.1, 179.0, 196.1, 196.0, 83.1, 83.0, 197.1, 197.0, 198.1, 198.0, 84.1, 84.0, 180.1, 180.0, 181.1, 181.0, 199.1, 199.0, 182.1, 182.0, 140.1, 140.0, 141.1, 141.0, 142.1, 142.0, 85.1, 85.0, 183.1, 183.0, 200.1, 200.0, 86.1, 86.0, 87.1, 87.0, 88.1, 88.0, 89.1, 89.0, 90.1, 90.0, 143.1, 143.0, 184.1, 184.0, 91.1, 91.0, 92.1, 92.0, 93.1, 93.0, 185.1, 185.0, 94.1, 94.0, 144.1, 144.0, 95.1, 95.0, 96.1, 96.0, 145.1, 145.0, 146.1, 146.0, 97.1, 97.0, 147.1, 147.0, 98.1, 98.0, 99.1, 99.0, 100.1, 100.0, 186.1, 186.0, 187.1, 187.0, 188.1, 188.0, 148.1, 148.0, 189.1, 189.0, 190.1, 190.0, 149.1, 149.0, 150.1, 150.0, 191.1, 191.0, 151.1, 151.0, 152.1, 152.0, 101.1, 101.0, 102.1, 102.0, 103.1, 103.0, 104.1, 104.0, 105.1, 105.0, 153.1, 153.0, 154.1, 154.0, 155.1, 155.0, 192.1, 192.0, 193.1, 193.0, 156.1, 156.0, 157.1, 157.0, 158.1, 158.0, 159.1, 159.0, 160.1, 160.0, 161.1, 161.0, 162.1, 162.0, 194.1, 194.0, 106.1, 106.0, 107.1, 107.0, 108.1, 108.0, 109.1, 109.0, 195.1, 195.0, 110.1, 110.0, 111.1, 111.0, 163.1, 163.0, 0.1, 0.0, 112.1, 112.0, 1.1, 1.0, 113.1, 113.0, 2.1, 2.0, 114.1, 114.0, 3.1, 3.0, 164.1, 164.0, 4.1, 4.0, 5.1, 5.0, 165.1, 165.0, 6.1, 6.0, 166.1, 166.0, 7.1, 7.0, 167.1, 167.0, 8.1, 8.0, 168.1, 168.0, 9.1, 9.0, 115.1, 115.0, 169.1, 169.0, 10.1, 10.0, 170.1, 170.0, 11.1, 11.0, 196.1, 196.0, 12.1, 12.0, 197.1, 197.0, 13.1, 13.0, 198.1, 198.0, 199.1, 199.0, 14.1, 14.0, 171.1, 171.0, 15.1, 15.0, 172.1, 172.0, 16.1, 16.0, 200.1, 200.0, 17.1, 17.0, 116.1, 116.0, 18.1, 18.0, 117.1, 117.0, 19.1, 19.0, 20.1, 20.0, 21.1, 21.0, 118.1, 118.0, 22.1, 22.0, 173.1, 173.0, 119.1, 119.0, 23.1, 23.0, 24.1, 24.0, 25.1, 25.0, 120.1, 120.0, 26.1, 26.0, 27.1, 27.0, 121.1, 121.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 125.1, 125.0, 28.1, 28.0, 29.1, 29.0, 30.1, 30.0, 31.1, 31.0, 32.1, 32.0, 174.1, 174.0, 33.1, 33.0, 175.1, 175.0, 34.1, 34.0, 176.1, 176.0, 35.1, 35.0, 177.1, 177.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 178.1, 178.0, 179.1, 179.0, 180.1, 180.0, 181.1, 181.0, 39.1, 39.0, 182.1, 182.0, 40.1, 40.0, 41.1, 41.0, 42.1, 42.0, 43.1, 43.0, 44.1, 44.0, 183.1, 183.0, 126.1, 126.0, 127.1, 127.0, 184.1, 184.0, 128.1, 128.0, 45.1, 45.0, 185.1, 185.0, 129.1, 129.0, 130.1, 130.0, 131.1, 131.0, 132.1, 132.0, 133.1, 133.0, 134.1, 134.0, 135.1, 135.0, 136.1, 136.0, 46.1, 46.0, 137.1, 137.0, 47.1, 47.0, 138.1, 138.0, 48.1, 48.0, 49.1, 49.0, 50.1, 50.0, 139.1, 139.0, 51.1, 51.0, 52.1, 52.0, 53.1, 53.0, 54.1, 54.0, 186.1, 186.0, 187.1, 187.0, 55.1, 55.0, 188.1, 188.0, 56.1, 56.0, 189.1, 189.0, 57.1, 57.0, 190.1, 190.0, 58.1, 58.0, 191.1, 191.0, 59.1, 59.0, 60.1, 60.0, 61.1, 61.0, 62.1, 62.0, 140.1, 140.0, 63.1, 63.0, 141.1, 141.0, 64.1, 64.0, 142.1, 142.0, 65.1, 65.0, 66.1, 66.0, 67.1, 67.0, 143.1, 143.0, 192.1, 192.0, 68.1, 68.0, 193.1, 193.0, 69.1, 69.0, 70.1, 70.0, 71.1, 71.0, 144.1, 144.0, 145.1, 145.0, 146.1, 146.0, 194.1, 194.0, 147.1, 147.0, 72.1, 72.0, 73.1, 73.0, 148.1, 148.0, 149.1, 149.0, 74.1, 74.0, 150.1, 150.0, 75.1, 75.0, 76.1, 76.0, 77.1, 77.0, 151.1, 151.0, 78.1, 78.0, 79.1, 79.0, 152.1, 152.0, 80.1, 80.0, 81.1, 81.0, 82.1, 82.0, 83.1, 83.0, 84.1, 84.0, 85.1, 85.0, 86.1, 86.0, 87.1, 87.0, 88.1, 88.0, 89.1, 89.0, 90.1, 90.0, 91.1, 91.0, 92.1, 92.0, 93.1, 93.0, 94.1, 94.0, 95.1, 95.0, 96.1, 96.0, 97.1, 97.0, 98.1, 98.0}

// Advanced multi = 40
var Advanced = []float32{0.1, 0.0, 0.0, 1.1, 1.0, 1.0, 2.1, 2.0, 2.0, 3.1, 3.0, 3.0, 4.1, 4.0, 4.0, 5.1, 5.0, 5.0, 6.1, 6.0, 6.0, 7.1, 7.0, 7.0, 8.1, 8.0, 8.0, 9.1, 9.0, 9.0, 10.1, 10.0, 10.0, 11.1, 11.0, 11.0, 12.1, 12.0, 12.0, 13.1, 13.0, 13.0, 0.1, 0.0, 14.1, 14.0, 14.0, 1.1, 1.0, 15.1, 15.0, 15.0, 2.1, 2.0, 16.1, 16.0, 16.0, 3.1, 3.0, 17.1, 17.0, 17.0, 4.1, 4.0, 18.1, 18.0, 18.0, 5.1, 5.0, 19.1, 19.0, 19.0, 6.1, 6.0, 20.1, 20.0, 20.0, 7.1, 7.0, 21.1, 21.0, 21.0, 8.1, 8.0, 22.1, 22.0, 22.0, 9.1, 9.0, 23.1, 23.0, 23.0, 10.1, 10.0, 24.1, 24.0, 24.0, 11.1, 11.0, 25.1, 25.0, 25.0, 12.1, 12.0, 26.1, 26.0, 26.0, 13.1, 13.0, 27.1, 27.0, 27.0, 14.1, 14.0, 28.1, 28.0, 28.0, 15.1, 15.0, 29.1, 29.0, 29.0, 16.1, 16.0, 30.1, 30.0, 30.0, 17.1, 17.0, 31.1, 31.0, 31.0, 18.1, 18.0, 32.1, 32.0, 32.0, 19.1, 19.0, 33.1, 33.0, 33.0, 20.1, 20.0, 34.1, 34.0, 34.0, 21.1, 21.0, 35.1, 35.0, 35.0, 22.1, 22.0, 36.1, 36.0, 36.0, 23.1, 23.0, 37.1, 37.0, 37.0, 24.1, 24.0, 38.1, 38.0, 38.0, 25.1, 25.0, 39.1, 39.0, 39.0, 26.1, 26.0, 40.1, 40.0, 40.0, 27.1, 27.0, 41.1, 41.0, 41.0, 28.1, 28.0, 42.1, 42.0, 42.0, 29.1, 29.0, 43.1, 43.0, 43.0, 30.1, 30.0, 44.1, 44.0, 44.0, 31.1, 31.0, 45.1, 45.0, 45.0, 32.1, 32.0, 46.1, 46.0, 46.0, 33.1, 33.0, 47.1, 47.0, 47.0, 34.1, 34.0, 48.1, 48.0, 48.0, 35.1, 35.0, 49.1, 49.0, 49.0, 36.1, 36.0, 50.1, 50.0, 50.0, 37.1, 37.0, 51.1, 51.0, 51.0, 38.1, 38.0, 52.1, 52.0, 52.0, 39.1, 39.0, 53.1, 53.0, 53.0, 40.1, 40.0, 54.1, 54.0, 54.0, 41.1, 41.0, 55.1, 55.0, 55.0, 42.1, 42.0, 56.1, 56.0, 56.0, 43.1, 43.0, 57.1, 57.0, 57.0, 44.1, 44.0, 58.1, 58.0, 58.0, 45.1, 45.0, 59.1, 59.0, 59.0, 46.1, 46.0, 60.1, 60.0, 60.0, 47.1, 47.0, 61.1, 61.0, 61.0, 48.1, 48.0, 62.1, 62.0, 62.0, 49.1, 49.0, 63.1, 63.0, 63.0, 50.1, 50.0, 64.1, 64.0, 64.0, 51.1, 51.0, 65.1, 65.0, 65.0, 52.1, 52.0, 66.1, 66.0, 66.0, 53.1, 53.0, 0.1, 0.0, 54.1, 54.0, 1.1, 1.0, 55.1, 55.0, 2.1, 2.0, 56.1, 56.0, 3.1, 3.0, 57.1, 57.0, 4.1, 4.0, 58.1, 58.0, 5.1, 5.0, 59.1, 59.0, 6.1, 6.0, 60.1, 60.0, 7.1, 7.0, 61.1, 61.0, 8.1, 8.0, 62.1, 62.0, 9.1, 9.0, 63.1, 63.0, 10.1, 10.0, 64.1, 64.0, 11.1, 11.0, 65.1, 65.0, 12.1, 12.0, 66.1, 66.0, 13.1, 13.0, 67.1, 67.0, 67.0, 14.1, 14.0, 68.1, 68.0, 68.0, 15.1, 15.0, 69.1, 69.0, 69.0, 16.1, 16.0, 70.1, 70.0, 70.0, 17.1, 17.0, 71.1, 71.0, 71.0, 18.1, 18.0, 72.1, 72.0, 72.0, 19.1, 19.0, 73.1, 73.0, 73.0, 20.1, 20.0, 74.1, 74.0, 74.0, 21.1, 21.0, 75.1, 75.0, 75.0, 22.1, 22.0, 76.1, 76.0, 76.0, 23.1, 23.0, 77.1, 77.0, 77.0, 24.1, 24.0, 78.1, 78.0, 78.0, 25.1, 25.0, 79.1, 79.0, 79.0, 26.1, 26.0, 80.1, 80.0, 80.0, 27.1, 27.0, 67.1, 67.0, 28.1, 28.0, 68.1, 68.0, 29.1, 29.0, 69.1, 69.0, 30.1, 30.0, 70.1, 70.0, 31.1, 31.0, 71.1, 71.0, 32.1, 32.0, 72.1, 72.0, 33.1, 33.0, 73.1, 73.0, 34.1, 34.0, 74.1, 74.0, 35.1, 35.0, 75.1, 75.0, 36.1, 36.0, 76.1, 76.0, 37.1, 37.0, 77.1, 77.0, 38.1, 38.0, 78.1, 78.0, 39.1, 39.0, 79.1, 79.0, 40.1, 40.0, 80.1, 80.0, 41.1, 41.0, 81.1, 81.0, 81.0, 42.1, 42.0, 82.1, 82.0, 82.0, 43.1, 43.0, 83.1, 83.0, 83.0, 44.1, 44.0, 84.1, 84.0, 84.0, 45.1, 45.0, 85.1, 85.0, 85.0, 46.1, 46.0, 86.1, 86.0, 86.0, 47.1, 47.0, 87.1, 87.0, 87.0, 48.1, 48.0, 88.1, 88.0, 88.0, 49.1, 49.0, 89.1, 89.0, 89.0, 50.1, 50.0, 90.1, 90.0, 90.0, 51.1, 51.0, 91.1, 91.0, 91.0, 52.1, 52.0, 53.1, 53.0, 92.1, 92.0, 92.0, 54.1, 54.0, 93.1, 93.0, 93.0, 55.1, 55.0, 81.1, 81.0, 56.1, 56.0, 82.1, 82.0, 57.1, 57.0, 83.1, 83.0, 58.1, 58.0, 84.1, 84.0, 59.1, 59.0, 85.1, 85.0, 60.1, 60.0, 86.1, 86.0, 61.1, 61.0, 87.1, 87.0, 62.1, 62.0, 88.1, 88.0, 63.1, 63.0, 89.1, 89.0, 64.1, 64.0, 90.1, 90.0, 65.1, 65.0, 91.1, 91.0, 66.1, 66.0, 92.1, 92.0, 93.1, 93.0, 94.1, 94.0, 94.0, 95.1, 95.0, 95.0, 96.1, 96.0, 96.0, 97.1, 97.0, 97.0, 98.1, 98.0, 98.0, 99.1, 99.0, 99.0, 100.1, 100.0, 100.0, 101.1, 101.0, 101.0, 102.1, 102.0, 102.0, 103.1, 103.0, 103.0, 104.1, 104.0, 104.0, 105.1, 105.0, 105.0, 106.1, 106.0, 106.0, 67.1, 67.0, 107.1, 107.0, 107.0, 68.1, 68.0, 94.1, 94.0, 69.1, 69.0, 95.1, 95.0, 70.1, 70.0, 96.1, 96.0, 71.1, 71.0, 97.1, 97.0, 72.1, 72.0, 98.1, 98.0, 73.1, 73.0, 99.1, 99.0, 74.1, 74.0, 100.1, 100.0, 75.1, 75.0, 101.1, 101.0, 76.1, 76.0, 102.1, 102.0, 77.1, 77.0, 103.1, 103.0, 78.1, 78.0, 104.1, 104.0, 79.1, 79.0, 105.1, 105.0, 80.1, 80.0, 106.1, 106.0, 107.1, 107.0, 108.1, 108.0, 108.0, 109.1, 109.0, 109.0, 110.1, 110.0, 110.0, 111.1, 111.0, 111.0, 112.1, 112.0, 112.0, 113.1, 113.0, 113.0, 114.1, 114.0, 114.0, 115.1, 115.0, 115.0, 116.1, 116.0, 116.0, 117.1, 117.0, 117.0, 118.1, 118.0, 118.0, 119.1, 119.0, 119.0, 120.1, 120.0, 120.0, 81.1, 81.0, 121.1, 121.0, 121.0, 82.1, 82.0, 108.1, 108.0, 83.1, 83.0, 109.1, 109.0, 84.1, 84.0, 110.1, 110.0, 85.1, 85.0, 111.1, 111.0, 86.1, 86.0, 112.1, 112.0, 87.1, 87.0, 113.1, 113.0, 88.1, 88.0, 114.1, 114.0, 89.1, 89.0, 115.1, 115.0, 90.1, 90.0, 116.1, 116.0, 91.1, 91.0, 117.1, 117.0, 92.1, 92.0, 0.1, 0.0, 93.1, 93.0, 1.1, 1.0, 118.1, 118.0, 2.1, 2.0, 119.1, 119.0, 3.1, 3.0, 120.1, 120.0, 4.1, 4.0, 121.1, 121.0, 5.1, 5.0, 122.1, 122.0, 122.0, 6.1, 6.0, 123.1, 123.0, 123.0, 7.1, 7.0, 124.1, 124.0, 124.0, 8.1, 8.0, 125.1, 125.0, 125.0, 9.1, 9.0, 126.1, 126.0, 126.0, 10.1, 10.0, 127.1, 127.0, 127.0, 11.1, 11.0, 128.1, 128.0, 128.0, 12.1, 12.0, 129.1, 129.0, 129.0, 13.1, 13.0, 130.1, 130.0, 130.0, 14.1, 14.0, 94.1, 94.0, 15.1, 15.0, 95.1, 95.0, 16.1, 16.0, 96.1, 96.0, 17.1, 17.0, 97.1, 97.0, 18.1, 18.0, 98.1, 98.0, 19.1, 19.0, 99.1, 99.0, 20.1, 20.0, 100.1, 100.0, 21.1, 21.0, 101.1, 101.0, 22.1, 22.0, 102.1, 102.0, 23.1, 23.0, 103.1, 103.0, 24.1, 24.0, 104.1, 104.0, 25.1, 25.0, 105.1, 105.0, 26.1, 26.0, 106.1, 106.0, 27.1, 27.0, 107.1, 107.0, 28.1, 28.0, 122.1, 122.0, 29.1, 29.0, 123.1, 123.0, 30.1, 30.0, 124.1, 124.0, 31.1, 31.0, 125.1, 125.0, 32.1, 32.0, 126.1, 126.0, 33.1, 33.0, 127.1, 127.0, 34.1, 34.0, 128.1, 128.0, 35.1, 35.0, 129.1, 129.0, 36.1, 36.0, 130.1, 130.0, 37.1, 37.0, 108.1, 108.0, 38.1, 38.0, 109.1, 109.0, 39.1, 39.0, 110.1, 110.0, 40.1, 40.0, 111.1, 111.0, 41.1, 41.0, 112.1, 112.0, 42.1, 42.0, 113.1, 113.0, 43.1, 43.0, 114.1, 114.0, 44.1, 44.0, 115.1, 115.0, 45.1, 45.0, 116.1, 116.0, 46.1, 46.0, 117.1, 117.0, 47.1, 47.0, 118.1, 118.0, 48.1, 48.0, 119.1, 119.0, 49.1, 49.0, 120.1, 120.0, 50.1, 50.0, 121.1, 121.0, 51.1, 51.0, 131.1, 131.0, 131.0, 52.1, 52.0, 53.1, 53.0, 132.1, 132.0, 132.0, 54.1, 54.0, 133.1, 133.0, 133.0, 55.1, 55.0, 134.1, 134.0, 134.0, 56.1, 56.0, 135.1, 135.0, 135.0, 57.1, 57.0, 136.1, 136.0, 136.0, 58.1, 58.0, 137.1, 137.0, 137.0, 59.1, 59.0, 138.1, 138.0, 138.0, 60.1, 60.0, 139.1, 139.0, 139.0, 61.1, 61.0, 140.1, 140.0, 140.0, 62.1, 62.0, 141.1, 141.0, 141.0, 63.1, 63.0, 142.1, 142.0, 142.0, 64.1, 64.0, 143.1, 143.0, 143.0, 65.1, 65.0, 131.1, 131.0, 66.1, 66.0, 132.1, 132.0, 144.1, 144.0, 144.0, 133.1, 133.0, 145.1, 145.0, 145.0, 134.1, 134.0, 146.1, 146.0, 146.0, 135.1, 135.0, 147.1, 147.0, 147.0, 136.1, 136.0, 148.1, 148.0, 148.0, 137.1, 137.0, 149.1, 149.0, 149.0, 138.1, 138.0, 150.1, 150.0, 150.0, 139.1, 139.0, 151.1, 151.0, 151.0, 140.1, 140.0, 152.1, 152.0, 152.0, 141.1, 141.0, 153.1, 153.0, 153.0, 142.1, 142.0, 122.1, 122.0, 143.1, 143.0, 123.1, 123.0, 154.1, 154.0, 154.0, 124.1, 124.0, 155.1, 155.0, 155.0, 125.1, 125.0, 67.1, 67.0, 126.1, 126.0, 68.1, 68.0, 127.1, 127.0, 69.1, 69.0, 128.1, 128.0, 70.1, 70.0, 129.1, 129.0, 71.1, 71.0, 130.1, 130.0, 72.1, 72.0, 144.1, 144.0, 73.1, 73.0, 145.1, 145.0, 74.1, 74.0, 146.1, 146.0, 75.1, 75.0, 147.1, 147.0, 76.1, 76.0, 148.1, 148.0, 77.1, 77.0, 149.1, 149.0, 78.1, 78.0, 150.1, 150.0, 79.1, 79.0, 151.1, 151.0, 80.1, 80.0, 152.1, 152.0, 153.1, 153.0, 154.1, 154.0, 155.1, 155.0, 156.1, 156.0, 156.0, 157.1, 157.0, 157.0, 158.1, 158.0, 158.0, 159.1, 159.0, 159.0, 160.1, 160.0, 160.0, 161.1, 161.0, 161.0, 162.1, 162.0, 162.0, 163.1, 163.0, 163.0, 164.1, 164.0, 164.0, 165.1, 165.0, 165.0, 166.1, 166.0, 166.0, 167.1, 167.0, 167.0, 81.1, 81.0, 168.1, 168.0, 168.0, 82.1, 82.0, 169.1, 169.0, 169.0, 83.1, 83.0, 156.1, 156.0, 84.1, 84.0, 157.1, 157.0, 85.1, 85.0, 158.1, 158.0, 86.1, 86.0, 159.1, 159.0, 87.1, 87.0, 160.1, 160.0, 88.1, 88.0, 161.1, 161.0, 89.1, 89.0, 131.1, 131.0, 90.1, 90.0, 132.1, 132.0, 91.1, 91.0, 133.1, 133.0, 92.1, 92.0, 134.1, 134.0, 93.1, 93.0, 135.1, 135.0, 136.1, 136.0, 137.1, 137.0, 138.1, 138.0, 139.1, 139.0, 162.1, 162.0, 140.1, 140.0, 163.1, 163.0, 141.1, 141.0, 164.1, 164.0, 142.1, 142.0, 165.1, 165.0, 143.1, 143.0, 166.1, 166.0, 167.1, 167.0, 168.1, 168.0, 169.1, 169.0, 170.1, 170.0, 170.0, 171.1, 171.0, 171.0, 172.1, 172.0, 172.0, 173.1, 173.0, 173.0, 94.1, 94.0, 174.1, 174.0, 174.0, 95.1, 95.0, 175.1, 175.0, 175.0, 96.1, 96.0, 176.1, 176.0, 176.0, 97.1, 97.0, 144.1, 144.0, 98.1, 98.0, 145.1, 145.0, 99.1, 99.0, 146.1, 146.0, 100.1, 100.0, 147.1, 147.0, 101.1, 101.0, 148.1, 148.0, 102.1, 102.0, 149.1, 149.0, 103.1, 103.0, 150.1, 150.0, 104.1, 104.0, 151.1, 151.0, 105.1, 105.0, 152.1, 152.0, 106.1, 106.0, 153.1, 153.0, 107.1, 107.0, 154.1, 154.0, 155.1, 155.0, 170.1, 170.0, 171.1, 171.0, 172.1, 172.0, 173.1, 173.0, 174.1, 174.0, 175.1, 175.0, 176.1, 176.0, 177.1, 177.0, 177.0, 178.1, 178.0, 178.0, 179.1, 179.0, 179.0, 180.1, 180.0, 180.0, 108.1, 108.0, 181.1, 181.0, 181.0, 109.1, 109.0, 182.1, 182.0, 182.0, 110.1, 110.0, 156.1, 156.0, 111.1, 111.0, 157.1, 157.0, 112.1, 112.0, 158.1, 158.0, 113.1, 113.0, 159.1, 159.0, 114.1, 114.0, 160.1, 160.0, 115.1, 115.0, 161.1, 161.0, 116.1, 116.0, 177.1, 177.0, 117.1, 117.0, 178.1, 178.0, 118.1, 118.0, 179.1, 179.0, 119.1, 119.0, 180.1, 180.0, 120.1, 120.0, 181.1, 181.0, 121.1, 121.0, 182.1, 182.0, 183.1, 183.0, 183.0, 162.1, 162.0, 184.1, 184.0, 184.0, 163.1, 163.0, 185.1, 185.0, 185.0, 164.1, 164.0, 186.1, 186.0, 186.0, 165.1, 165.0, 187.1, 187.0, 187.0, 166.1, 166.0, 167.1, 167.0, 168.1, 168.0, 169.1, 169.0, 188.1, 188.0, 188.0, 189.1, 189.0, 189.0, 190.1, 190.0, 190.0, 191.1, 191.0, 191.0, 192.1, 192.0, 192.0, 193.1, 193.0, 193.0, 183.1, 183.0, 194.1, 194.0, 194.0, 184.1, 184.0, 195.1, 195.0, 195.0, 185.1, 185.0, 196.1, 196.0, 196.0, 186.1, 186.0, 197.1, 197.0, 197.0, 187.1, 187.0, 198.1, 198.0, 198.0, 199.1, 199.0, 199.0, 200.1, 200.0, 200.0, 188.1, 188.0, 189.1, 189.0, 190.1, 190.0, 191.1, 191.0, 122.1, 122.0, 192.1, 192.0, 123.1, 123.0, 193.1, 193.0, 124.1, 124.0, 194.1, 194.0, 125.1, 125.0, 170.1, 170.0, 126.1, 126.0, 171.1, 171.0, 127.1, 127.0, 172.1, 172.0, 128.1, 128.0, 173.1, 173.0, 129.1, 129.0, 174.1, 174.0, 130.1, 130.0, 175.1, 175.0, 176.1, 176.0, 195.1, 195.0, 196.1, 196.0, 197.1, 197.0, 198.1, 198.0, 199.1, 199.0, 200.1, 200.0, 0.1, 0.0, 1.1, 1.0, 2.1, 2.0, 3.1, 3.0, 4.1, 4.0, 177.1, 177.0, 5.1, 5.0, 178.1, 178.0, 6.1, 6.0, 179.1, 179.0, 7.1, 7.0, 180.1, 180.0, 8.1, 8.0, 181.1, 181.0, 9.1, 9.0, 182.1, 182.0, 10.1, 10.0, 11.1, 11.0, 12.1, 12.0, 13.1, 13.0, 14.1, 14.0, 15.1, 15.0, 16.1, 16.0, 17.1, 17.0, 18.1, 18.0, 19.1, 19.0, 20.1, 20.0, 21.1, 21.0, 183.1, 183.0, 22.1, 22.0, 184.1, 184.0, 23.1, 23.0, 131.1, 131.0, 24.1, 24.0, 132.1, 132.0, 25.1, 25.0, 133.1, 133.0, 26.1, 26.0, 134.1, 134.0, 27.1, 27.0, 135.1, 135.0, 28.1, 28.0, 136.1, 136.0, 29.1, 29.0, 137.1, 137.0, 30.1, 30.0, 138.1, 138.0, 31.1, 31.0, 139.1, 139.0, 32.1, 32.0, 140.1, 140.0, 33.1, 33.0, 141.1, 141.0, 34.1, 34.0, 142.1, 142.0, 35.1, 35.0, 143.1, 143.0, 36.1, 36.0, 185.1, 185.0, 37.1, 37.0, 186.1, 186.0, 38.1, 38.0, 187.1, 187.0, 39.1, 39.0, 188.1, 188.0, 40.1, 40.0, 144.1, 144.0, 41.1, 41.0, 145.1, 145.0, 42.1, 42.0, 146.1, 146.0, 43.1, 43.0, 147.1, 147.0, 44.1, 44.0, 148.1, 148.0, 45.1, 45.0, 149.1, 149.0, 46.1, 46.0, 150.1, 150.0, 47.1, 47.0, 151.1, 151.0, 48.1, 48.0, 152.1, 152.0, 49.1, 49.0, 153.1, 153.0, 50.1, 50.0, 154.1, 154.0, 51.1, 51.0, 155.1, 155.0, 52.1, 52.0, 53.1, 53.0, 189.1, 189.0, 54.1, 54.0, 190.1, 190.0, 55.1, 55.0, 191.1, 191.0, 56.1, 56.0, 192.1, 192.0, 57.1, 57.0, 193.1, 193.0, 58.1, 58.0, 156.1, 156.0, 59.1, 59.0, 157.1, 157.0, 60.1, 60.0, 158.1, 158.0, 61.1, 61.0, 159.1, 159.0, 62.1, 62.0, 160.1, 160.0, 63.1, 63.0, 161.1, 161.0, 64.1, 64.0, 194.1, 194.0, 65.1, 65.0, 195.1, 195.0, 66.1, 66.0, 196.1, 196.0, 197.1, 197.0, 198.1, 198.0, 162.1, 162.0, 199.1, 199.0, 163.1, 163.0, 200.1, 200.0, 164.1, 164.0, 165.1, 165.0, 166.1, 166.0, 167.1, 167.0, 168.1, 168.0, 169.1, 169.0, 67.1, 67.0, 68.1, 68.0, 69.1, 69.0, 70.1, 70.0, 71.1, 71.0, 72.1, 72.0, 73.1, 73.0, 74.1, 74.0, 75.1, 75.0, 76.1, 76.0, 77.1, 77.0, 78.1, 78.0, 79.1, 79.0, 80.1, 80.0, 170.1, 170.0, 171.1, 171.0, 172.1, 172.0, 173.1, 173.0, 174.1, 174.0, 175.1, 175.0, 176.1, 176.0, 81.1, 81.0, 82.1, 82.0, 83.1, 83.0, 84.1, 84.0, 85.1, 85.0, 86.1, 86.0, 177.1, 177.0, 87.1, 87.0, 178.1, 178.0, 88.1, 88.0, 179.1, 179.0, 89.1, 89.0, 180.1, 180.0, 90.1, 90.0, 181.1, 181.0, 91.1, 91.0, 182.1, 182.0, 92.1, 92.0, 93.1, 93.0, 183.1, 183.0, 184.1, 184.0, 94.1, 94.0, 95.1, 95.0, 96.1, 96.0, 97.1, 97.0, 98.1, 98.0, 99.1, 99.0, 100.1, 100.0, 101.1, 101.0, 102.1, 102.0, 103.1, 103.0, 104.1, 104.0, 105.1, 105.0, 106.1, 106.0, 107.1, 107.0, 185.1, 185.0, 186.1, 186.0, 187.1, 187.0, 188.1, 188.0, 108.1, 108.0, 109.1, 109.0, 110.1, 110.0, 111.1, 111.0, 112.1, 112.0, 113.1, 113.0, 114.1, 114.0, 115.1, 115.0, 116.1, 116.0, 117.1, 117.0, 118.1, 118.0, 119.1, 119.0, 189.1, 189.0, 120.1, 120.0, 190.1, 190.0, 121.1, 121.0, 191.1, 191.0, 192.1, 192.0, 193.1, 193.0, 194.1, 194.0, 195.1, 195.0, 196.1, 196.0, 197.1, 197.0, 198.1, 198.0, 199.1, 199.0, 200.1, 200.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 125.1, 125.0, 126.1, 126.0, 127.1, 127.0, 128.1, 128.0, 129.1, 129.0, 130.1, 130.0, 131.1, 131.0, 132.1, 132.0, 133.1, 133.0, 134.1, 134.0, 135.1, 135.0, 136.1, 136.0, 137.1, 137.0, 138.1, 138.0, 139.1, 139.0, 140.1, 140.0, 141.1, 141.0, 142.1, 142.0, 143.1, 143.0, 144.1, 144.0, 145.1, 145.0, 146.1, 146.0, 147.1, 147.0, 148.1, 148.0, 149.1, 149.0, 150.1, 150.0, 151.1, 151.0, 152.1, 152.0, 153.1, 153.0, 154.1, 154.0, 155.1, 155.0, 156.1, 156.0, 157.1, 157.0, 158.1, 158.0, 159.1, 159.0, 160.1, 160.0, 161.1, 161.0, 162.1, 162.0, 163.1, 163.0, 164.1, 164.0, 165.1, 165.0, 166.1, 166.0, 167.1, 167.0, 168.1, 168.0, 169.1, 169.0, 170.1, 170.0, 171.1, 171.0, 172.1, 172.0, 173.1, 173.0, 174.1, 174.0, 175.1, 175.0, 176.1, 176.0, 177.1, 177.0, 178.1, 178.0, 179.1, 179.0, 180.1, 180.0, 181.1, 181.0, 182.1, 182.0, 0.1, 0.0, 1.1, 1.0, 2.1, 2.0, 3.1, 3.0, 4.1, 4.0, 5.1, 5.0, 6.1, 6.0, 7.1, 7.0, 8.1, 8.0, 9.1, 9.0, 183.1, 183.0, 10.1, 10.0, 184.1, 184.0, 11.1, 11.0, 12.1, 12.0, 13.1, 13.0, 14.1, 14.0, 15.1, 15.0, 16.1, 16.0, 17.1, 17.0, 18.1, 18.0, 19.1, 19.0, 20.1, 20.0, 21.1, 21.0, 22.1, 22.0, 23.1, 23.0, 24.1, 24.0, 25.1, 25.0, 26.1, 26.0, 27.1, 27.0, 185.1, 185.0, 28.1, 28.0, 186.1, 186.0, 29.1, 29.0, 187.1, 187.0, 30.1, 30.0, 188.1, 188.0, 31.1, 31.0, 32.1, 32.0, 33.1, 33.0, 34.1, 34.0, 35.1, 35.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 39.1, 39.0, 40.1, 40.0, 41.1, 41.0, 42.1, 42.0, 43.1, 43.0, 44.1, 44.0, 45.1, 45.0, 46.1, 46.0, 189.1, 189.0, 47.1, 47.0, 190.1, 190.0, 48.1, 48.0, 191.1, 191.0, 49.1, 49.0, 192.1, 192.0, 50.1, 50.0, 193.1, 193.0, 51.1, 51.0, 52.1, 52.0, 53.1, 53.0, 54.1, 54.0, 55.1, 55.0, 56.1, 56.0, 57.1, 57.0, 58.1, 58.0, 194.1, 194.0, 59.1, 59.0, 195.1, 195.0, 60.1, 60.0, 196.1, 196.0, 61.1, 61.0, 197.1, 197.0, 62.1, 62.0, 198.1, 198.0, 63.1, 63.0, 199.1, 199.0, 64.1, 64.0, 200.1, 200.0, 65.1, 65.0, 66.1, 66.0, 67.1, 67.0, 68.1, 68.0, 69.1, 69.0, 70.1, 70.0, 71.1, 71.0, 72.1, 72.0, 73.1, 73.0, 74.1, 74.0, 75.1, 75.0, 76.1, 76.0, 77.1, 77.0, 78.1, 78.0, 79.1, 79.0, 80.1, 80.0, 81.1, 81.0, 82.1, 82.0, 83.1, 83.0, 84.1, 84.0, 85.1, 85.0, 86.1, 86.0, 87.1, 87.0, 88.1, 88.0, 89.1, 89.0, 90.1, 90.0, 91.1, 91.0, 92.1, 92.0, 93.1, 93.0, 94.1, 94.0, 95.1, 95.0, 96.1, 96.0, 97.1, 97.0, 98.1, 98.0, 99.1, 99.0, 100.1, 100.0, 101.1, 101.0, 102.1, 102.0, 103.1, 103.0, 104.1, 104.0, 105.1, 105.0, 106.1, 106.0, 107.1, 107.0, 108.1, 108.0, 109.1, 109.0, 110.1, 110.0, 111.1, 111.0, 112.1, 112.0, 113.1, 113.0, 114.1, 114.0, 115.1, 115.0, 116.1, 116.0, 117.1, 117.0, 118.1, 118.0, 119.1, 119.0, 120.1, 120.0, 121.1, 121.0, 122.1, 122.0, 123.1, 123.0, 124.1, 124.0, 125.1, 125.0, 126.1, 126.0, 127.1, 127.0, 128.1, 128.0, 129.1, 129.0, 130.1, 130.0, 131.1, 131.0, 132.1, 132.0, 133.1, 133.0, 134.1, 134.0, 135.1, 135.0, 136.1, 136.0, 137.1, 137.0, 138.1, 138.0, 139.1, 139.0, 140.1, 140.0, 141.1, 141.0, 142.1, 142.0, 143.1, 143.0, 144.1, 144.0, 145.1, 145.0, 146.1, 146.0, 147.1, 147.0, 148.1, 148.0, 149.1, 149.0, 150.1, 150.0, 151.1, 151.0, 152.1, 152.0, 153.1, 153.0, 154.1, 154.0, 155.1, 155.0, 156.1, 156.0, 157.1, 157.0, 158.1, 158.0, 159.1, 159.0, 160.1, 160.0, 161.1, 161.0, 162.1, 162.0, 163.1, 163.0, 164.1, 164.0, 165.1, 165.0, 166.1, 166.0, 167.1, 167.0, 168.1, 168.0, 169.1, 169.0, 170.1, 170.0, 171.1, 171.0, 172.1, 172.0, 173.1, 173.0, 174.1, 174.0, 175.1, 175.0, 176.1, 176.0, 177.1, 177.0, 178.1, 178.0, 179.1, 179.0, 180.1, 180.0, 181.1, 181.0, 182.1, 182.0, 183.1, 183.0, 184.1, 184.0, 185.1, 185.0, 186.1, 186.0, 187.1, 187.0, 188.1, 188.0, 189.1, 189.0, 190.1, 190.0, 191.1, 191.0, 192.1, 192.0, 193.1, 193.0, 194.1, 194.0, 195.1, 195.0, 196.1, 196.0, 197.1, 197.0, 198.1, 198.0, 199.1, 199.0, 200.1, 200.0, 0.1, 0.0, 1.1, 1.0, 2.1, 2.0, 3.1, 3.0, 4.1, 4.0, 5.1, 5.0, 6.1, 6.0, 7.1, 7.0, 8.1, 8.0, 9.1, 9.0, 10.1, 10.0, 11.1, 11.0, 12.1, 12.0, 13.1, 13.0, 14.1, 14.0, 15.1, 15.0, 16.1, 16.0, 17.1, 17.0, 18.1, 18.0, 19.1, 19.0, 20.1, 20.0, 21.1, 21.0, 22.1, 22.0, 23.1, 23.0, 24.1, 24.0, 25.1, 25.0, 26.1, 26.0, 27.1, 27.0, 28.1, 28.0, 29.1, 29.0, 30.1, 30.0, 31.1, 31.0, 32.1, 32.0, 33.1, 33.0, 34.1, 34.0, 35.1, 35.0, 36.1, 36.0, 37.1, 37.0, 38.1, 38.0, 39.1, 39.0, 40.1, 40.0, 41.1, 41.0, 42.1, 42.0, 43.1, 43.0, 44.1, 44.0, 45.1, 45.0, 46.1, 46.0, 47.1, 47.0, 48.1, 48.0, 49.1, 49.0, 50.1, 50.0, 51.1, 51.0, 52.1, 52.0, 53.1, 53.0, 54.1, 54.0, 55.1, 55.0, 56.1, 56.0, 57.1, 57.0, 58.1, 58.0, 59.1, 59.0, 60.1, 60.0, 61.1, 61.0, 62.1, 62.0, 63.1, 63.0, 64.1, 64.0, 65.1, 65.0, 66.1, 66.0}

// Review each phrase is only repeated one time
var Review = []float32{0.1, 0.0, 0.0, 1.1, 1.0, 1.0, 2.1, 2.0, 2.0, 3.1, 3.0, 3.0, 4.1, 4.0, 4.0, 5.1, 5.0, 5.0, 6.1, 6.0, 6.0, 7.1, 7.0, 7.0, 8.1, 8.0, 8.0, 9.1, 9.0, 9.0, 10.1, 10.0, 10.0, 11.1, 11.0, 11.0, 12.1, 12.0, 12.0, 13.1, 13.0, 13.0, 14.1, 14.0, 14.0, 15.1, 15.0, 15.0, 16.1, 16.0, 16.0, 17.1, 17.0, 17.0, 18.1, 18.0, 18.0, 19.1, 19.0, 19.0, 20.1, 20.0, 20.0, 21.1, 21.0, 21.0, 22.1, 22.0, 22.0, 23.1, 23.0, 23.0, 24.1, 24.0, 24.0, 25.1, 25.0, 25.0, 26.1, 26.0, 26.0, 27.1, 27.0, 27.0, 28.1, 28.0, 28.0, 29.1, 29.0, 29.0, 30.1, 30.0, 30.0, 31.1, 31.0, 31.0, 32.1, 32.0, 32.0, 33.1, 33.0, 33.0, 34.1, 34.0, 34.0, 35.1, 35.0, 35.0, 36.1, 36.0, 36.0, 37.1, 37.0, 37.0, 38.1, 38.0, 38.0, 39.1, 39.0, 39.0, 40.1, 40.0, 40.0, 41.1, 41.0, 41.0, 42.1, 42.0, 42.0, 43.1, 43.0, 43.0, 44.1, 44.0, 44.0, 45.1, 45.0, 45.0, 46.1, 46.0, 46.0, 47.1, 47.0, 47.0, 48.1, 48.0, 48.0, 49.1, 49.0, 49.0, 50.1, 50.0, 50.0, 51.1, 51.0, 51.0, 52.1, 52.0, 52.0, 53.1, 53.0, 53.0, 54.1, 54.0, 54.0, 55.1, 55.0, 55.0, 56.1, 56.0, 56.0, 57.1, 57.0, 57.0, 58.1, 58.0, 58.0, 59.1, 59.0, 59.0, 60.1, 60.0, 60.0, 61.1, 61.0, 61.0, 62.1, 62.0, 62.0, 63.1, 63.0, 63.0, 64.1, 64.0, 64.0, 65.1, 65.0, 65.0, 66.1, 66.0, 66.0, 67.1, 67.0, 67.0, 68.1, 68.0, 68.0, 69.1, 69.0, 69.0, 70.1, 70.0, 70.0, 71.1, 71.0, 71.0, 72.1, 72.0, 72.0, 73.1, 73.0, 73.0, 74.1, 74.0, 74.0, 75.1, 75.0, 75.0, 76.1, 76.0, 76.0, 77.1, 77.0, 77.0, 78.1, 78.0, 78.0, 79.1, 79.0, 79.0, 80.1, 80.0, 80.0, 81.1, 81.0, 81.0, 82.1, 82.0, 82.0, 83.1, 83.0, 83.0, 84.1, 84.0, 84.0, 85.1, 85.0, 85.0, 86.1, 86.0, 86.0, 87.1, 87.0, 87.0, 88.1, 88.0, 88.0, 89.1, 89.0, 89.0, 90.1, 90.0, 90.0, 91.1, 91.0, 91.0, 92.1, 92.0, 92.0, 93.1, 93.0, 93.0, 94.1, 94.0, 94.0, 95.1, 95.0, 95.0, 96.1, 96.0, 96.0, 97.1, 97.0, 97.0, 98.1, 98.0, 98.0, 99.1, 99.0, 99.0, 100.1, 100.0, 100.0, 101.1, 101.0, 101.0, 102.1, 102.0, 102.0, 103.1, 103.0, 103.0, 104.1, 104.0, 104.0, 105.1, 105.0, 105.0, 106.1, 106.0, 106.0, 107.1, 107.0, 107.0, 108.1, 108.0, 108.0, 109.1, 109.0, 109.0, 110.1, 110.0, 110.0, 111.1, 111.0, 111.0, 112.1, 112.0, 112.0, 113.1, 113.0, 113.0, 114.1, 114.0, 114.0, 115.1, 115.0, 115.0, 116.1, 116.0, 116.0, 117.1, 117.0, 117.0, 118.1, 118.0, 118.0, 119.1, 119.0, 119.0, 120.1, 120.0, 120.0, 121.1, 121.0, 121.0, 122.1, 122.0, 122.0, 123.1, 123.0, 123.0, 124.1, 124.0, 124.0, 125.1, 125.0, 125.0, 126.1, 126.0, 126.0, 127.1, 127.0, 127.0, 128.1, 128.0, 128.0, 129.1, 129.0, 129.0, 130.1, 130.0, 130.0, 131.1, 131.0, 131.0, 132.1, 132.0, 132.0, 133.1, 133.0, 133.0, 134.1, 134.0, 134.0, 135.1, 135.0, 135.0, 136.1, 136.0, 136.0, 137.1, 137.0, 137.0, 138.1, 138.0, 138.0, 139.1, 139.0, 139.0, 140.1, 140.0, 140.0, 141.1, 141.0, 141.0, 142.1, 142.0, 142.0, 143.1, 143.0, 143.0, 144.1, 144.0, 144.0, 145.1, 145.0, 145.0, 146.1, 146.0, 146.0, 147.1, 147.0, 147.0, 148.1, 148.0, 148.0, 149.1, 149.0, 149.0, 150.1, 150.0, 150.0, 151.1, 151.0, 151.0, 152.1, 152.0, 152.0, 153.1, 153.0, 153.0, 154.1, 154.0, 154.0, 155.1, 155.0, 155.0, 156.1, 156.0, 156.0, 157.1, 157.0, 157.0, 158.1, 158.0, 158.0, 159.1, 159.0, 159.0, 160.1, 160.0, 160.0, 161.1, 161.0, 161.0, 162.1, 162.0, 162.0, 163.1, 163.0, 163.0, 164.1, 164.0, 164.0, 165.1, 165.0, 165.0, 166.1, 166.0, 166.0, 167.1, 167.0, 167.0, 168.1, 168.0, 168.0, 169.1, 169.0, 169.0, 170.1, 170.0, 170.0, 171.1, 171.0, 171.0, 172.1, 172.0, 172.0, 173.1, 173.0, 173.0, 174.1, 174.0, 174.0, 175.1, 175.0, 175.0, 176.1, 176.0, 176.0, 177.1, 177.0, 177.0, 178.1, 178.0, 178.0, 179.1, 179.0, 179.0, 180.1, 180.0, 180.0, 181.1, 181.0, 181.0, 182.1, 182.0, 182.0, 183.1, 183.0, 183.0, 184.1, 184.0, 184.0, 185.1, 185.0, 185.0, 186.1, 186.0, 186.0, 187.1, 187.0, 187.0, 188.1, 188.0, 188.0, 189.1, 189.0, 189.0, 190.1, 190.0, 190.0, 191.1, 191.0, 191.0, 192.1, 192.0, 192.0, 193.1, 193.0, 193.0, 194.1, 194.0, 194.0, 195.1, 195.0, 195.0, 196.1, 196.0, 196.0, 197.1, 197.0, 197.0, 198.1, 198.0, 198.0, 199.1, 199.0, 199.0, 200.1, 200.0, 200.0}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "cloud.google.com/go/firestore"
        "context"
        "errors"
        firebase "firebase.google.com/go"
        "flag"
        _ "github.com/lib/pq"
        "talkliketv.click/tltv/internal/test"
        "talkliketv.click/tltv/internal/translates"
)

// Config Update the config struct to hold the SMTP server settings.
type Config struct {
        Port            string
        Env             string
        MaxNumPhrases   int
        TTSBasePath     string
        FileUploadLimit int64
        GcpProjectID    string
}

func (cfg *Config) SetConfigs() error <span class="cov8" title="1">{
        // get port and debug from commandline flags... if not present use defaults
        flag.StringVar(&amp;cfg.Port, "port", "8080", "API server port")

        flag.StringVar(&amp;cfg.Env, "env", "development", "Environment (development|staging|cloud)")

        flag.StringVar(&amp;cfg.TTSBasePath, "tts-base-path", "/tmp/audio/", "text-to-speech base path temporary storage of mp3 audio files")

        flag.Int64Var(&amp;cfg.FileUploadLimit, "upload-size-limit", 8*8000, "File upload size limit in KB (default is 8)")
        flag.IntVar(&amp;cfg.MaxNumPhrases, "maximum-number-phrases", 100, "Maximum number of phrases to be turned into audio files")

        // set the global variable GlobalPlatform to google or amazon
        var platform string
        flag.StringVar(&amp;platform, "platform", "google", "which platform you are using [google|amazon]")
        if platform == "google" </span><span class="cov8" title="1">{
                translates.GlobalPlatform = translates.Google
        }</span> else<span class="cov0" title="0"> if platform == "amazon" </span><span class="cov0" title="0">{
                translates.GlobalPlatform = translates.Amazon
        }</span> else<span class="cov0" title="0"> {
                return errors.New("invalid platform (must be google|amazon)")
        }</span>

        // google cloud project id
        <span class="cov8" title="1">flag.StringVar(&amp;cfg.GcpProjectID, "gcp-project-id", test.TestProject, "project id for google cloud platform that contains firestore")

        return nil</span>
}

func (cfg *Config) FirestoreClient() (*firestore.Client, error) <span class="cov0" title="0">{
        // Use the application default credentials
        ctx := context.Background()
        conf := &amp;firebase.Config{ProjectID: cfg.GcpProjectID}
        app, err := firebase.NewApp(ctx, conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := app.Firestore(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/translates/amazonclients.go
//
// Generated by this command:
//
//        mockgen -package mock -destination=internal/mock/amazonclients.go -source=internal/translates/amazonclients.go
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        polly "github.com/aws/aws-sdk-go-v2/service/polly"
        translate "github.com/aws/aws-sdk-go-v2/service/translate"
        gomock "go.uber.org/mock/gomock"
)

// MockAmazonTranslateClientX is a mock of AmazonTranslateClientX interface.
type MockAmazonTranslateClientX struct {
        ctrl     *gomock.Controller
        recorder *MockAmazonTranslateClientXMockRecorder
        isgomock struct{}
}

// MockAmazonTranslateClientXMockRecorder is the mock recorder for MockAmazonTranslateClientX.
type MockAmazonTranslateClientXMockRecorder struct {
        mock *MockAmazonTranslateClientX
}

// NewMockAmazonTranslateClientX creates a new mock instance.
func NewMockAmazonTranslateClientX(ctrl *gomock.Controller) *MockAmazonTranslateClientX <span class="cov8" title="1">{
        mock := &amp;MockAmazonTranslateClientX{ctrl: ctrl}
        mock.recorder = &amp;MockAmazonTranslateClientXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAmazonTranslateClientX) EXPECT() *MockAmazonTranslateClientXMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// TranslateText mocks base method.
func (m *MockAmazonTranslateClientX) TranslateText(arg0 context.Context, arg1 *translate.TranslateTextInput, arg2 ...func(*translate.Options)) (*translate.TranslateTextOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{arg0, arg1}
        for _, a := range arg2 </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "TranslateText", varargs...)
        ret0, _ := ret[0].(*translate.TranslateTextOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// TranslateText indicates an expected call of TranslateText.
func (mr *MockAmazonTranslateClientXMockRecorder) TranslateText(arg0, arg1 any, arg2 ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TranslateText", reflect.TypeOf((*MockAmazonTranslateClientX)(nil).TranslateText), varargs...)
}</span>

// MockAmazonTTSClientX is a mock of AmazonTTSClientX interface.
type MockAmazonTTSClientX struct {
        ctrl     *gomock.Controller
        recorder *MockAmazonTTSClientXMockRecorder
        isgomock struct{}
}

// MockAmazonTTSClientXMockRecorder is the mock recorder for MockAmazonTTSClientX.
type MockAmazonTTSClientXMockRecorder struct {
        mock *MockAmazonTTSClientX
}

// NewMockAmazonTTSClientX creates a new mock instance.
func NewMockAmazonTTSClientX(ctrl *gomock.Controller) *MockAmazonTTSClientX <span class="cov8" title="1">{
        mock := &amp;MockAmazonTTSClientX{ctrl: ctrl}
        mock.recorder = &amp;MockAmazonTTSClientXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAmazonTTSClientX) EXPECT() *MockAmazonTTSClientXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// SynthesizeSpeech mocks base method.
func (m *MockAmazonTTSClientX) SynthesizeSpeech(arg0 context.Context, arg1 *polly.SynthesizeSpeechInput, arg2 ...func(*polly.Options)) (*polly.SynthesizeSpeechOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []any{arg0, arg1}
        for _, a := range arg2 </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "SynthesizeSpeech", varargs...)
        ret0, _ := ret[0].(*polly.SynthesizeSpeechOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// SynthesizeSpeech indicates an expected call of SynthesizeSpeech.
func (mr *MockAmazonTTSClientXMockRecorder) SynthesizeSpeech(arg0, arg1 any, arg2 ...any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SynthesizeSpeech", reflect.TypeOf((*MockAmazonTTSClientX)(nil).SynthesizeSpeech), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/audio/audiofile/audiofile.go
//
// Generated by this command:
//
//        mockgen -package mock -destination=internal/mock/audiofile.go -source=internal/audio/audiofile/audiofile.go
//

// Package mock is a generated GoMock package.
package mock

import (
        iter "iter"
        multipart "mime/multipart"
        os "os"
        exec "os/exec"
        reflect "reflect"

        echo "github.com/labstack/echo/v4"
        gomock "go.uber.org/mock/gomock"
        models "talkliketv.click/tltv/internal/models"
)

// MockAudioFileX is a mock of AudioFileX interface.
type MockAudioFileX struct {
        ctrl     *gomock.Controller
        recorder *MockAudioFileXMockRecorder
        isgomock struct{}
}

// MockAudioFileXMockRecorder is the mock recorder for MockAudioFileX.
type MockAudioFileXMockRecorder struct {
        mock *MockAudioFileX
}

// NewMockAudioFileX creates a new mock instance.
func NewMockAudioFileX(ctrl *gomock.Controller) *MockAudioFileX <span class="cov8" title="1">{
        mock := &amp;MockAudioFileX{ctrl: ctrl}
        mock.recorder = &amp;MockAudioFileXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAudioFileX) EXPECT() *MockAudioFileXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// BuildAudioInputFiles mocks base method.
func (m *MockAudioFileX) BuildAudioInputFiles(arg0 echo.Context, arg1 models.Title, arg2, arg3, arg4, arg5 string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BuildAudioInputFiles", arg0, arg1, arg2, arg3, arg4, arg5)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BuildAudioInputFiles indicates an expected call of BuildAudioInputFiles.
func (mr *MockAudioFileXMockRecorder) BuildAudioInputFiles(arg0, arg1, arg2, arg3, arg4, arg5 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildAudioInputFiles", reflect.TypeOf((*MockAudioFileX)(nil).BuildAudioInputFiles), arg0, arg1, arg2, arg3, arg4, arg5)
}</span>

// CreateMp3Zip mocks base method.
func (m *MockAudioFileX) CreateMp3Zip(arg0 echo.Context, arg1 models.Title, arg2 string) (*os.File, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateMp3Zip", arg0, arg1, arg2)
        ret0, _ := ret[0].(*os.File)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateMp3Zip indicates an expected call of CreateMp3Zip.
func (mr *MockAudioFileXMockRecorder) CreateMp3Zip(arg0, arg1, arg2 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMp3Zip", reflect.TypeOf((*MockAudioFileX)(nil).CreateMp3Zip), arg0, arg1, arg2)
}</span>

// CreatePhrasesZip mocks base method.
func (m *MockAudioFileX) CreatePhrasesZip(arg0 echo.Context, arg1 iter.Seq[[]string], arg2, arg3 string) (*os.File, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePhrasesZip", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(*os.File)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreatePhrasesZip indicates an expected call of CreatePhrasesZip.
func (mr *MockAudioFileXMockRecorder) CreatePhrasesZip(arg0, arg1, arg2, arg3 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePhrasesZip", reflect.TypeOf((*MockAudioFileX)(nil).CreatePhrasesZip), arg0, arg1, arg2, arg3)
}</span>

// GetLines mocks base method.
func (m *MockAudioFileX) GetLines(arg0 echo.Context, arg1 multipart.File) ([]string, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLines", arg0, arg1)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLines indicates an expected call of GetLines.
func (mr *MockAudioFileXMockRecorder) GetLines(arg0, arg1 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLines", reflect.TypeOf((*MockAudioFileX)(nil).GetLines), arg0, arg1)
}</span>

// MockcmdRunnerX is a mock of cmdRunnerX interface.
type MockcmdRunnerX struct {
        ctrl     *gomock.Controller
        recorder *MockcmdRunnerXMockRecorder
        isgomock struct{}
}

// MockcmdRunnerXMockRecorder is the mock recorder for MockcmdRunnerX.
type MockcmdRunnerXMockRecorder struct {
        mock *MockcmdRunnerX
}

// NewMockcmdRunnerX creates a new mock instance.
func NewMockcmdRunnerX(ctrl *gomock.Controller) *MockcmdRunnerX <span class="cov8" title="1">{
        mock := &amp;MockcmdRunnerX{ctrl: ctrl}
        mock.recorder = &amp;MockcmdRunnerXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcmdRunnerX) EXPECT() *MockcmdRunnerXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CombinedOutput mocks base method.
func (m *MockcmdRunnerX) CombinedOutput(cmd *exec.Cmd) ([]byte, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CombinedOutput", cmd)
        ret0, _ := ret[0].([]byte)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CombinedOutput indicates an expected call of CombinedOutput.
func (mr *MockcmdRunnerXMockRecorder) CombinedOutput(cmd any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CombinedOutput", reflect.TypeOf((*MockcmdRunnerX)(nil).CombinedOutput), cmd)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/translates/googleclients.go
//
// Generated by this command:
//
//        mockgen -package mock -destination=internal/mock/googleclients.go -source=internal/translates/googleclients.go
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        texttospeechpb "cloud.google.com/go/texttospeech/apiv1/texttospeechpb"
        translate "cloud.google.com/go/translate"
        gax "github.com/googleapis/gax-go/v2"
        gomock "go.uber.org/mock/gomock"
        language "golang.org/x/text/language"
)

// MockGoogleTranslateClientX is a mock of GoogleTranslateClientX interface.
type MockGoogleTranslateClientX struct {
        ctrl     *gomock.Controller
        recorder *MockGoogleTranslateClientXMockRecorder
        isgomock struct{}
}

// MockGoogleTranslateClientXMockRecorder is the mock recorder for MockGoogleTranslateClientX.
type MockGoogleTranslateClientXMockRecorder struct {
        mock *MockGoogleTranslateClientX
}

// NewMockGoogleTranslateClientX creates a new mock instance.
func NewMockGoogleTranslateClientX(ctrl *gomock.Controller) *MockGoogleTranslateClientX <span class="cov8" title="1">{
        mock := &amp;MockGoogleTranslateClientX{ctrl: ctrl}
        mock.recorder = &amp;MockGoogleTranslateClientXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGoogleTranslateClientX) EXPECT() *MockGoogleTranslateClientXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Translate mocks base method.
func (m *MockGoogleTranslateClientX) Translate(arg0 context.Context, arg1 []string, arg2 language.Tag, arg3 *translate.Options) ([]translate.Translation, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Translate", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].([]translate.Translation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Translate indicates an expected call of Translate.
func (mr *MockGoogleTranslateClientXMockRecorder) Translate(arg0, arg1, arg2, arg3 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Translate", reflect.TypeOf((*MockGoogleTranslateClientX)(nil).Translate), arg0, arg1, arg2, arg3)
}</span>

// MockGoogleTTSClientX is a mock of GoogleTTSClientX interface.
type MockGoogleTTSClientX struct {
        ctrl     *gomock.Controller
        recorder *MockGoogleTTSClientXMockRecorder
        isgomock struct{}
}

// MockGoogleTTSClientXMockRecorder is the mock recorder for MockGoogleTTSClientX.
type MockGoogleTTSClientXMockRecorder struct {
        mock *MockGoogleTTSClientX
}

// NewMockGoogleTTSClientX creates a new mock instance.
func NewMockGoogleTTSClientX(ctrl *gomock.Controller) *MockGoogleTTSClientX <span class="cov8" title="1">{
        mock := &amp;MockGoogleTTSClientX{ctrl: ctrl}
        mock.recorder = &amp;MockGoogleTTSClientXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGoogleTTSClientX) EXPECT() *MockGoogleTTSClientXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// SynthesizeSpeech mocks base method.
func (m *MockGoogleTTSClientX) SynthesizeSpeech(arg0 context.Context, arg1 *texttospeechpb.SynthesizeSpeechRequest, arg2 ...gax.CallOption) (*texttospeechpb.SynthesizeSpeechResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []any{arg0, arg1}
        for _, a := range arg2 </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "SynthesizeSpeech", varargs...)
        ret0, _ := ret[0].(*texttospeechpb.SynthesizeSpeechResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// SynthesizeSpeech indicates an expected call of SynthesizeSpeech.
func (mr *MockGoogleTTSClientXMockRecorder) SynthesizeSpeech(arg0, arg1 any, arg2 ...any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SynthesizeSpeech", reflect.TypeOf((*MockGoogleTTSClientX)(nil).SynthesizeSpeech), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/models/models.go
//
// Generated by this command:
//
//        mockgen -package mock -destination=internal/mock/models.go -source=internal/models/models.go
//

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        models "talkliketv.click/tltv/internal/models"
)

// MockModelsX is a mock of ModelsX interface.
type MockModelsX struct {
        ctrl     *gomock.Controller
        recorder *MockModelsXMockRecorder
        isgomock struct{}
}

// MockModelsXMockRecorder is the mock recorder for MockModelsX.
type MockModelsXMockRecorder struct {
        mock *MockModelsX
}

// NewMockModelsX creates a new mock instance.
func NewMockModelsX(ctrl *gomock.Controller) *MockModelsX <span class="cov8" title="1">{
        mock := &amp;MockModelsX{ctrl: ctrl}
        mock.recorder = &amp;MockModelsXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModelsX) EXPECT() *MockModelsXMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetLanguage mocks base method.
func (m *MockModelsX) GetLanguage(arg0 int) (models.Language, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLanguage", arg0)
        ret0, _ := ret[0].(models.Language)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLanguage indicates an expected call of GetLanguage.
func (mr *MockModelsXMockRecorder) GetLanguage(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLanguage", reflect.TypeOf((*MockModelsX)(nil).GetLanguage), arg0)
}</span>

// GetVoice mocks base method.
func (m *MockModelsX) GetVoice(arg0 int) (models.Voice, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVoice", arg0)
        ret0, _ := ret[0].(models.Voice)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVoice indicates an expected call of GetVoice.
func (mr *MockModelsXMockRecorder) GetVoice(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVoice", reflect.TypeOf((*MockModelsX)(nil).GetVoice), arg0)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/models/tokens.go
//
// Generated by this command:
//
//        mockgen -package mock -destination=internal/mock/tokens.go -source=internal/models/tokens.go
//

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockTokensX is a mock of TokensX interface.
type MockTokensX struct {
        ctrl     *gomock.Controller
        recorder *MockTokensXMockRecorder
        isgomock struct{}
}

// MockTokensXMockRecorder is the mock recorder for MockTokensX.
type MockTokensXMockRecorder struct {
        mock *MockTokensX
}

// NewMockTokensX creates a new mock instance.
func NewMockTokensX(ctrl *gomock.Controller) *MockTokensX <span class="cov8" title="1">{
        mock := &amp;MockTokensX{ctrl: ctrl}
        mock.recorder = &amp;MockTokensXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTokensX) EXPECT() *MockTokensXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CheckToken mocks base method.
func (m *MockTokensX) CheckToken(c context.Context, token string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckToken", c, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CheckToken indicates an expected call of CheckToken.
func (mr *MockTokensXMockRecorder) CheckToken(c, token any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckToken", reflect.TypeOf((*MockTokensX)(nil).CheckToken), c, token)
}</span>

// UpdateField mocks base method.
func (m *MockTokensX) UpdateField(c context.Context, token, path, value string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateField", c, token, path, value)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateField indicates an expected call of UpdateField.
func (mr *MockTokensXMockRecorder) UpdateField(c, token, path, value any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateField", reflect.TypeOf((*MockTokensX)(nil).UpdateField), c, token, path, value)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/translates/translates.go
//
// Generated by this command:
//
//        mockgen -package mock -destination=internal/mock/translates.go -source=internal/translates/translates.go
//

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        echo "github.com/labstack/echo/v4"
        gomock "go.uber.org/mock/gomock"
        models "talkliketv.click/tltv/internal/models"
)

// MockTranslateX is a mock of TranslateX interface.
type MockTranslateX struct {
        ctrl     *gomock.Controller
        recorder *MockTranslateXMockRecorder
        isgomock struct{}
}

// MockTranslateXMockRecorder is the mock recorder for MockTranslateX.
type MockTranslateXMockRecorder struct {
        mock *MockTranslateX
}

// NewMockTranslateX creates a new mock instance.
func NewMockTranslateX(ctrl *gomock.Controller) *MockTranslateX <span class="cov8" title="1">{
        mock := &amp;MockTranslateX{ctrl: ctrl}
        mock.recorder = &amp;MockTranslateXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTranslateX) EXPECT() *MockTranslateXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateTTS mocks base method.
func (m *MockTranslateX) CreateTTS(arg0 echo.Context, arg1 models.Title, arg2 int, arg3 string) ([]models.Phrase, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTTS", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].([]models.Phrase)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateTTS indicates an expected call of CreateTTS.
func (mr *MockTranslateXMockRecorder) CreateTTS(arg0, arg1, arg2, arg3 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTTS", reflect.TypeOf((*MockTranslateX)(nil).CreateTTS), arg0, arg1, arg2, arg3)
}</span>

// TranslatePhrases mocks base method.
func (m *MockTranslateX) TranslatePhrases(arg0 echo.Context, arg1 models.Title, arg2 models.Language) ([]models.Phrase, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TranslatePhrases", arg0, arg1, arg2)
        ret0, _ := ret[0].([]models.Phrase)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// TranslatePhrases indicates an expected call of TranslatePhrases.
func (mr *MockTranslateXMockRecorder) TranslatePhrases(arg0, arg1, arg2 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TranslatePhrases", reflect.TypeOf((*MockTranslateX)(nil).TranslatePhrases), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "encoding/json"
        "errors"
        "log"
        "strings"
)

// aws_languages =&gt; aws translate list-Languages &gt; aws_languages.json
// aws_voices =&gt; aws polly describe-Voices &gt; aws_voices.json
// google_languages =&gt; /scripts/python/supported_languages.json
// google_voices =&gt; /scripts/python/voices_api.json

var (
        ErrTooManyPhrases    = errors.New("too many phrases")
        ErrVoiceIdInvalid    = errors.New("voice id invalid")
        ErrPauseNotFound     = errors.New("audio pause file not found")
        ErrLanguageIdInvalid = errors.New("language id invalid")
        ErrPauseInvalid      = errors.New("pause out of range (must be between 3 and 10")
)

type Title struct {
        Name         string
        TitleLangId  int
        ToVoiceId    int
        FromVoiceId  int
        Pause        int
        TitlePhrases []Phrase
        ToPhrases    []Phrase
        Pattern      int
}

type Phrase struct {
        ID   int
        Text string
}

type GoogleJsonVoice struct {
        LanguageCodes          []string
        SsmlGender             string
        Name                   string
        NaturalSampleRateHertz int
}

type GoogleJsonLanguage struct {
        Language string
        Name     string
}

type AmazonLanguageArray struct {
        Languages []AmazonJsonLanguage
}
type AmazonJsonLanguage struct {
        LanguageCode string
        LanguageName string
}

type AmazonVoiceArray struct {
        Voices []AmazonJsonVoice
}

type AmazonJsonVoice struct {
        Gender           string
        Id               string
        LanguageCode     string
        LanguageName     string
        Name             string
        SupportedEngines []string
}

type Language struct {
        ID   int
        Code string
        Name string
}

type Voice struct {
        ID                     int
        LanguageCodes          []string
        Gender                 string
        VoiceName              string
        LanguageName           string
        NaturalSampleRateHertz int
        Engine                 string
        LangId                 int
}

type Status int

const (
        New Status = iota
        Used
)

var Languages = make(map[int]Language)
var Voices = make(map[int]Voice)

type ModelsX interface {
        GetLanguage(int) (Language, error)
        GetVoice(int) (Voice, error)
}

type Models struct{}

func (m *Models) GetLanguage(id int) (Language, error) <span class="cov0" title="0">{
        lang, ok := Languages[id]
        if !ok </span><span class="cov0" title="0">{
                return Language{}, ErrLanguageIdInvalid
        }</span>
        <span class="cov0" title="0">return lang, nil</span>
}

func (m *Models) GetVoice(id int) (Voice, error) <span class="cov0" title="0">{
        voice, ok := Voices[id]
        if !ok </span><span class="cov0" title="0">{
                return Voice{}, ErrVoiceIdInvalid
        }</span>
        <span class="cov0" title="0">return voice, nil</span>
}

func MakeGoogleMaps() <span class="cov0" title="0">{
        languageFile, err := JsonModels.Open("jsonmodels/google_languages.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // Decode the JSON data into a struct
        <span class="cov0" title="0">var glangs []GoogleJsonLanguage
        decoder := json.NewDecoder(languageFile)
        err = decoder.Decode(&amp;glangs)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error decoding JSON:", err)
        }</span>

        <span class="cov0" title="0">voiceFile, err := JsonModels.Open("jsonmodels/google_voices.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // Decode the JSON data into a struct
        <span class="cov0" title="0">var voices []GoogleJsonVoice
        decoder = json.NewDecoder(voiceFile)
        err = decoder.Decode(&amp;voices)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error decoding JSON:", err)
        }</span>

        <span class="cov0" title="0">usedLangs := make(map[int]bool)
        for i, voice := range voices </span><span class="cov0" title="0">{
                langCode := voice.LanguageCodes[0]
                // get the language id for the voice from the language tag
                langTag := strings.Split(langCode, "-")
                found := false
                langId := -1
                // find the language id (key) for the language that corresponds to the voice
                for j, lang := range glangs </span><span class="cov0" title="0">{
                        // filipino voice langTag does not match language tag
                        if langTag[0] == "fil" &amp;&amp; lang.Language == "tl" </span><span class="cov0" title="0">{
                                found = true
                                langId = j
                                break</span>
                        }
                        // norwegian voice langTag does not match language tag
                        <span class="cov0" title="0">if langTag[0] == "nb" &amp;&amp; lang.Language == "no" </span><span class="cov0" title="0">{
                                found = true
                                langId = j
                                break</span>
                        }
                        <span class="cov0" title="0">if lang.Language == langTag[0] </span><span class="cov0" title="0">{
                                found = true
                                langId = j
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span>{<span class="cov0" title="0">
                        //log.Println("langId not found for " + voice.Name + " : " + voice.LanguageCodes[0])
                }</span> else<span class="cov0" title="0"> {
                        usedLangs[langId] = true
                        // add to VoiceLangId map
                        Voices[i] = Voice{
                                ID:                     i,
                                LanguageCodes:          voice.LanguageCodes,
                                Gender:                 voice.SsmlGender,
                                VoiceName:              voice.Name,
                                NaturalSampleRateHertz: voice.NaturalSampleRateHertz,
                                LangId:                 langId,
                        }
                }</span>
        }
        // only add google language to models.Language if it has a voice
        <span class="cov0" title="0">for i, lang := range glangs </span><span class="cov0" title="0">{
                _, ok := usedLangs[i]
                // If the key exists
                if ok </span><span class="cov0" title="0">{
                        Languages[i] = Language{
                                ID:   i,
                                Code: lang.Language,
                                Name: lang.Name,
                        }
                }</span>
        }
}

func MakeAmazonMaps() <span class="cov0" title="0">{
        languageFile, err := JsonModels.Open("jsonmodels/aws_languages.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // Decode the JSON data into a struct
        <span class="cov0" title="0">var langArray AmazonLanguageArray
        decoder := json.NewDecoder(languageFile)
        err = decoder.Decode(&amp;langArray)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error decoding JSON:", err)
        }</span>
        <span class="cov0" title="0">languages := langArray.Languages

        voiceFile, err := JsonModels.Open("jsonmodels/aws_voices.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // Decode the JSON data into a struct
        <span class="cov0" title="0">var voices AmazonVoiceArray
        decoder = json.NewDecoder(voiceFile)
        err = decoder.Decode(&amp;voices)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error decoding JSON:", err)
        }</span>

        <span class="cov0" title="0">usedLangs := make(map[int]bool)
        for i, voice := range voices.Voices </span><span class="cov0" title="0">{
                langCode := voice.LanguageCode
                // get the language id for the voice from the language tag
                langTag := strings.Split(langCode, "-")
                found := false
                langId := -1
                // find the language id (key) for the language that corresponds to the voice
                for j, lang := range languages </span><span class="cov0" title="0">{
                        if lang.LanguageCode == langTag[0] </span><span class="cov0" title="0">{
                                found = true
                                langId = j
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        log.Println("langId not found for " + voice.Name + voice.LanguageCode)
                }</span> else<span class="cov0" title="0"> {
                        usedLangs[langId] = true
                        // add to VoiceLangId map
                        Voices[i] = Voice{
                                ID:            i,
                                LanguageCodes: []string{voice.LanguageCode},
                                Gender:        voice.Gender,
                                VoiceName:     voice.Name,
                                LanguageName:  voice.LanguageName,
                                LangId:        langId,
                                Engine:        voice.SupportedEngines[0],
                        }
                }</span>
        }

        // only add the language to models.Language if it has a voice
        <span class="cov0" title="0">for i, lang := range languages </span><span class="cov0" title="0">{
                _, ok := usedLangs[i]
                // If the key exists
                if ok </span><span class="cov0" title="0">{
                        Languages[i] = Language{
                                ID:   i,
                                Code: lang.LanguageCode,
                                Name: lang.LanguageName,
                        }
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "cloud.google.com/go/firestore"
        "context"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base32"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "os"
        "talkliketv.click/tltv/internal/util"
        "time"
)

type Token struct {
        UploadUsed bool
        TimesUsed  int
        Created    time.Time
        Hash       string
}

type FirestoreToken struct {
        UploadUsed bool
        TimesUsed  int
        Created    time.Time
}

type Tokens struct {
        Coll *firestore.CollectionRef
}

type TokensX interface {
        CheckToken(c context.Context, token string) error
        UpdateField(c context.Context, token string, path string, value string) error
}

var (
        UsedTokenError = errors.New("token already used")
)

func (t *Tokens) CheckToken(ctx context.Context, token string) error <span class="cov0" title="0">{
        tokenHash := sha256.Sum256([]byte(token))
        hashString := hex.EncodeToString(tokenHash[:])
        tokenDoc, err := t.Coll.Doc(hashString).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("token check failed: %w", err)
        }</span>
        <span class="cov0" title="0">var tStruct Token
        err = tokenDoc.DataTo(&amp;tStruct)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("token check failed: %w", err)
        }</span>
        <span class="cov0" title="0">if tStruct.UploadUsed </span><span class="cov0" title="0">{
                return UsedTokenError
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (t *Tokens) AddToken(ctx context.Context, token Token) error <span class="cov0" title="0">{
        _, err := t.Coll.Doc(token.Hash).Set(ctx, FirestoreToken{
                UploadUsed: token.UploadUsed,
                TimesUsed:  token.TimesUsed,
                Created:    token.Created,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed adding token: %v", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (t *Tokens) UpdateField(ctx context.Context, token, path, value string) error <span class="cov0" title="0">{
        tokenHash := sha256.Sum256([]byte(token))
        hashString := hex.EncodeToString(tokenHash[:])
        tokenDoc := t.Coll.Doc(hashString)
        _, err := tokenDoc.Update(ctx, []firestore.Update{
                {
                        Path:  path,
                        Value: value,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("token update failed: %w", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func CreateTokensFile(filePath string, filename string, numTokens int) ([]string, error) <span class="cov0" title="0">{
        var tokens []*Token
        var plaintexts []string
        for i := 0; i &lt; numTokens; i++ </span><span class="cov0" title="0">{
                token, plaintext, err := GenerateToken()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">tokens = append(tokens, token)
                plaintexts = append(plaintexts, plaintext)</span>
        }

        // Marshal the data to JSON
        <span class="cov0" title="0">jsonData, err := json.Marshal(tokens)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // create a file path if it does not exist
        <span class="cov0" title="0">exists, err := util.PathExists(filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                err = os.MkdirAll(filePath, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }
        // Open the file for writing
        <span class="cov0" title="0">file, err := os.Create(filePath + filename)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Write the JSON data to the file
        _, err = file.Write(jsonData)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return plaintexts, nil</span>
}

func GenerateToken() (*Token, string, error) <span class="cov0" title="0">{
        // Initialize a zero-valued byte slice with a length of 16 bytes.
        randomBytes := make([]byte, 16)

        // Use the Read() function from the crypto/rand package to fill the byte slice with
        // random bytes from your operating system's CSPRNG. This will return an error if
        // the CSPRNG fails to function correctly.
        _, err := rand.Read(randomBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">token := &amp;Token{
                Created: time.Now(),
        }
        plaintext := base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(randomBytes)
        // Generate a SHA-256 hash of the plaintext token string. This will be the value
        // that we store in the `hash` field of our database table.
        // Create the hash
        hash := sha256.Sum256([]byte(plaintext))

        // Convert the hash to a hexadecimal string
        hashString := hex.EncodeToString(hash[:])
        token.Hash = hashString

        return token, plaintext, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package oapi

import (
        "bytes"
        "compress/gzip"
        "encoding/base64"
        "fmt"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/labstack/echo/v4"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// Error defines model for Error.
type Error struct {
        // Code Error code
        Code int32 `json:"code"`

        // Message Error message
        Message string `json:"message"`
}

// AudioFromFileMultipartBody defines parameters for AudioFromFile.
type AudioFromFileMultipartBody struct {
        // FileLanguageId the original language of the file you are uploading
        FileLanguageId string             `json:"file_language_id"`
        FilePath       openapi_types.File `json:"file_path"`

        // FromVoiceId the language you know
        FromVoiceId string `json:"from_voice_id"`

        // Pattern pattern is the pattern used to construct the audio files. You have 3 choices:
        // 1 is beginner and repeats closer together --
        // 2 is intermediate --
        // 3 is advanced and repeats phrases less often and should only be used if you are at an advanced level --
        // 4 is review and repeats each phrase one time and can be used to review already learned phrases
        Pattern string `json:"pattern"`

        // Pause the pause in seconds between phrases in the audiofile (default is 4)
        Pause string `json:"pause"`

        // TitleName choose a descriptive title that includes to and from languages
        TitleName string `json:"title_name"`

        // ToVoiceId the language you want to learn
        ToVoiceId string `json:"to_voice_id"`

        // Token tokens are required to be able to successfully request an audio file
        Token string `json:"token"`
}

// ParseFileMultipartBody defines parameters for ParseFile.
type ParseFileMultipartBody struct {
        FilePath openapi_types.File `json:"file_path"`
}

// AudioFromFileMultipartRequestBody defines body for AudioFromFile for multipart/form-data ContentType.
type AudioFromFileMultipartRequestBody AudioFromFileMultipartBody

// ParseFileMultipartRequestBody defines body for ParseFile for multipart/form-data ContentType.
type ParseFileMultipartRequestBody ParseFileMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

        // (POST /audio)
        AudioFromFile(ctx echo.Context) error

        // (POST /parse)
        ParseFile(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// AudioFromFile converts echo context to params.
func (w *ServerInterfaceWrapper) AudioFromFile(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AudioFromFile(ctx)
        return err
}</span>

// ParseFile converts echo context to params.
func (w *ServerInterfaceWrapper) ParseFile(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.ParseFile(ctx)
        return err
}</span>

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov8" title="1">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.POST(baseURL+"/audio", wrapper.AudioFromFile)
        router.POST(baseURL+"/parse", wrapper.ParseFile)

}</span>

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "H4sIAAAAAAAC/8xX348buQ3+Vwi1Dy0wGW92g6L1U3/ligVyh6BJCxT1IeBqODO61VCqxLHXe9j/vaBm",
        "xj9iJ3d9KNon2xJFUh8/fpR/NDYMMTCxZLP+0WTb04Dl69uUQtIvMYVISRyVZRsa0s+Gsk0uigts1pMx",
        "lL3KtCENKGZtHMvdramM7CNNP6mjZF4qM1DO2H3R0bJ9OJolOe7My0tlEv1rdIkas/6nmQMu5t+/qIHj",
        "NkyZsqAV/UoDOm/Wphmz7He4Z/q9DYPFLDWTmMowDhrmz7oPH/BxyvI8tY/oH9+5R/r4d3AZEDxyN2JH",
        "4AkTO+4AY/TOotpDQ9l1TA1IgJ58hDFTyhC2lGwYCKQniB6FcIQNh1aIgdiGkYUSNbBz0kOQntIxEMaY",
        "a7gXCG2rzhAipRwYvXum5pgHPUVKjtgSbPhhD+h92OnGlIMEsH0IeUoiR7KudRZinzBT1sU97JBFDdtg",
        "xwyBa/hbOWuRYYw+YAMbRhB6EmidpynfxYVjiJiwSxh7UDpUEJjmbU0avGOqICSgLTEgw4e/fiyOKkBW",
        "35raKZ475z10xJRQCBAyKQzw7fs7wLFxoRwud2vROu9EzQ6ISJ/C2PXgXRbSlRo2vOF/hLHcyCYqXvnE",
        "F2RJ6LpeoE1hKFCVZRR4H7LAqpiudFPXa7hvi5E48QQ9ZtjwEBKd4IpcLAZ8KumjgA3cuq7+Fp++G4f3",
        "C3oy3TaRjIkB4dnFSM0UPrRH0DPk6J2AYwmL5w3zODxQUsM5cg33kMiGYSBuIAsmmTBxGXa4hxxgvwDR",
        "k31UEAd8JMhjUo6g6H4qITe8w6zFzdSADSmRFb+vN2wq450lzqWp5376Q0TbE9zWN6YyY9IW7EViXq9W",
        "u92uxrJdh9St5rN59e7+T2+/+/D21W19U/cyeO3DAulpB25NZbaU8tSYr+ub+kbtQiTG6Mza3JWlykSU",
        "vsjWVK0iZyHLpe4sDLjW1UdKFCZM9NfOfhJlcE5TNeqyUOwUygc6a4OspleaoCCnAltoft8oahrwmxSG",
        "b5xXeVPFoyx/DM1+0TXicodh9OIiJllpk71qUPCo4pfarbl9Wi74yTWXMCiJQnKdY/RHKEJ7pL8yBRPN",
        "KKgoV4aecIilQm9+d6nZ1RRXS1GSWKbDg2NM+6v2KQyftsHZLyd5yE3zeeSwO0vj9W9ur/mNKEKJLz3O",
        "G6rrRZfnn2Oe9NsGzpJGK2X3RG5qUAXpcUtwp5rqLOU1bPi1enqgzjFTKoKWKBJKButDpgQSOira/uoV",
        "bPhWzXU6poEapzwsy3dlzjRbZEvNmZdFUjzlDNPs0O3ch9E3ENjvlX4lfdceSoZSFG5x6GlLfor0RiMl",
        "2jrancUhtIuoF+6KG6gYzARfAFqO+kTY7KfWoWZJs1D8pDjXSzNmul7qsqW9lMkGbhRY2RHx6bQ51KVw",
        "9FcNtTh60Vu9+fVp8DeVGfDJDeNg1q9vKjM4nn7cXcmpyM6nScou9GIaoAiH5e0i/UUwHVs/NtNAUsCK",
        "ciykzdcQkPCfUH6ZzwXqM3hvb3573f0jXWF+Wc6FHsvDSt0+EOCD3iVAHq2lnNvR+z3MUnQ+KX/ymXYC",
        "ZHUpQp/3+zkUp+qx3GKhy7Gjvz+kEB5+ICumvATPr6pR3s1x7xvlRplqjFPtAnejang4t/k68jXouwj+",
        "8vYjrA7V1RePThKXyxPlcNo1eRqUR2wkjVTAyjHo+NMC3d7cfCbzJ++g1bOL5xL/k3p6icRcOqVk6Zcl",
        "/PTmLa3zlQx+yIHPU/hlotaszS9Wxz8Tq/mfxGr6G3EliZH1mWqFGqDF5qUyq/K2+PKgLtv5OI8O03jS",
        "LX0x5a8+meZhtojHNPibK2P4vUb6r4zgnz0KP+uj4+GfxffFeqHxYX4vFC5Y/l8w8tnFyzLNr8y5Uv97",
        "cr68/DsAAP//nxLsPi8PAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov8" title="1">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov8" title="1">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov8" title="1">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov8" title="1">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov8" title="1">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov8" title="1">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov8" title="1">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov8" title="1">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov8" title="1">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package test

import (
        "github.com/stretchr/testify/require"
        "go.uber.org/mock/gomock"
        "math/rand"
        "reflect"
        "slices"
        "strings"
        "talkliketv.click/tltv/internal/mock"
        "talkliketv.click/tltv/internal/models"
        "testing"
)

var (
        AudioBasePath = "/tmp/test/audio/"
)

func RequireMatchAnyExcept(t *testing.T, model any, response any, skip []string, except string, shouldEqual any) <span class="cov8" title="1">{
        v := reflect.ValueOf(response)
        u := reflect.ValueOf(model)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                // Check if field name is the one that should be different
                if v.Type().Field(i).Name == except </span><span class="cov0" title="0">{
                        // Check if type is int32 or int64
                        if v.Field(i).CanInt() </span><span class="cov0" title="0">{
                                // check if equal as int64
                                require.Equal(t, shouldEqual, v.Field(i).Int())
                        }</span> else<span class="cov0" title="0"> {
                                // if not check if equal as string
                                require.Equal(t, shouldEqual, v.Field(i).String())
                        }</span>
                } else<span class="cov8" title="1"> if slices.Contains(skip, v.Type().Field(i).Name) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        if v.Field(i).CanInt() </span><span class="cov8" title="1">{
                                require.Equal(t, u.Field(i).Int(), v.Field(i).Int())
                        }</span> else<span class="cov8" title="1"> {
                                require.Equal(t, u.Field(i).String(), v.Field(i).String())
                        }</span>
                }
        }
}

const (
        DefaultPause            = 5
        DefaultPattern          = 1
        MaxLanguages            = 75
        MaxVoices               = 95
        ValidLangId             = 16
        alphabet                = "abcdefghijklmnopqrstuvwxyz"
        FirestoreTestCollection = "token-tltv-test-coll"
        TestProject             = "token-tltv-test"
)

// RandomString generates a random string of length n
func RandomString(n int) string <span class="cov8" title="1">{
        var sb strings.Builder
        k := len(alphabet)

        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                c := alphabet[rand.Intn(k)] //nolint:gosec
                sb.WriteByte(c)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

func RandomPhrase() models.Phrase <span class="cov8" title="1">{
        return models.Phrase{
                ID:   rand.Intn(100), //nolint:gosec
                Text: RandomString(20),
        }
}</span>

// RandomVoice creates a random Voice for testing
func RandomVoice() models.Voice <span class="cov8" title="1">{
        return models.Voice{
                LangId:                 rand.Intn(MaxLanguages), //nolint:gosec
                LanguageCodes:          []string{RandomString(8), RandomString(8)},
                Gender:                 "FEMALE",
                VoiceName:              RandomString(8),
                NaturalSampleRateHertz: 24000,
        }
}</span>

func RandomTitle() (title models.Title) <span class="cov8" title="1">{
        return models.Title{
                Name:        RandomString(8),
                TitleLangId: ValidLangId,
                ToVoiceId:   models.Voices[rand.Intn(MaxVoices)].ID, //nolint:gosec
                FromVoiceId: models.Voices[rand.Intn(MaxVoices)].ID, //nolint:gosec
                Pause:       DefaultPause,
                Pattern:     DefaultPattern,
        }
}</span>

type MockStubs struct {
        TranslateX             *mock.MockTranslateX
        GoogleTranslateClientX *mock.MockGoogleTranslateClientX
        GoogleTTsClientX       *mock.MockGoogleTTSClientX
        AmazonTranslateClientX *mock.MockAmazonTranslateClientX
        AmazonTTsClientX       *mock.MockAmazonTTSClientX
        AudioFileX             *mock.MockAudioFileX
        TokensX                *mock.MockTokensX
        ModelsX                *mock.MockModelsX
}

// NewMockStubs creates instantiates new instances of all the mock interfaces for testing
func NewMockStubs(ctrl *gomock.Controller) MockStubs <span class="cov8" title="1">{
        return MockStubs{
                TranslateX:             mock.NewMockTranslateX(ctrl),
                GoogleTranslateClientX: mock.NewMockGoogleTranslateClientX(ctrl),
                GoogleTTsClientX:       mock.NewMockGoogleTTSClientX(ctrl),
                AudioFileX:             mock.NewMockAudioFileX(ctrl),
                AmazonTranslateClientX: mock.NewMockAmazonTranslateClientX(ctrl),
                AmazonTTsClientX:       mock.NewMockAmazonTTSClientX(ctrl),
                TokensX:                mock.NewMockTokensX(ctrl),
                ModelsX:                mock.NewMockModelsX(ctrl),
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package translates

import (
        "context"
        "errors"
        "fmt"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/polly"
        "github.com/aws/aws-sdk-go-v2/service/polly/types"
        "github.com/aws/aws-sdk-go-v2/service/translate"
        "github.com/labstack/echo/v4"
        "log"
        "os"
        "strconv"
        "sync"
        "talkliketv.click/tltv/internal/models"
)

// AmazonTranslateClientX creates an interface for amazon translate so it can be mocked for testing
type AmazonTranslateClientX interface {
        TranslateText(context.Context, *translate.TranslateTextInput, ...func(*translate.Options)) (*translate.TranslateTextOutput, error)
}

// AmazonTTSClientX creates an interface for amazon texttospeechpb so it can be mocked for testing
type AmazonTTSClientX interface {
        SynthesizeSpeech(context.Context, *polly.SynthesizeSpeechInput, ...func(*polly.Options)) (*polly.SynthesizeSpeechOutput, error)
}

type AmazonClients struct {
        atc  AmazonTranslateClientX
        atts AmazonTTSClientX
}

// NewAmazonClients creates new amazon translate and text-to-speech clients; constructs
// the dependencies and returns them
func NewAmazonClients() *AmazonClients <span class="cov0" title="0">{
        // create amazon translate and text-to-speech clients
        ctx := context.Background()
        // Initialize AWS configuration
        cfg, err := config.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to load SDK config, %v", err)
        }</span>

        // Create an AWS Translate client
        <span class="cov0" title="0">translateClient := translate.NewFromConfig(cfg)

        // Create a Polly client
        ttsClient := polly.NewFromConfig(cfg)

        //// Input text to translate
        //text := "Hello, how are you?"
        //sourceLanguage := "en" // Source language code (e.g., "en" for English)
        //targetLanguage := "es" // Target language code (e.g., "es" for Spanish)

        // Call the TranslateText API
        //output, err := translateClient.TranslateText(context.TODO(), &amp;translate.TranslateTextInput{
        //        Text:               &amp;text,
        //        SourceLanguageCode: &amp;sourceLanguage,
        //        TargetLanguageCode: &amp;targetLanguage,
        //})
        //if err != nil {
        //        log.Fatalf("Failed to translate text: %v", err)
        //}
        //
        //// Print the translated text
        //fmt.Printf("Original text: %s\n", text)
        //fmt.Printf("Translated text: %s\n", *output.TranslatedText)
        return &amp;AmazonClients{atc: translateClient, atts: ttsClient}</span>
}

// GetTranslate is a helper function for TranslatePhrases that allows concurrent calls to
// google translate.Translate.
// It receives a context.CancelFunc that is invoked on an error so all subsequent calls to
// google translate.Translate can be aborted
func (g *AmazonClients) GetTranslate(e echo.Context,
        ctx context.Context,
        cancel context.CancelFunc,
        phrase models.Phrase,
        wg *sync.WaitGroup,
        toLang string,
        fromLang string,
        responses []models.Phrase,
        i int,
) <span class="cov0" title="0">{
        defer wg.Done()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span> // Error somewhere, terminate
        default:<span class="cov0" title="0"> // Default to avoid blocking

                resp, err := g.atc.TranslateText(ctx, &amp;translate.TranslateTextInput{
                        Text:               &amp;phrase.Text,
                        SourceLanguageCode: &amp;fromLang,
                        TargetLanguageCode: &amp;toLang,
                })
                if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, context.Canceled):<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                e.Logger().Error(fmt.Errorf("error translating text: %s", err))
                                cancel()
                                return</span>
                        }
                }

                <span class="cov0" title="0">responses[i] = models.Phrase{
                        ID:   phrase.ID,
                        Text: *resp.TranslatedText,
                }</span>
        }
}

// GetSpeech is a helper function for TextToSpeech that is run concurrently.
// it is passed a cancel context, so if one routine fails, the following routines can
// be canceled

func (g *AmazonClients) GetSpeech(
        e echo.Context,
        ctx context.Context,
        cancel context.CancelFunc,
        translate models.Phrase,
        voice models.Voice,
        wg *sync.WaitGroup,
        basePath string) <span class="cov8" title="1">{
        defer wg.Done()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span> // Error somewhere, terminate
        default:<span class="cov8" title="1">
                resp, err := g.atts.SynthesizeSpeech(ctx, &amp;polly.SynthesizeSpeechInput{
                        Text:         &amp;translate.Text,
                        VoiceId:      types.VoiceId(voice.VoiceName), // voice.Name
                        OutputFormat: "mp3",
                        Engine:       types.Engine(voice.Engine),
                })
                if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, context.Canceled):<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                e.Logger().Error(fmt.Errorf("error creating Synthesize Speech client: %s", err))
                                cancel()
                                return</span>
                        }
                }

                // Save the output to an MP3 file
                <span class="cov8" title="1">outputFile := basePath + strconv.Itoa(translate.ID)
                file, err := os.Create(outputFile)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("error creating output file: %s", err))
                        cancel()
                        return
                }</span>
                <span class="cov8" title="1">defer file.Close()

                if resp.AudioStream == nil </span><span class="cov8" title="1">{
                        e.Logger().Error(fmt.Errorf("error synthesizing speech amazon: %s", err))
                        cancel()
                        return
                }</span>
                // Write the audio stream to the file
                <span class="cov8" title="1">_, err = file.ReadFrom(resp.AudioStream)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("failed to write audio stream to file, %v", err))
                        cancel()
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package translates

import (
        tts "cloud.google.com/go/texttospeech/apiv1"
        "cloud.google.com/go/texttospeech/apiv1/texttospeechpb"
        "cloud.google.com/go/translate"
        "context"
        "errors"
        "fmt"
        "github.com/googleapis/gax-go/v2"
        "github.com/labstack/echo/v4"
        "golang.org/x/text/language"
        "log"
        "os"
        "strconv"
        "sync"
        "talkliketv.click/tltv/internal/models"
)

// GoogleTranslateClientX creates an interface for google translate.Translate so it can
// be mocked for testing
type GoogleTranslateClientX interface {
        Translate(context.Context, []string, language.Tag, *translate.Options) ([]translate.Translation, error)
}

// GoogleTTSClientX creates an interface for google texttospeechpb.SynthesizeSpeech so
// it can be mocked for testing
type GoogleTTSClientX interface {
        SynthesizeSpeech(context.Context, *texttospeechpb.SynthesizeSpeechRequest, ...gax.CallOption) (*texttospeechpb.SynthesizeSpeechResponse, error)
}

type GoogleClients struct {
        gtc  GoogleTranslateClientX
        gtts GoogleTTSClientX
}

// NewGoogleClients creates a new google translate and text-to-speech clients; constructs
// the translate and audiofile dependencies and returns them
func NewGoogleClients() *GoogleClients <span class="cov0" title="0">{
        // create google translate and text-to-speech clients
        ctx := context.Background()
        transClient, err := translate.NewClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating google api translate client\n: %s", err)
        }</span>
        <span class="cov0" title="0">ttsClient, err := tts.NewClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error creating google api translate client\n: %s", err)
        }</span>
        <span class="cov0" title="0">return &amp;GoogleClients{
                gtc:  transClient,
                gtts: ttsClient,
        }</span>
}

// GetTranslate is a helper function for TranslatePhrases that allows concurrent calls to
// google translate.Translate.
// It receives a context.CancelFunc that is invoked on an error so all subsequent calls to
// google translate.Translate can be aborted
func (g *GoogleClients) GetTranslate(e echo.Context,
        ctx context.Context,
        cancel context.CancelFunc,
        phrase models.Phrase,
        wg *sync.WaitGroup,
        lang language.Tag,
        responses []models.Phrase,
        i int,
) <span class="cov8" title="1">{
        defer wg.Done()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span> // Error somewhere, terminate
        default:<span class="cov8" title="1"> // Default to avoid blocking
                resp, err := g.gtc.Translate(ctx, []string{phrase.Text}, lang, nil)
                if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, context.Canceled):<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                e.Logger().Error(fmt.Errorf("error translating text: %s", err))
                                cancel()</span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">if len(resp) == 0 </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("translate returned empty response to text: %s", err))
                        cancel()
                }</span>

                <span class="cov8" title="1">responses[i] = models.Phrase{
                        ID:   phrase.ID,
                        Text: resp[0].Text,
                }</span>
        }
}

// GetSpeech is a helper function for TextToSpeech that is run concurrently.
// it is passed a cancel context, so if one routine fails, the following routines can
// be canceled
func (g *GoogleClients) GetSpeech(
        e echo.Context,
        ctx context.Context,
        cancel context.CancelFunc,
        translate models.Phrase,
        wg *sync.WaitGroup,
        params *texttospeechpb.VoiceSelectionParams,
        basePath string) <span class="cov8" title="1">{
        defer wg.Done()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span> // Error somewhere, terminate
        default:<span class="cov8" title="1">
                // Perform the text-to-speech request on the text input with the selected
                // voice parameters and audio file type.
                req := texttospeechpb.SynthesizeSpeechRequest{
                        // Set the text input to be synthesized.
                        Input: &amp;texttospeechpb.SynthesisInput{
                                InputSource: &amp;texttospeechpb.SynthesisInput_Text{Text: translate.Text},
                        },
                        // Build the voice request, select the language code ("en-US") and the SSML
                        // voice gender ("neutral").
                        Voice: params,
                        // Select the type of audio file you want returned.
                        AudioConfig: &amp;texttospeechpb.AudioConfig{
                                AudioEncoding: texttospeechpb.AudioEncoding_MP3,
                        },
                }

                resp, err := g.gtts.SynthesizeSpeech(ctx, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("error creating Synthesize Speech client: %s", err))
                        cancel()
                        return
                }</span>

                // The resp AudioContent is binary.
                <span class="cov8" title="1">filename := basePath + strconv.Itoa(translate.ID)
                err = os.WriteFile(filename, resp.AudioContent, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("error creating translate client: %s", err))
                        cancel()
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package translates

import (
        "cloud.google.com/go/texttospeech/apiv1/texttospeechpb"
        "context"
        "github.com/labstack/echo/v4"
        "golang.org/x/text/language"
        "os"
        "sync"
        "talkliketv.click/tltv/internal/models"
        "talkliketv.click/tltv/internal/util"
        "time"
)

type Platform int

const (
        Google Platform = iota
        Amazon
)

var GlobalPlatform Platform

type Translate struct {
        googleClients GoogleClients
        amazonClients AmazonClients
        m             models.ModelsX
}

func New(gc GoogleClients, ac AmazonClients, m models.ModelsX) *Translate <span class="cov8" title="1">{
        return &amp;Translate{
                googleClients: gc,
                amazonClients: ac,
                m:             m,
        }
}</span>

// TranslateX creates an interface for Translates
type TranslateX interface {
        CreateTTS(echo.Context, models.Title, int, string) ([]models.Phrase, error)
        TranslatePhrases(echo.Context, models.Title, models.Language) ([]models.Phrase, error)
}

// TranslatePhrases takes a slice of db.Translate{} and a db.Language and returns a slice
// of util.TranslatesReturn to be inserted into the db
func (t *Translate) TranslatePhrases(e echo.Context, title models.Title, lang models.Language) ([]models.Phrase, error) <span class="cov8" title="1">{
        //TODO translate as document instead of separate phrase

        // concurrently get all the responses from Google Translate
        var wg sync.WaitGroup
        responses := make([]models.Phrase, len(title.TitlePhrases)) // create string slice to hold all the responses
        // create context with cancel, so you can cancel all other requests after any error
        newCtx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        // this is needed fro googleClients translate
        langTag, err := language.Parse(lang.Code)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">for i, nextTranslate := range title.TitlePhrases </span><span class="cov8" title="1">{
                // added intermittent sleep to fix TLS handshake errors on the client side
                if i%50 == 0 &amp;&amp; i != 0 </span><span class="cov0" title="0">{
                        time.Sleep(2 * time.Second)
                }</span>
                <span class="cov8" title="1">wg.Add(1)
                // get responses concurrently with go routines depending on platform
                if GlobalPlatform == Google </span><span class="cov8" title="1">{
                        go t.googleClients.GetTranslate(e, newCtx, cancel, nextTranslate, &amp;wg, langTag, responses, i)
                }</span> else<span class="cov0" title="0"> {
                        titleLang, err := t.m.GetLanguage(title.TitleLangId)
                        if err != nil </span><span class="cov0" title="0">{
                                e.Logger().Error(err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">go t.amazonClients.GetTranslate(e, newCtx, cancel, nextTranslate, &amp;wg, lang.Code, titleLang.Code, responses, i)</span>
                }
        }
        <span class="cov8" title="1">wg.Wait()

        if newCtx.Err() != nil </span><span class="cov0" title="0">{
                e.Logger().Error(newCtx.Err())
                return nil, newCtx.Err()
        }</span>

        <span class="cov8" title="1">return responses, nil</span>
}

// CreateTTS is called from api.createAudioFromTitle.
// It checks if the mp3 audio files exist and if not it creates them.
func (t *Translate) CreateTTS(e echo.Context, title models.Title, voiceId int, basePath string) ([]models.Phrase, error) <span class="cov0" title="0">{
        voice, err := t.m.GetVoice(voiceId)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">lang, err := t.m.GetLanguage(voice.LangId)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        // if the audio files already exist, no need to request them again
        <span class="cov0" title="0">skip, err := util.PathExists(basePath)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var translates []models.Phrase
        // if they do not exist, then request them
        if !skip </span><span class="cov0" title="0">{
                translates, err = t.CreateTranslates(e, title, lang)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">err = os.MkdirAll(basePath, 0777)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">if err = t.TextToSpeech(e, translates, voice, basePath); err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return translates, nil</span>
}

// TextToSpeech takes a slice of db.Translate and get the speech mp3's adding them
// to the machines local file system
func (t *Translate) TextToSpeech(e echo.Context, ts []models.Phrase, voice models.Voice, bp string) error <span class="cov8" title="1">{
        // concurrently get all the audio content from Google text-to-speech
        var wg sync.WaitGroup
        // create context with cancel, so you can cancel all other requests after any error
        newCtx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        // set the texttospeec params from the db voice sent in the request
        voiceSelectionParams := &amp;texttospeechpb.VoiceSelectionParams{
                LanguageCode: voice.LanguageCodes[0],
                SsmlGender:   texttospeechpb.SsmlVoiceGender_MALE,
                Name:         voice.VoiceName,
        }
        if voice.Gender == "FEMALE" </span><span class="cov0" title="0">{
                voiceSelectionParams.SsmlGender = texttospeechpb.SsmlVoiceGender_FEMALE
        }</span>

        <span class="cov8" title="1">for i, nextText := range ts </span><span class="cov8" title="1">{
                // added intermittent sleep to fix TLS handshake errors on the client side
                if i%50 == 0 &amp;&amp; i != 0 </span><span class="cov0" title="0">{
                        time.Sleep(2 * time.Second)
                }</span>
                <span class="cov8" title="1">wg.Add(1)
                //get responses concurrently with go routines depending on the platform
                if GlobalPlatform == Google </span><span class="cov8" title="1">{
                        go t.googleClients.GetSpeech(e, newCtx, cancel, nextText, &amp;wg, voiceSelectionParams, bp)
                }</span> else<span class="cov8" title="1"> {
                        go t.amazonClients.GetSpeech(e, newCtx, cancel, nextText, voice, &amp;wg, bp)
                }</span>
        }
        <span class="cov8" title="1">wg.Wait()

        if newCtx.Err() != nil </span><span class="cov8" title="1">{
                e.Logger().Error(newCtx.Err())
                return newCtx.Err()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateTranslates creates the translates in the language
func (t *Translate) CreateTranslates(e echo.Context, title models.Title, lang models.Language) ([]models.Phrase, error) <span class="cov0" title="0">{
        titleLang, err := t.m.GetLanguage(title.TitleLangId)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        // if the original language of file matches the language you desire translates for return original phrases
        <span class="cov0" title="0">if titleLang.ID == lang.ID </span><span class="cov0" title="0">{
                return title.TitlePhrases, nil
        }</span>

        // create translates for title and to language and return
        <span class="cov0" title="0">translated, err := t.TranslatePhrases(e, title, lang)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return translated, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package util

import (
        "cloud.google.com/go/firestore"
        "context"
        "errors"
        "github.com/go-playground/form/v4"
        "google.golang.org/api/iterator"
        "net/http"
        "os"
)

var (
        Integration = false
)

// PathExists returns whether the given file or directory exists
func PathExists(path string) (bool, error) <span class="cov8" title="1">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

// DecodePostForm  helper method. The second parameter here, dst,
// is the target destination that we want to decode the form data into.
func DecodePostForm(r *http.Request, dst any, fd *form.Decoder) error <span class="cov0" title="0">{
        // Call Decode() on our decoder instance, passing the target destination as
        // the first parameter.
        err := fd.Decode(dst, r.PostForm)
        if err != nil </span><span class="cov0" title="0">{
                // If we try to use an invalid target destination, the Decode() method
                // will return an error with the type *form.InvalidDecoderError.We use
                // errors.As() to check for this and raise a panic rather than returning
                // the error.
                var invalidDecoderError *form.InvalidDecoderError

                if errors.As(err, &amp;invalidDecoderError) </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                // For all other errors, we return them as normal.
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// RemoveDuplicateStr removes duplicate strings from a slice.
// In this application, it will be particularly useful if someone wants to use
// song lyrics to build the mp3 files.
// You cannot use a sort function because you want to keep the order.
func RemoveDuplicateStr(strSlice []string) []string <span class="cov8" title="1">{
        allKeys := make(map[string]bool)
        var list []string
        for _, item := range strSlice </span><span class="cov8" title="1">{
                if _, value := allKeys[item]; !value </span><span class="cov8" title="1">{
                        allKeys[item] = true
                        list = append(list, item)
                }</span>
        }
        <span class="cov8" title="1">return list</span>
}

// RemoveLongStr removes strings with more than 150 characters.
func RemoveLongStr(strSlice []string) []string <span class="cov8" title="1">{
        var list []string
        for _, item := range strSlice </span><span class="cov8" title="1">{
                if len(item) &lt; 150 </span><span class="cov8" title="1">{
                        list = append(list, item)
                }</span>
        }
        <span class="cov8" title="1">return list</span>
}

func DeleteFirestoreCollection(ctx context.Context, client *firestore.Client, coll *firestore.CollectionRef) error <span class="cov0" title="0">{
        // delete all documents in test collection
        bulkwriter := client.BulkWriter(ctx)
        for </span><span class="cov0" title="0">{
                // Get a batch of documents
                iter := coll.Documents(ctx)
                numDeleted := 0

                // Iterate through the documents, adding
                // a delete operation for each one to the BulkWriter.
                for </span><span class="cov0" title="0">{
                        doc, err := iter.Next()
                        if errors.Is(err, iterator.Done) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">_, err = bulkwriter.Delete(doc.Ref)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">numDeleted++</span>
                }

                // If there are no documents to delete,
                // the process is over.
                <span class="cov0" title="0">if numDeleted == 0 </span><span class="cov0" title="0">{
                        bulkwriter.End()
                        break</span>
                }

                <span class="cov0" title="0">bulkwriter.Flush()</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package validator

import (
        "net/mail"
        "strings"
        "unicode/utf8"
)

// Validator Add a new NonFieldErrors []string field to the struct, which we will use to
// hold any validation errors which are not related to a specific form field.
type Validator struct {
        NonFieldErrors []string
        FieldErrors    map[string]string
}

// Valid Update the Valid() method to also check that the NonFieldErrors slice is
// empty.
func (v *Validator) Valid() bool <span class="cov0" title="0">{
        return len(v.FieldErrors) == 0 &amp;&amp; len(v.NonFieldErrors) == 0
}</span>

// In returns true if a specific value is in a list of strings.
func In(value string, list ...string) bool <span class="cov0" title="0">{
        for i := range list </span><span class="cov0" title="0">{
                if value == list[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CheckField adds an error message to the FieldErrors map only if a
// validation check is not 'ok'.
func (v *Validator) CheckField(ok bool, key, message string) <span class="cov0" title="0">{
        if !ok </span><span class="cov0" title="0">{
                v.AddFieldError(key, message)
        }</span>
}

// Matches returns true if a value matches a provided compiled regular
// expression pattern.
//func Matches(value string, rx *regexp.Regexp) bool {
//        return rx.MatchString(value)
//}

func (v *Validator) IsEmail(email string) bool <span class="cov0" title="0">{
        emailAddress, err := mail.ParseAddress(email)
        return err == nil &amp;&amp; emailAddress.Address == email
}</span>

// AddNonFieldError Create an AddNonFieldError() helper for adding error messages to the new
// NonFieldErrors slice.
func (v *Validator) AddNonFieldError(message string) <span class="cov0" title="0">{
        v.NonFieldErrors = append(v.NonFieldErrors, message)
}</span>

// AddFieldError adds an error message to the FieldErrors map (so long as no
// entry already exists for the given key).
func (v *Validator) AddFieldError(key, message string) <span class="cov0" title="0">{
        // Note: We need to initialize the map first, if it isn't already
        // initialized.
        if v.FieldErrors == nil </span><span class="cov0" title="0">{
                v.FieldErrors = make(map[string]string)
        }</span>

        <span class="cov0" title="0">if _, exists := v.FieldErrors[key]; !exists </span><span class="cov0" title="0">{
                v.FieldErrors[key] = message
        }</span>
}

// NotBlank returns true if a value is not an empty string.
func (v *Validator) NotBlank(value string) bool <span class="cov0" title="0">{
        return strings.TrimSpace(value) != ""
}</span>

// NotNil returns true if a value is not nill.
func (v *Validator) NotNil(value any) bool <span class="cov0" title="0">{
        return value != nil
}</span>

// MinChars returns true if a value contains at least n characters.
func (v *Validator) MinChars(value string, n int) bool <span class="cov0" title="0">{
        return utf8.RuneCountInString(value) &gt;= n
}</span>

// MaxChars returns true if a value contains less than n characters.
func (v *Validator) MaxChars(value string, n int) bool <span class="cov0" title="0">{
        return utf8.RuneCountInString(value) &lt;= n
}</span>

// In returns true if a specific value is in a list of strings.
func (v *Validator) In(value string, list ...string) bool <span class="cov0" title="0">{
        for i := range list </span><span class="cov0" title="0">{
                if value == list[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">//go:build go1.22

package main

import (
        "flag"
        "log"
        "net"
        "os/exec"
        "strings"
        "talkliketv.click/tltv/api"
        "talkliketv.click/tltv/internal/audio/audiofile"
        "talkliketv.click/tltv/internal/config"
        "talkliketv.click/tltv/internal/models"
        "talkliketv.click/tltv/internal/translates"
)

func main() <span class="cov0" title="0">{
        var cfg config.Config
        err := cfg.SetConfigs()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">flag.Parse()

        // if ffmpeg is not installed and in PATH of host machine fail immediately
        cmd := exec.Command("ffmpeg", "-version")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Please make sure ffmep is installed and in PATH\n: %s", err)
        }</span>
        <span class="cov0" title="0">if !strings.Contains(string(output), "ffmpeg version") </span><span class="cov0" title="0">{
                log.Fatalf("Please make sure ffmep is installed and in PATH\n: %s", string(output))
        }</span>

        //initialize audiofile with the real command runner
        <span class="cov0" title="0">af := audiofile.New(&amp;audiofile.RealCmdRunner{})

        // create translates with google or amazon clients depending on the flag set in conifg
        // I also set a global platform since this will not be changed during execution
        t := translates.New(*translates.NewGoogleClients(), translates.AmazonClients{}, &amp;models.Models{})
        if translates.GlobalPlatform == translates.Amazon </span><span class="cov0" title="0">{
                t = translates.New(translates.GoogleClients{}, *translates.NewAmazonClients(), &amp;models.Models{})
        }</span>

        <span class="cov0" title="0">fClient, err := cfg.FirestoreClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error creating firestore client: ", err)
        }</span>

        <span class="cov0" title="0">tokensColl := fClient.Collection("tokens")
        tokens := models.Tokens{Coll: tokensColl}

        // create new server
        e := api.NewServer(cfg, t, af, &amp;tokens)

        e.Logger.Fatal(e.Start(net.JoinHostPort("0.0.0.0", cfg.Port)))</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
coinsfirestore uploads a jsonfile of tokens to the default firestore database

Usage:

        go run coinsfirestore.go [flags]

The flags are:

        -f
            The file path to the json file to upload
        -p
            The project id to upload it to
*/
package main

import (
        "context"
        "encoding/json"
        firebase "firebase.google.com/go"
        "flag"
        "fmt"
        "log"
        "os"
        "talkliketv.click/tltv/internal/models"
        "talkliketv.click/tltv/internal/test"
)

func main() <span class="cov0" title="0">{
        filePath := flag.String("f", "", "filepath is required")
        projectID := flag.String("p", test.TestProject, "project is required")
        collection := flag.String("c", test.FirestoreTestCollection, "collection is required. ")
        flag.Parse()

        if *filePath == "" </span><span class="cov0" title="0">{
                fmt.Println("Error: -f filepath flag is required")
                os.Exit(1)
        }</span>

        // Use the application default credentials
        <span class="cov0" title="0">ctx := context.Background()
        conf := &amp;firebase.Config{ProjectID: *projectID}
        app, err := firebase.NewApp(ctx, conf)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>

        <span class="cov0" title="0">client, err := app.Firestore(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Open the JSON file
        file, err := os.Open(*filePath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error opening file:", err)
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Decode the JSON data
        var tokens []models.Token
        decoder := json.NewDecoder(file)
        err = decoder.Decode(&amp;tokens)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error decoding JSON:", err)
                return
        }</span>

        // get the tokens collection from the database
        <span class="cov0" title="0">tokensColl := client.Collection(*collection)
        for _, token := range tokens </span><span class="cov0" title="0">{
                _, err = tokensColl.Doc(token.Hash).Set(ctx, models.FirestoreToken{
                        UploadUsed: token.UploadUsed,
                        TimesUsed:  token.TimesUsed,
                        Created:    token.Created,
                })
                //_, _, err = tokensColl.Add(ctx, token)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed adding token: %v", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
generatecoins generates tokens to be used in token-tltv.

It will print the plaintext token once when you run the program. They will not be
saved to the json file so you must save them to some place safe after you run the
program.

Usage:

        generatecoins [flags] [path ...]
        go run generatecoins.go -o ../../internal/models/jsonmodels/ -n 100

The flags are:

        -o
            The file where you want the tokens json file to be output. Default is /tmp/
        -n
            The number of tokens you want to be generated. Default is 10.
*/
package main

import (
        "flag"
        "log"
        "talkliketv.click/tltv/internal/models"
        "time"
)

func main() <span class="cov0" title="0">{
        var outputPath string
        var numTokens int

        filename := "tokens-" + time.Now().Format("20060102150405") + ".json"
        flag.StringVar(&amp;outputPath, "o", "/tmp/", "file path where you want json token file")
        flag.IntVar(&amp;numTokens, "n", 0, "the number of tokens to generate")
        flag.Parse()

        plaintexts, err := models.CreateTokensFile(outputPath, filename, numTokens)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">for i := range plaintexts </span><span class="cov0" title="0">{
                println(plaintexts[i])
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
