
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">talkliketv.click/tltv/api/audio.go (52.9%)</option>
				
				<option value="file1">talkliketv.click/tltv/api/languages.go (71.4%)</option>
				
				<option value="file2">talkliketv.click/tltv/api/permissions.go (92.3%)</option>
				
				<option value="file3">talkliketv.click/tltv/api/phrases.go (71.1%)</option>
				
				<option value="file4">talkliketv.click/tltv/api/server.go (62.7%)</option>
				
				<option value="file5">talkliketv.click/tltv/api/titles.go (79.0%)</option>
				
				<option value="file6">talkliketv.click/tltv/api/users.go (78.7%)</option>
				
				<option value="file7">talkliketv.click/tltv/api/voices.go (81.8%)</option>
				
				<option value="file8">talkliketv.click/tltv/db/sqlc/db.go (50.0%)</option>
				
				<option value="file9">talkliketv.click/tltv/db/sqlc/error.go (0.0%)</option>
				
				<option value="file10">talkliketv.click/tltv/db/sqlc/languages.sql.go (0.0%)</option>
				
				<option value="file11">talkliketv.click/tltv/db/sqlc/permissions.sql.go (0.0%)</option>
				
				<option value="file12">talkliketv.click/tltv/db/sqlc/phrases.sql.go (0.0%)</option>
				
				<option value="file13">talkliketv.click/tltv/db/sqlc/titles.sql.go (0.0%)</option>
				
				<option value="file14">talkliketv.click/tltv/db/sqlc/translates.sql.go (0.0%)</option>
				
				<option value="file15">talkliketv.click/tltv/db/sqlc/users.sql.go (0.0%)</option>
				
				<option value="file16">talkliketv.click/tltv/db/sqlc/voices.sql.go (0.0%)</option>
				
				<option value="file17">talkliketv.click/tltv/internal/audio/audiofile/audiofile.go (83.4%)</option>
				
				<option value="file18">talkliketv.click/tltv/internal/audio/pattern/pattern.go (40.0%)</option>
				
				<option value="file19">talkliketv.click/tltv/internal/config/config.go (27.1%)</option>
				
				<option value="file20">talkliketv.click/tltv/internal/mock/audiofile/audiofile.go (83.3%)</option>
				
				<option value="file21">talkliketv.click/tltv/internal/mock/db/store.go (83.8%)</option>
				
				<option value="file22">talkliketv.click/tltv/internal/mock/translates/translates.go (98.2%)</option>
				
				<option value="file23">talkliketv.click/tltv/internal/oapi/tltv.gen.go (62.7%)</option>
				
				<option value="file24">talkliketv.click/tltv/internal/test/test_util.go (96.3%)</option>
				
				<option value="file25">talkliketv.click/tltv/internal/token/fakejws.go (70.8%)</option>
				
				<option value="file26">talkliketv.click/tltv/internal/token/jwtauthenticator.go (78.7%)</option>
				
				<option value="file27">talkliketv.click/tltv/internal/translates/translates.go (49.0%)</option>
				
				<option value="file28">talkliketv.click/tltv/internal/util/errors.go (100.0%)</option>
				
				<option value="file29">talkliketv.click/tltv/internal/util/helpers.go (80.0%)</option>
				
				<option value="file30">talkliketv.click/tltv/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "database/sql"
        "errors"
        "fmt"
        "github.com/labstack/echo/v4"
        "net/http"
        "os"
        "slices"
        "strconv"
        "strings"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/audio/audiofile"
        "talkliketv.click/tltv/internal/oapi"
        "talkliketv.click/tltv/internal/test"
        "talkliketv.click/tltv/internal/util"
)

// AudioFromFile accepts a file in srt, phrase per line, or paragraph form and
// sends a zip file of mp3 audio tracks for learning a language that you choose
func (s *Server) AudioFromFile(e echo.Context) error <span class="cov8" title="1">{
        // get values from multipart form
        titleName := e.FormValue("titleName")
        // convert strings from multipart form to int16's
        fileLangId, err := util.ConvertStringInt16(e.FormValue("fileLanguageId"))
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, fmt.Sprintf("error converting fileLanguageId to int16: %s", err.Error()))
        }</span>
        <span class="cov8" title="1">toVoiceId, err := util.ConvertStringInt16(e.FormValue("toVoiceId"))
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, fmt.Sprintf("error converting toVoiceId to int16: %s", err.Error()))
        }</span>
        <span class="cov8" title="1">fromVoiceId, err := util.ConvertStringInt16(e.FormValue("fromVoiceId"))
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, fmt.Sprintf("error converting fromVoiceId to int16: %s", err.Error()))
        }</span>
        // check if user sent 'pause' in the request and update config if they did
        <span class="cov8" title="1">pause := e.FormValue("pause")
        if pause != "" </span><span class="cov8" title="1">{
                pauseInt, err := strconv.Atoi(pause)
                if err != nil </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, fmt.Sprintf("error converting fromVoiceId to int: %s", err.Error()))
                }</span>
                <span class="cov8" title="1">if pauseInt &gt; 10 || pauseInt &lt; 3 </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, fmt.Sprintf("pause must be between 3 and 10: %d", pauseInt))
                }</span>
                <span class="cov8" title="1">s.config.PhrasePause = pauseInt</span>
        }

        <span class="cov8" title="1">pattern := e.FormValue("pattern")
        if pattern != "" </span><span class="cov0" title="0">{
                patternInt, err := strconv.Atoi(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, fmt.Sprintf("error converting pattern to int: %s", err.Error()))
                }</span>
                <span class="cov0" title="0">if patternInt &gt; 3 || patternInt &lt; 1 </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, fmt.Sprintf("pattern must be between 1 and 3: %d", patternInt))
                }</span>
                <span class="cov0" title="0">s.config.AudioPattern = patternInt</span>
        }
        <span class="cov8" title="1">e.Set("pattern", s.config.AudioPattern)

        title, phraseZipFile, err := s.processFile(e, titleName, fileLangId)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, util.ErrTooManyPhrases) </span><span class="cov0" title="0">{
                        return e.Attachment(phraseZipFile.Name(), "TooManyPhrasesUseTheseFiles.zip")
                }</span>
                <span class="cov8" title="1">if strings.Contains(err.Error(), "unable to parse file") </span><span class="cov8" title="1">{
                        return e.String(http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov8" title="1">return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        <span class="cov8" title="1">audioFromTitleRequest := oapi.AudioFromTitleJSONRequestBody{
                TitleId:     title.ID,
                ToVoiceId:   toVoiceId,
                FromVoiceId: fromVoiceId,
        }
        zipFile, err := s.createAudioFromTitle(e, *title, audioFromTitleRequest)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, util.ErrVoiceLangIdNoMatch) </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">if errors.Is(err, util.ErrVoiceIdInvalid) </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">if errors.Is(err, util.ErrOneFile) </span><span class="cov0" title="0">{
                        return e.Attachment(zipFile.Name(), title.Title+".mp3")
                }</span>
                <span class="cov0" title="0">return e.String(http.StatusInternalServerError, err.Error())</span>
        }
        <span class="cov8" title="1">return e.Attachment(zipFile.Name(), title.Title+".zip")</span>
}

func (s *Server) processFile(e echo.Context, titleName string, fileLangId int16) (*db.Title, *os.File, error) <span class="cov8" title="1">{
        // Get file handler for filename, size and headers
        fh, err := e.FormFile("filePath")
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, nil, util.ErrUnableToParseFile(err)
        }</span>

        // Check if file size is too large 64000 == 8KB ~ approximately 4 pages of text
        <span class="cov8" title="1">if fh.Size &gt; s.config.FileUploadLimit </span><span class="cov8" title="1">{
                rString := fmt.Sprintf("file too large (%d &gt; %d)", fh.Size, s.config.FileUploadLimit)
                return nil, nil, util.ErrUnableToParseFile(errors.New(rString))
        }</span>
        <span class="cov8" title="1">src, err := fh.Open()
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">defer src.Close()

        // get an array of all the phrases from the uploaded file
        stringsSlice, err := s.af.GetLines(e, src)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, util.ErrUnableToParseFile(err)
        }</span>
        // send back zip of split files of phrase that requester can use if too big
        <span class="cov8" title="1">if len(stringsSlice) &gt; s.config.MaxNumPhrases </span><span class="cov0" title="0">{
                chunkedPhrases := slices.Chunk(stringsSlice, s.config.MaxNumPhrases)
                phrasesBasePath := s.config.TTSBasePath + titleName + "/"
                // create zip of phrases files of maxNumPhrases for user to use instead of uploaded file
                zipFile, err := s.af.CreatePhrasesZip(e, chunkedPhrases, phrasesBasePath, titleName)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">return nil, zipFile, util.ErrTooManyPhrases</span>
        }

        // We're always asynchronous, so lock unsafe operations below
        <span class="cov8" title="1">s.Lock()
        defer s.Unlock()

        // insert title into the database
        title, err := s.queries.InsertTitle(
                e.Request().Context(),
                db.InsertTitleParams{
                        Title:        titleName,
                        NumSubs:      int16(len(stringsSlice)),
                        OgLanguageID: fileLangId,
                })
        if err != nil </span><span class="cov8" title="1">{
                e.Logger().Error(err)
                return nil, nil, err
        }</span>

        // insert phrases into db as translates object of OgLanguage
        <span class="cov8" title="1">_, err = s.translates.InsertNewPhrases(e, title, s.queries, stringsSlice)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                _ = s.queries.DeleteTitleById(e.Request().Context(), title.ID)
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return &amp;title, nil, nil</span>
}

// AudioFromTitle accepts a title id and returns a zip file of mp3 audio tracks for
// learning a language that you choose
func (s *Server) AudioFromTitle(e echo.Context) error <span class="cov8" title="1">{
        var audioFromTitleRequest oapi.AudioFromTitleJSONRequestBody
        err := e.Bind(&amp;audioFromTitleRequest)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">if audioFromTitleRequest.Pattern != nil </span><span class="cov0" title="0">{
                s.config.AudioPattern = *audioFromTitleRequest.Pattern
        }</span>
        <span class="cov8" title="1">e.Set("pattern", s.config.AudioPattern)

        if audioFromTitleRequest.Pause != nil </span><span class="cov8" title="1">{
                s.config.PhrasePause = *audioFromTitleRequest.Pause
        }</span>
        <span class="cov8" title="1">e.Set("pause", audioFromTitleRequest.Pause)

        // get title to translate from
        title, err := s.queries.SelectTitleById(e.Request().Context(), audioFromTitleRequest.TitleId)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, "invalid title id")
                }</span>
                <span class="cov8" title="1">e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        <span class="cov8" title="1">zipFile, err := s.createAudioFromTitle(e, title, audioFromTitleRequest)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, util.ErrVoiceLangIdNoMatch) </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">if errors.Is(err, util.ErrVoiceIdInvalid) </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">if errors.Is(err, util.ErrOneFile) </span><span class="cov0" title="0">{
                        return e.Attachment(zipFile.Name(), title.Title+".mp3")
                }</span>
                <span class="cov0" title="0">return e.String(http.StatusInternalServerError, err.Error())</span>
        }
        <span class="cov8" title="1">return e.Attachment(zipFile.Name(), title.Title+".zip")</span>
}

// createAudioFromTitle is a helper function that performs the tasks shared by
// AudioFromFile and AudioFromTitle
func (s *Server) createAudioFromTitle(e echo.Context, title db.Title, r oapi.AudioFromTitleJSONRequestBody) (*os.File, error) <span class="cov8" title="1">{

        fromVoice, err := s.queries.SelectVoiceById(e.Request().Context(), r.FromVoiceId)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, util.ErrVoiceIdInvalid
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">toVoice, err := s.queries.SelectVoiceById(e.Request().Context(), r.ToVoiceId)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, util.ErrVoiceIdInvalid
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // TODO if you don't want these files to persist then you need to defer removing them from calling function
        <span class="cov8" title="1">audioBasePath := fmt.Sprintf("%s%d/", s.config.TTSBasePath, title.ID)

        fromAudioBasePath := fmt.Sprintf("%s%d/", audioBasePath, fromVoice.LanguageID)
        toAudioBasePath := fmt.Sprintf("%s%d/", audioBasePath, toVoice.LanguageID)

        if err = s.translates.CreateTTS(e, s.queries, title, r.FromVoiceId, fromAudioBasePath); err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                osErr := os.RemoveAll(audioBasePath)
                if osErr != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(osErr)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if err = s.translates.CreateTTS(e, s.queries, title, r.ToVoiceId, toAudioBasePath); err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                osErr := os.RemoveAll(audioBasePath)
                if osErr != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(osErr)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">phraseIds, err := s.queries.SelectPhraseIdsByTitleId(e.Request().Context(), title.ID)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                osErr := os.RemoveAll(audioBasePath)
                if osErr != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(osErr)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">pausePath, ok := audiofile.AudioPauseFilePath[s.config.PhrasePause]
        if !ok </span><span class="cov0" title="0">{
                e.Logger().Error(errors.New("audio pause file not found"))
                return nil, err
        }</span>
        <span class="cov8" title="1">fullPausePath := s.config.TTSBasePath + pausePath

        tmpDirPath := fmt.Sprintf("%s%s-%s/", s.config.TTSBasePath, title.Title, test.RandomString(4))
        err = os.MkdirAll(tmpDirPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = s.af.BuildAudioInputFiles(e, phraseIds, title, fullPausePath, fromAudioBasePath, toAudioBasePath, tmpDirPath); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.af.CreateMp3Zip(e, title, tmpDirPath)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "github.com/labstack/echo/v4"
        "net/http"
        "talkliketv.click/tltv/internal/oapi"
)

// GetLanguages returns a list of all the available languages for the
// translate functions
func (s *Server) GetLanguages(e echo.Context, params oapi.GetLanguagesParams) error <span class="cov8" title="1">{

        similarity := ""
        if params.Similarity != nil </span><span class="cov0" title="0">{
                similarity = *params.Similarity
        }</span>
        <span class="cov8" title="1">languages, err := s.queries.ListLanguagesSimilar(e.Request().Context(), similarity)
        if err != nil </span><span class="cov0" title="0">{
                return e.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return e.JSON(http.StatusOK, languages)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "github.com/labstack/echo/v4"
        "net/http"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/oapi"
)

// AddUserPermission allows user with global:admin permission to add any
// permission to any user
func (s *Server) AddUserPermission(e echo.Context) error <span class="cov8" title="1">{
        // We expect a NewTitle object in the request body.
        var newUserPermission oapi.NewUserPermission
        err := e.Bind(&amp;newUserPermission)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        // We're always asynchronous, so lock unsafe operations below
        <span class="cov8" title="1">s.Lock()
        defer s.Unlock()

        userPermission, err := s.queries.InsertUserPermission(
                e.Request().Context(),
                db.InsertUserPermissionParams{
                        UserID:       newUserPermission.UserId,
                        PermissionID: newUserPermission.PermissionId,
                })

        if err != nil </span><span class="cov8" title="1">{
                if db.PqErrorCode(err) == db.ForeignKeyViolation </span><span class="cov8" title="1">{
                        return e.String(http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov8" title="1">e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        <span class="cov8" title="1">return e.JSON(http.StatusCreated, userPermission)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        jsonpatch "github.com/evanphx/json-patch/v5"
        "github.com/labstack/echo/v4"
        "io"
        "net/http"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/oapi"
        "talkliketv.click/tltv/internal/token"
)

// GetPhrases gets the next set limit or default ten phrases for user title and language ids
// sorted by ascending correctness (correctness is how many times a user has guessed a phrase
// correctly)
func (s *Server) GetPhrases(e echo.Context, params oapi.GetPhrasesParams) error <span class="cov8" title="1">{

        if params.Limit == nil </span><span class="cov8" title="1">{
                params.Limit = new(int32)
                *params.Limit = 10
        }</span>

        <span class="cov8" title="1">user, err := token.GetUserFromContext(e)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">usersPhrases, err := s.queries.SelectTranslatesWithCorrect(
                e.Request().Context(),
                db.SelectTranslatesWithCorrectParams{
                        UserID:       user.ID,
                        TitleID:      user.TitleID,
                        LanguageID:   user.OgLanguageID,
                        LanguageID_2: user.NewLanguageID,
                        Limit:        *params.Limit,
                })

        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return e.JSON(http.StatusOK, usersPhrases)</span>
}

// UpdateUsersPhrases performs a PATCH request on the users_phrases table. It will
// mostly be used to increase the correct column by one.
func (s *Server) UpdateUsersPhrases(e echo.Context, phraseId int64, languageId int16) error <span class="cov8" title="1">{
        user, err := token.GetUserFromContext(e)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(e.Request().Body)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">patch, err := jsonpatch.DecodePatch(body)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">usersPhraseById, err := s.queries.SelectUsersPhrasesByIds(
                e.Request().Context(),
                db.SelectUsersPhrasesByIdsParams{
                        UserID:     user.ID,
                        LanguageID: languageId,
                        PhraseID:   phraseId,
                })
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusInternalServerError, fmt.Sprintf("Error selecting user phrase by ids: %s", err.Error()))
        }</span>

        <span class="cov8" title="1">current := oapi.UsersPhrases{
                LanguageId:    usersPhraseById.LanguageID,
                TitleId:       usersPhraseById.TitleID,
                PhraseId:      usersPhraseById.PhraseID,
                UserId:        usersPhraseById.UserID,
                PhraseCorrect: usersPhraseById.PhraseCorrect,
        }

        currentBytes, err := json.Marshal(current)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">modifiedBytes, err := patch.Apply(currentBytes)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">var modified oapi.UsersPhrases
        err = json.Unmarshal(modifiedBytes, &amp;modified)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">updatedUsersPhrases, err := s.queries.UpdateUsersPhrasesByThreeIds(
                e.Request().Context(),
                db.UpdateUsersPhrasesByThreeIdsParams{
                        TitleID:       modified.TitleId,
                        UserID:        modified.UserId,
                        PhraseID:      modified.PhraseId,
                        LanguageID:    modified.LanguageId,
                        PhraseCorrect: modified.PhraseCorrect,
                })

        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return e.JSON(http.StatusOK, updatedUsersPhrases)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        texttospeech "cloud.google.com/go/texttospeech/apiv1"
        "cloud.google.com/go/translate"
        "context"
        "encoding/json"
        "fmt"
        "github.com/getkin/kin-openapi/openapi3"
        "github.com/getkin/kin-openapi/openapi3filter"
        ui "github.com/go-openapi/runtime/middleware"
        "github.com/labstack/echo/v4"
        v4mw "github.com/labstack/echo/v4/middleware"
        mw "github.com/oapi-codegen/echo-middleware"
        "log"
        "os"
        "strconv"
        "sync"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/audio"
        "talkliketv.click/tltv/internal/audio/audiofile"
        "talkliketv.click/tltv/internal/config"
        "talkliketv.click/tltv/internal/oapi"
        "talkliketv.click/tltv/internal/token"
        "talkliketv.click/tltv/internal/translates"
        "talkliketv.click/tltv/internal/util"
)

type Server struct {
        sync.RWMutex
        queries    db.Querier
        translates translates.TranslateX
        config     config.Config
        fa         token.FakeAuthenticator
        af         audiofile.AudioFileX
}

// NewServer creates a new HTTP server and sets up routing.
func NewServer(e *echo.Echo, cfg config.Config, q db.Querier, t translates.TranslateX, af audiofile.AudioFileX) *Server <span class="cov8" title="1">{

        spec, err := oapi.GetSwagger()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("loading spec: %w", err)
        }</span>

        <span class="cov8" title="1">g := e.Group("/swagger")
        g.GET("/doc.json", func(ctx echo.Context) error </span><span class="cov0" title="0">{
                err := json.NewEncoder(ctx.Response().Writer).Encode(spec)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error encoding swagger spec\n: %s\n", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov8" title="1">swaggerHandler := ui.SwaggerUI(ui.SwaggerUIOpts{
                Path:    "/swagger/",
                SpecURL: "/swagger/doc.json",
        }, nil)

        g.GET("/", echo.WrapHandler(swaggerHandler))

        // Create a fake authenticator. This allows us to issue tokens, and also
        // implements a validator to check their validity.
        fa, err := token.NewFakeAuthenticator(&amp;cfg.JWTDuration)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("error creating authenticator:", err)
        }</span>

        <span class="cov8" title="1">spec.Servers = openapi3.Servers{&amp;openapi3.Server{URL: "/v1"}}

        // make sure silence mp3s exist in your base path
        initSilence(e, cfg)

        // Create middleware for validating tokens.
        middle, err := createMiddleware(fa, spec)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("error creating middleware:", err)
        }</span>
        <span class="cov8" title="1">apiGrp := e.Group("/v1")
        apiGrp.Use(v4mw.Logger())
        apiGrp.Use(v4mw.Recover())
        apiGrp.Use(middle...)

        srv := &amp;Server{
                fa:         *fa,
                translates: t,
                queries:    q,
                config:     cfg,
                af:         af,
        }

        oapi.RegisterHandlersWithBaseURL(apiGrp, srv, "")

        return srv</span>
}

// Make sure we conform to ServerInterface
var _ oapi.ServerInterface = (*Server)(nil)

// createMiddleware creates the JWS middleware function that will validate the JWT token
// and store data in echo context for use in echo handlers
func createMiddleware(v token.JWSValidator, spec *openapi3.T) ([]echo.MiddlewareFunc, error) <span class="cov8" title="1">{
        validator := mw.OapiRequestValidatorWithOptions(spec,
                &amp;mw.Options{
                        Options: openapi3filter.Options{
                                AuthenticationFunc: token.NewAuthenticator(v),
                        },
                        SilenceServersWarning: true,
                })

        return []echo.MiddlewareFunc{validator}, nil
}</span>

// initSilence copies the silence mp3's from the embedded filesystem to the config TTSBasePath
func initSilence(e *echo.Echo, cfg config.Config) <span class="cov8" title="1">{
        // check if silence mp3s exist in your base path
        silencePath := cfg.TTSBasePath + audiofile.AudioPauseFilePath[cfg.PhrasePause]
        exists, err := util.PathExists(silencePath)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Fatal(err)
        }</span>
        // if it doesn't exist copy it from embedded FS to TTSBasePath
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                err = os.MkdirAll(cfg.TTSBasePath+"silence/", 0777)
                for key, value := range audiofile.AudioPauseFilePath </span><span class="cov8" title="1">{
                        fmt.Printf(strconv.Itoa(key))
                        pause, err := audio.Silence.ReadFile(value)
                        if err != nil </span><span class="cov0" title="0">{
                                e.Logger.Fatal(err)
                        }</span>
                        // Create a new file
                        <span class="cov8" title="1">file, err := os.Create(cfg.TTSBasePath + value)
                        if err != nil </span><span class="cov0" title="0">{
                                e.Logger.Fatal(err)
                        }</span>
                        <span class="cov8" title="1">defer file.Close()
                        // Write to the file
                        _, err = file.Write(pause)
                        if err != nil </span><span class="cov0" title="0">{
                                e.Logger.Fatal(err)
                        }</span>
                        // Ensure data is written to disk
                        <span class="cov8" title="1">err = file.Sync()
                        if err != nil </span><span class="cov0" title="0">{
                                e.Logger.Fatal(err)
                        }</span>
                }
        }
}

// Depends creates a new google translate and text-to-speech clients; constructs
// the translates and audiofile dependencies and returns them
func Depends(e *echo.Echo) (*translates.Translate, *audiofile.AudioFile) <span class="cov0" title="0">{
        // create google translate and text-to-speech clients
        ctx := context.Background()
        transClient, err := translate.NewClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Fatal("Error creating google api translate client\n: %s", err)
        }</span>
        <span class="cov0" title="0">ttsClient, err := texttospeech.NewClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Fatal("Error creating google api translate client\n: %s", err)
        }</span>
        <span class="cov0" title="0">t := translates.New(transClient, ttsClient)

        //initialize audiofile with the real command runner
        af := audiofile.New(&amp;audiofile.RealCmdRunner{})

        return t, af</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "database/sql"
        "errors"
        "fmt"
        "github.com/labstack/echo/v4"
        "net/http"
        "strings"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/oapi"
        "talkliketv.click/tltv/internal/util"
)

// FindTitles returns the number of titles set by the Limit and Similarity params
func (s *Server) FindTitles(ctx echo.Context, params oapi.FindTitlesParams) error <span class="cov8" title="1">{

        titles, err := s.queries.ListTitles(
                ctx.Request().Context(),
                db.ListTitlesParams{
                        Similarity: params.Similarity,
                        Limit:      params.Limit,
                })

        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger().Error(err)
                return ctx.String(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return ctx.JSON(http.StatusOK, titles)</span>
}

// AddTitle takes your uploaded file, filename, and title and adds it to the database,
// along with adding the phrases in the original language to the translates table
func (s *Server) AddTitle(e echo.Context) error <span class="cov8" title="1">{

        // get lang id and title from multipart form
        titleName := e.FormValue("titleName")
        fileLangId, err := util.ConvertStringInt16(e.FormValue("languageId"))
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, fmt.Sprintf("error converting fileLanguageId to int16: %s", err.Error()))
        }</span>

        <span class="cov8" title="1">title, phraseZipFile, err := s.processFile(e, titleName, fileLangId)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, util.ErrTooManyPhrases) </span><span class="cov0" title="0">{
                        return e.Attachment(phraseZipFile.Name(), "TooManyPhrasesUseTheseFiles.zip")
                }</span>
                <span class="cov8" title="1">if strings.Contains(err.Error(), "unable to parse file") </span><span class="cov8" title="1">{
                        return e.String(http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov8" title="1">return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        <span class="cov8" title="1">return e.JSON(http.StatusOK, title)</span>
}

func (s *Server) FindTitleByID(e echo.Context, id int64) error <span class="cov8" title="1">{

        title, err := s.queries.SelectTitleById(e.Request().Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                e.Logger().Error(err)
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return e.JSON(http.StatusOK, title)</span>
}

func (s *Server) DeleteTitle(e echo.Context, id int64) error <span class="cov8" title="1">{

        err := s.queries.DeleteTitleById(e.Request().Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov8" title="1">return e.NoContent(http.StatusNoContent)</span>
}

// TitlesTranslate translates the phrases of a title from the original language
// of the title to any available language by id and stores them in the translates table
func (s *Server) TitlesTranslate(e echo.Context) error <span class="cov8" title="1">{

        var newTranslateTitle oapi.TitlesTranslateRequest
        err := e.Bind(&amp;newTranslateTitle)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        // make sure the translates for that title don't already exist
        <span class="cov8" title="1">exists, err := s.queries.SelectExistsTranslates(
                e.Request().Context(),
                db.SelectExistsTranslatesParams{
                        LanguageID: newTranslateTitle.NewLanguageId,
                        ID:         newTranslateTitle.TitleId,
                })
        if exists </span><span class="cov8" title="1">{
                return e.String(http.StatusBadRequest, "title already exists in that language")
        }</span>

        // get title to translate from
        <span class="cov8" title="1">title, err := s.queries.SelectTitleById(e.Request().Context(), newTranslateTitle.TitleId)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return e.String(http.StatusBadRequest, "invalid title id")
                }</span>
                <span class="cov0" title="0">e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        // get language model for tag
        <span class="cov8" title="1">dbLang, err := s.queries.SelectLanguagesById(e.Request().Context(), newTranslateTitle.NewLanguageId)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return e.String(http.StatusBadRequest, "invalid language id")
                }</span>
                <span class="cov0" title="0">e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        // We're always asynchronous, so lock unsafe operations below
        <span class="cov8" title="1">s.Lock()
        defer s.Unlock()

        // get translates for original language to translate from
        phrasesToTranslate, err := s.queries.SelectTranslatesByTitleIdLangId(
                e.Request().Context(),
                db.SelectTranslatesByTitleIdLangIdParams{
                        ID:         newTranslateTitle.TitleId,
                        LanguageID: title.OgLanguageID,
                })
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        // get the translates from the phrases
        <span class="cov8" title="1">newTranslates, err := s.translates.TranslatePhrases(e, phrasesToTranslate, dbLang)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        // check if returned translates is empty
        <span class="cov8" title="1">if len(newTranslates) == 0 </span><span class="cov8" title="1">{
                return e.String(http.StatusInternalServerError, "something went wrong")
        }</span>

        // insert new translated phrases into the database
        <span class="cov8" title="1">insertTranslates, err := s.translates.InsertTranslates(e, s.queries, dbLang.ID, newTranslates)
        if err != nil </span><span class="cov8" title="1">{
                e.Logger().Info(fmt.Sprintf("Error inserting translates -- titleId: %d -- languageId: %d -- error: %s", title.ID, dbLang.ID, err.Error()))
                // roll back by deleting any translates that were inserted
                _ = s.queries.DeleteTranslatesByLanguageId(e.Request().Context(),
                        db.DeleteTranslatesByLanguageIdParams{
                                LanguageID: dbLang.ID,
                                TitleID:    title.ID,
                        })
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return e.JSON(http.StatusCreated, insertTranslates)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        jsonpatch "github.com/evanphx/json-patch/v5"
        "github.com/labstack/echo/v4"
        "golang.org/x/crypto/bcrypt"
        "io"
        "net/http"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/oapi"
        "talkliketv.click/tltv/internal/token"
        "talkliketv.click/tltv/internal/util"
        "time"
)

type userResponse struct {
        TitleID       int64     `json:"title_id"`
        Name          string    `json:"name"`
        Email         string    `json:"email"`
        Flipped       bool      `json:"flipped"`
        OgLanguageID  int16     `json:"og_language_id"`
        NewLanguageID int16     `json:"new_language_id"`
        Created       time.Time `json:"created"`
}

func newUserResponse(user db.User) userResponse <span class="cov8" title="1">{
        return userResponse{
                TitleID:       user.TitleID,
                Name:          user.Name,
                Email:         user.Email,
                OgLanguageID:  user.OgLanguageID,
                NewLanguageID: user.NewLanguageID,
                Created:       user.Created,
        }
}</span>

// CreateUser registers a new user
func (s *Server) CreateUser(e echo.Context) error <span class="cov8" title="1">{
        // We expect a NewUser object in the request body.
        var newUser oapi.NewUser
        err := e.Bind(&amp;newUser)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        // We're always asynchronous, so lock unsafe operations below
        <span class="cov8" title="1">s.Lock()
        defer s.Unlock()

        password, err := bcrypt.GenerateFromPassword([]byte(newUser.Password), 14)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">user, err := s.queries.InsertUser(
                e.Request().Context(),
                db.InsertUserParams{
                        Name:           newUser.Name,
                        Email:          newUser.Email,
                        HashedPassword: string(password),
                        TitleID:        newUser.TitleId,
                        OgLanguageID:   newUser.OgLanguageId,
                        NewLanguageID:  newUser.NewLanguageId,
                })

        if err != nil </span><span class="cov8" title="1">{
                if db.PqErrorCode(err) == db.UniqueViolation </span><span class="cov8" title="1">{
                        if db.PqErrorConstraint(err) == db.EmailConstraint </span><span class="cov0" title="0">{
                                return e.String(http.StatusBadRequest, "a user with this email address already exists")
                        }</span>
                        <span class="cov8" title="1">if db.PqErrorConstraint(err) == db.UsernameConstraint </span><span class="cov0" title="0">{
                                return e.String(http.StatusBadRequest, "a user with this name already exists")
                        }</span>
                        <span class="cov8" title="1">return e.String(http.StatusBadRequest, "duplicate key violation")</span>
                }
                <span class="cov8" title="1">e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        <span class="cov8" title="1">rsp := newUserResponse(user)
        return e.JSON(http.StatusOK, rsp)</span>
}

func (s *Server) DeleteUser(e echo.Context, id int64) error <span class="cov8" title="1">{
        err := token.CheckJWTUserIDFromRequest(e, id)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusForbidden, "Invalid user ID")
        }</span>

        <span class="cov8" title="1">err = s.queries.DeleteUserById(e.Request().Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusBadRequest, fmt.Sprintf("Error deleting user: %s", err))
        }</span>

        <span class="cov8" title="1">return e.NoContent(http.StatusNoContent)</span>
}

func (s *Server) FindUserByID(e echo.Context, id int64) error <span class="cov8" title="1">{
        err := token.CheckJWTUserIDFromRequest(e, id)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusForbidden, err.Error())
        }</span>

        <span class="cov8" title="1">user, err := s.queries.SelectUserById(e.Request().Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusBadRequest, fmt.Sprintf("Error selecting user by id: %s", err))
        }</span>

        <span class="cov8" title="1">rsp := newUserResponse(user)
        return e.JSON(http.StatusOK, rsp)</span>
}

// UpdateUser accepts a Patch request to update the user values
func (s *Server) UpdateUser(e echo.Context, id int64) error <span class="cov8" title="1">{

        err := token.CheckJWTUserIDFromRequest(e, id)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusForbidden, "Invalid user ID")
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(e.Request().Body)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">patch, err := jsonpatch.DecodePatch(body)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">user, err := s.queries.SelectUserById(e.Request().Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusBadRequest, fmt.Sprintf("Error selecting user by id: %s", err))
        }</span>

        <span class="cov8" title="1">current := oapi.NewUser{
                Email:         user.Email,
                NewLanguageId: user.NewLanguageID,
                OgLanguageId:  user.OgLanguageID,
                Password:      user.HashedPassword,
                TitleId:       user.TitleID,
        }

        currentBytes, err := json.Marshal(current)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">modifiedBytes, err := patch.Apply(currentBytes)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">var modified oapi.NewUser
        err = json.Unmarshal(modifiedBytes, &amp;modified)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        // perform business logic checks
        <span class="cov8" title="1">if modified.Password != current.Password </span><span class="cov0" title="0">{
                password, err := bcrypt.GenerateFromPassword([]byte(modified.Password), 14)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return e.String(http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">modified.Password = string(password)</span>
        }

        <span class="cov8" title="1">updatedUser, err := s.queries.UpdateUserById(
                e.Request().Context(),
                db.UpdateUserByIdParams{
                        TitleID:        modified.TitleId,
                        Email:          modified.Email,
                        OgLanguageID:   modified.OgLanguageId,
                        NewLanguageID:  modified.NewLanguageId,
                        HashedPassword: modified.Password,
                        ID:             id,
                })

        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">rsp := newUserResponse(updatedUser)
        return e.JSON(http.StatusOK, rsp)</span>
}

func (s *Server) LoginUser(e echo.Context) error <span class="cov8" title="1">{

        // We expect a NewUser object in the request body.
        var userLogin oapi.UserLogin
        err := e.Bind(&amp;userLogin)
        if err != nil </span><span class="cov0" title="0">{
                return e.String(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">user, err := s.queries.SelectUserByName(e.Request().Context(), userLogin.Username)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return e.String(http.StatusUnauthorized, "invalid username or password")
                }</span>
                <span class="cov8" title="1">e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())</span>
        }

        <span class="cov8" title="1">err = util.CheckPassword(userLogin.Password, user.HashedPassword)
        if err != nil </span><span class="cov8" title="1">{
                return e.String(http.StatusUnauthorized, "invalid username or password")
        }</span>

        <span class="cov8" title="1">permissions, err := s.queries.SelectUserPermissions(e.Request().Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return e.String(http.StatusInternalServerError, err.Error())
                }</span>
        }

        <span class="cov8" title="1">jwsToken, err := s.fa.CreateJWSWithClaims(permissions, user)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return e.JSON(http.StatusOK, jwsToken)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "github.com/labstack/echo/v4"
        "net/http"
        "talkliketv.click/tltv/internal/oapi"
)

// GetVoices returns a list of all the available voices for the
// text-to-speech functions
func (s *Server) GetVoices(e echo.Context, params oapi.GetVoicesParams) error <span class="cov8" title="1">{

        if params.LanguageId == nil </span><span class="cov8" title="1">{
                voices, err := s.queries.ListVoices(e.Request().Context())
                if err != nil </span><span class="cov8" title="1">{
                        e.Logger().Error(err)
                        return e.String(http.StatusInternalServerError, err.Error())
                }</span>

                <span class="cov8" title="1">return e.JSON(http.StatusOK, voices)</span>
        }

        <span class="cov8" title="1">voices, err := s.queries.SelectVoicesByLanguageId(e.Request().Context(), *params.LanguageId)

        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return e.String(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return e.JSON(http.StatusOK, voices)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package db

import (
        "context"
        "database/sql"
)

type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package db

import (
        "errors"
        "github.com/lib/pq"
)

var ErrUniqueViolation = &amp;pq.Error{
        Code: UniqueViolation,
}

var ErrForeignKeyViolation = &amp;pq.Error{
        Code:    ForeignKeyViolation,
        Message: "insert or update on table \"users_permissions\" violates foreign key constraint \"users_permissions_user_id_fkey\"",
}

const (
        ForeignKeyViolation = "23503"
        UniqueViolation     = "23505"
        EmailConstraint     = "users_email_key"
        UsernameConstraint  = "users_name_key"
        ReadTitlesCode      = "titles:r"
        WriteTitlesCode     = "titles:w"
        GlobalAdminCode     = "global:admin"
)

func PqErrorCode(err error) string <span class="cov0" title="0">{
        var pqErr *pq.Error
        if errors.As(err, &amp;pqErr) </span><span class="cov0" title="0">{
                return string(pqErr.Code)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func PqErrorConstraint(err error) string <span class="cov0" title="0">{
        var pqErr *pq.Error
        if errors.As(err, &amp;pqErr) </span><span class="cov0" title="0">{
                return pqErr.Constraint
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: languages.sql

package db

import (
        "context"
)

const listLanguages = `-- name: ListLanguages :many
SELECT id, language, tag FROM languages
`

func (q *Queries) ListLanguages(ctx context.Context) ([]Language, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listLanguages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Language{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Language
                if err := rows.Scan(&amp;i.ID, &amp;i.Language, &amp;i.Tag); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listLanguagesSimilar = `-- name: ListLanguagesSimilar :many
SELECT id, language, tag, similarity(language, $1) AS similarity
FROM languages
ORDER BY similarity desc
`

type ListLanguagesSimilarRow struct {
        ID         int16   `json:"id"`
        Language   string  `json:"language"`
        Tag        string  `json:"tag"`
        Similarity float32 `json:"similarity"`
}

func (q *Queries) ListLanguagesSimilar(ctx context.Context, similarity string) ([]ListLanguagesSimilarRow, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listLanguagesSimilar, similarity)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []ListLanguagesSimilarRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i ListLanguagesSimilarRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Language,
                        &amp;i.Tag,
                        &amp;i.Similarity,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const selectLanguagesById = `-- name: SelectLanguagesById :one
SELECT id, language, tag FROM languages WHERE id = $1
`

func (q *Queries) SelectLanguagesById(ctx context.Context, id int16) (Language, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectLanguagesById, id)
        var i Language
        err := row.Scan(&amp;i.ID, &amp;i.Language, &amp;i.Tag)
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: permissions.sql

package db

import (
        "context"
)

const deleteUserPermissionById = `-- name: DeleteUserPermissionById :exec
DELETE FROM users_permissions WHERE  user_id = $1 and permission_id = $2
`

type DeleteUserPermissionByIdParams struct {
        UserID       int64 `json:"user_id"`
        PermissionID int16 `json:"permission_id"`
}

func (q *Queries) DeleteUserPermissionById(ctx context.Context, arg DeleteUserPermissionByIdParams) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteUserPermissionById, arg.UserID, arg.PermissionID)
        return err
}</span>

const insertUserPermission = `-- name: InsertUserPermission :one
INSERT INTO users_permissions (user_id, permission_id)
VALUES ($1, $2)
RETURNING user_id, permission_id
`

type InsertUserPermissionParams struct {
        UserID       int64 `json:"user_id"`
        PermissionID int16 `json:"permission_id"`
}

func (q *Queries) InsertUserPermission(ctx context.Context, arg InsertUserPermissionParams) (UsersPermission, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, insertUserPermission, arg.UserID, arg.PermissionID)
        var i UsersPermission
        err := row.Scan(&amp;i.UserID, &amp;i.PermissionID)
        return i, err
}</span>

const selectPermissionByCode = `-- name: SelectPermissionByCode :one
select id, code from permissions where code = $1
`

func (q *Queries) SelectPermissionByCode(ctx context.Context, code string) (Permission, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectPermissionByCode, code)
        var i Permission
        err := row.Scan(&amp;i.ID, &amp;i.Code)
        return i, err
}</span>

const selectUserPermissions = `-- name: SelectUserPermissions :many
SELECT p.code FROM users_permissions up
JOIN permissions p on p.id = up.permission_id
WHERE user_id = $1
`

func (q *Queries) SelectUserPermissions(ctx context.Context, userID int64) ([]string, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, selectUserPermissions, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []string{}
        for rows.Next() </span><span class="cov0" title="0">{
                var code string
                if err := rows.Scan(&amp;code); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, code)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: phrases.sql

package db

import (
        "context"
)

const insertPhrases = `-- name: InsertPhrases :one
INSERT INTO phrases (title_id)
VALUES ($1)
RETURNING id, title_id
`

func (q *Queries) InsertPhrases(ctx context.Context, titleID int64) (Phrase, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, insertPhrases, titleID)
        var i Phrase
        err := row.Scan(&amp;i.ID, &amp;i.TitleID)
        return i, err
}</span>

const selectPhraseIdsByTitleId = `-- name: SelectPhraseIdsByTitleId :many
SELECT id FROM phrases
WHERE title_id = $1
ORDER BY id
`

func (q *Queries) SelectPhraseIdsByTitleId(ctx context.Context, titleID int64) ([]int64, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, selectPhraseIdsByTitleId, titleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []int64{}
        for rows.Next() </span><span class="cov0" title="0">{
                var id int64
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, id)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const selectTranslatesWithCorrect = `-- name: SelectTranslatesWithCorrect :many
SELECT og.phrase_id, og.phrase, og.phrase_hint, new.phrase, new.phrase_hint, up.phrase_correct
FROM
    (
        SELECT phrase_id, phrase, phrase_hint
        FROM translates t
        where t.language_id = $1
    ) og
    JOIN (
        SELECT phrase, phrase_hint, phrase_id
        FROM translates t
        WHERE t.language_id = $2
    ) new
ON og.phrase_id = new.phrase_id
    JOIN (
        SELECT phrase_id, phrase_correct
        FROM users_phrases u
        WHERE u.user_id = $3 AND u.title_id = $4 AND u.language_id = $2
    ) up
ON new.phrase_id = up.phrase_id
WHERE og.phrase_id
IN
    (
      SELECT phrase_id from users_phrases
      WHERE user_id = $3 AND title_id = $4 AND language_id = $2
      ORDER BY  phrase_correct, phrase_id
      LIMIT $5
    )
`

type SelectTranslatesWithCorrectParams struct {
        LanguageID   int16 `json:"language_id"`
        LanguageID_2 int16 `json:"language_id_2"`
        UserID       int64 `json:"user_id"`
        TitleID      int64 `json:"title_id"`
        Limit        int32 `json:"limit"`
}

type SelectTranslatesWithCorrectRow struct {
        PhraseID      int64  `json:"phrase_id"`
        Phrase        string `json:"phrase"`
        PhraseHint    string `json:"phrase_hint"`
        Phrase_2      string `json:"phrase_2"`
        PhraseHint_2  string `json:"phrase_hint_2"`
        PhraseCorrect int16  `json:"phrase_correct"`
}

func (q *Queries) SelectTranslatesWithCorrect(ctx context.Context, arg SelectTranslatesWithCorrectParams) ([]SelectTranslatesWithCorrectRow, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, selectTranslatesWithCorrect,
                arg.LanguageID,
                arg.LanguageID_2,
                arg.UserID,
                arg.TitleID,
                arg.Limit,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []SelectTranslatesWithCorrectRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i SelectTranslatesWithCorrectRow
                if err := rows.Scan(
                        &amp;i.PhraseID,
                        &amp;i.Phrase,
                        &amp;i.PhraseHint,
                        &amp;i.Phrase_2,
                        &amp;i.PhraseHint_2,
                        &amp;i.PhraseCorrect,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const selectUsersPhrasesByCorrect = `-- name: SelectUsersPhrasesByCorrect :many
SELECT phrase_id from users_phrases
WHERE user_id = $1 and title_id = $2 and language_id = $3
ORDER BY  phrase_correct, phrase_id
limit $4
`

type SelectUsersPhrasesByCorrectParams struct {
        UserID     int64 `json:"user_id"`
        TitleID    int64 `json:"title_id"`
        LanguageID int16 `json:"language_id"`
        Limit      int32 `json:"limit"`
}

func (q *Queries) SelectUsersPhrasesByCorrect(ctx context.Context, arg SelectUsersPhrasesByCorrectParams) ([]int64, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, selectUsersPhrasesByCorrect,
                arg.UserID,
                arg.TitleID,
                arg.LanguageID,
                arg.Limit,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []int64{}
        for rows.Next() </span><span class="cov0" title="0">{
                var phrase_id int64
                if err := rows.Scan(&amp;phrase_id); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, phrase_id)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const selectUsersPhrasesByIds = `-- name: SelectUsersPhrasesByIds :one
SELECT user_id, title_id, phrase_id, language_id, phrase_correct from users_phrases
WHERE user_id = $1 and language_id = $2 and phrase_id = $3
`

type SelectUsersPhrasesByIdsParams struct {
        UserID     int64 `json:"user_id"`
        LanguageID int16 `json:"language_id"`
        PhraseID   int64 `json:"phrase_id"`
}

func (q *Queries) SelectUsersPhrasesByIds(ctx context.Context, arg SelectUsersPhrasesByIdsParams) (UsersPhrase, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectUsersPhrasesByIds, arg.UserID, arg.LanguageID, arg.PhraseID)
        var i UsersPhrase
        err := row.Scan(
                &amp;i.UserID,
                &amp;i.TitleID,
                &amp;i.PhraseID,
                &amp;i.LanguageID,
                &amp;i.PhraseCorrect,
        )
        return i, err
}</span>

const updateUsersPhrasesByThreeIds = `-- name: UpdateUsersPhrasesByThreeIds :one
UPDATE users_phrases
SET user_id = $1, title_id = $2, phrase_id = $3, language_id = $4, phrase_correct = $5
WHERE user_id = $1 AND phrase_id = $3 AND language_id = $4
RETURNING user_id, title_id, phrase_id, language_id, phrase_correct
`

type UpdateUsersPhrasesByThreeIdsParams struct {
        UserID        int64 `json:"user_id"`
        TitleID       int64 `json:"title_id"`
        PhraseID      int64 `json:"phrase_id"`
        LanguageID    int16 `json:"language_id"`
        PhraseCorrect int16 `json:"phrase_correct"`
}

func (q *Queries) UpdateUsersPhrasesByThreeIds(ctx context.Context, arg UpdateUsersPhrasesByThreeIdsParams) (UsersPhrase, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateUsersPhrasesByThreeIds,
                arg.UserID,
                arg.TitleID,
                arg.PhraseID,
                arg.LanguageID,
                arg.PhraseCorrect,
        )
        var i UsersPhrase
        err := row.Scan(
                &amp;i.UserID,
                &amp;i.TitleID,
                &amp;i.PhraseID,
                &amp;i.LanguageID,
                &amp;i.PhraseCorrect,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: titles.sql

package db

import (
        "context"
)

const deleteTitleById = `-- name: DeleteTitleById :exec
DELETE FROM titles WHERE  id = $1
`

func (q *Queries) DeleteTitleById(ctx context.Context, id int64) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteTitleById, id)
        return err
}</span>

const insertTitle = `-- name: InsertTitle :one
INSERT INTO titles (title, num_subs, og_language_id)
VALUES ($1, $2, $3)
RETURNING id, title, num_subs, og_language_id
`

type InsertTitleParams struct {
        Title        string `json:"title"`
        NumSubs      int16  `json:"num_subs"`
        OgLanguageID int16  `json:"og_language_id"`
}

func (q *Queries) InsertTitle(ctx context.Context, arg InsertTitleParams) (Title, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, insertTitle, arg.Title, arg.NumSubs, arg.OgLanguageID)
        var i Title
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.NumSubs,
                &amp;i.OgLanguageID,
        )
        return i, err
}</span>

const listTitles = `-- name: ListTitles :many
SELECT id, title, similarity(title, $1) AS similarity, num_subs, og_language_id
FROM titles
ORDER BY similarity desc
LIMIT $2
`

type ListTitlesParams struct {
        Similarity string `json:"similarity"`
        Limit      int32  `json:"limit"`
}

type ListTitlesRow struct {
        ID           int64   `json:"id"`
        Title        string  `json:"title"`
        Similarity   float32 `json:"similarity"`
        NumSubs      int16   `json:"num_subs"`
        OgLanguageID int16   `json:"og_language_id"`
}

func (q *Queries) ListTitles(ctx context.Context, arg ListTitlesParams) ([]ListTitlesRow, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listTitles, arg.Similarity, arg.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []ListTitlesRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i ListTitlesRow
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Similarity,
                        &amp;i.NumSubs,
                        &amp;i.OgLanguageID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listTitlesByOgLanguage = `-- name: ListTitlesByOgLanguage :many
SELECT title, similarity(title, $1) AS similarity, num_subs, og_language_id
FROM titles
WHERE og_language_id = $2
ORDER BY similarity
LIMIT $3
`

type ListTitlesByOgLanguageParams struct {
        Similarity   string `json:"similarity"`
        OgLanguageID int16  `json:"og_language_id"`
        Limit        int32  `json:"limit"`
}

type ListTitlesByOgLanguageRow struct {
        Title        string  `json:"title"`
        Similarity   float32 `json:"similarity"`
        NumSubs      int16   `json:"num_subs"`
        OgLanguageID int16   `json:"og_language_id"`
}

func (q *Queries) ListTitlesByOgLanguage(ctx context.Context, arg ListTitlesByOgLanguageParams) ([]ListTitlesByOgLanguageRow, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listTitlesByOgLanguage, arg.Similarity, arg.OgLanguageID, arg.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []ListTitlesByOgLanguageRow{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i ListTitlesByOgLanguageRow
                if err := rows.Scan(
                        &amp;i.Title,
                        &amp;i.Similarity,
                        &amp;i.NumSubs,
                        &amp;i.OgLanguageID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const selectTitleById = `-- name: SelectTitleById :one
SELECT id, title, num_subs, og_language_id FROM titles WHERE  id = $1
`

func (q *Queries) SelectTitleById(ctx context.Context, id int64) (Title, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectTitleById, id)
        var i Title
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.NumSubs,
                &amp;i.OgLanguageID,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: translates.sql

package db

import (
        "context"
)

const deleteTranslatesByLanguageId = `-- name: DeleteTranslatesByLanguageId :exec
DELETE FROM translates
WHERE language_id =$1 and phrase_id in (
    SELECT FROM phrases WHERE title_id = $2
    )
`

type DeleteTranslatesByLanguageIdParams struct {
        LanguageID int16 `json:"language_id"`
        TitleID    int64 `json:"title_id"`
}

func (q *Queries) DeleteTranslatesByLanguageId(ctx context.Context, arg DeleteTranslatesByLanguageIdParams) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteTranslatesByLanguageId, arg.LanguageID, arg.TitleID)
        return err
}</span>

const insertTranslates = `-- name: InsertTranslates :one
INSERT INTO translates (phrase_id, language_id, phrase, phrase_hint)
VALUES ($1, $2, $3, $4)
RETURNING phrase_id, language_id, phrase, phrase_hint
`

type InsertTranslatesParams struct {
        PhraseID   int64  `json:"phrase_id"`
        LanguageID int16  `json:"language_id"`
        Phrase     string `json:"phrase"`
        PhraseHint string `json:"phrase_hint"`
}

func (q *Queries) InsertTranslates(ctx context.Context, arg InsertTranslatesParams) (Translate, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, insertTranslates,
                arg.PhraseID,
                arg.LanguageID,
                arg.Phrase,
                arg.PhraseHint,
        )
        var i Translate
        err := row.Scan(
                &amp;i.PhraseID,
                &amp;i.LanguageID,
                &amp;i.Phrase,
                &amp;i.PhraseHint,
        )
        return i, err
}</span>

const selectExistsTranslates = `-- name: SelectExistsTranslates :one
SELECT EXISTS(
    SELECT 1 FROM titles t
      JOIN phrases p ON t.id = p.title_id
      JOIN translates tr ON p.id = tr.phrase_id AND tr.language_id = $1
    WHERE tr.language_id = $1 and t.id = $2 ) AS "exists"
`

type SelectExistsTranslatesParams struct {
        LanguageID int16 `json:"language_id"`
        ID         int64 `json:"id"`
}

func (q *Queries) SelectExistsTranslates(ctx context.Context, arg SelectExistsTranslatesParams) (bool, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectExistsTranslates, arg.LanguageID, arg.ID)
        var exists bool
        err := row.Scan(&amp;exists)
        return exists, err
}</span>

const selectTranslatesByTitleIdLangId = `-- name: SelectTranslatesByTitleIdLangId :many
SELECT tr.phrase_id, tr.language_id, tr.phrase, tr.phrase_hint FROM titles t
    JOIN phrases p ON t.id = p.title_id
    JOIN translates tr ON p.id = tr.phrase_id AND tr.language_id = $1
WHERE tr.language_id = $1 and t.id = $2
`

type SelectTranslatesByTitleIdLangIdParams struct {
        LanguageID int16 `json:"language_id"`
        ID         int64 `json:"id"`
}

func (q *Queries) SelectTranslatesByTitleIdLangId(ctx context.Context, arg SelectTranslatesByTitleIdLangIdParams) ([]Translate, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, selectTranslatesByTitleIdLangId, arg.LanguageID, arg.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Translate{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Translate
                if err := rows.Scan(
                        &amp;i.PhraseID,
                        &amp;i.LanguageID,
                        &amp;i.Phrase,
                        &amp;i.PhraseHint,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package db

import (
        "context"
)

const deleteUserById = `-- name: DeleteUserById :exec
DELETE FROM users WHERE  id = $1
`

func (q *Queries) DeleteUserById(ctx context.Context, id int64) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteUserById, id)
        return err
}</span>

const insertUser = `-- name: InsertUser :one
INSERT INTO users (name, email, hashed_password, title_id, og_language_id, new_language_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, title_id, name, email, hashed_password, og_language_id, new_language_id, created
`

type InsertUserParams struct {
        Name           string `json:"name"`
        Email          string `json:"email"`
        HashedPassword string `json:"hashed_password"`
        TitleID        int64  `json:"title_id"`
        OgLanguageID   int16  `json:"og_language_id"`
        NewLanguageID  int16  `json:"new_language_id"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, insertUser,
                arg.Name,
                arg.Email,
                arg.HashedPassword,
                arg.TitleID,
                arg.OgLanguageID,
                arg.NewLanguageID,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.TitleID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.HashedPassword,
                &amp;i.OgLanguageID,
                &amp;i.NewLanguageID,
                &amp;i.Created,
        )
        return i, err
}</span>

const selectUserById = `-- name: SelectUserById :one
SELECT id, title_id, name, email, hashed_password, og_language_id, new_language_id, created FROM users WHERE  id = $1
`

func (q *Queries) SelectUserById(ctx context.Context, id int64) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectUserById, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.TitleID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.HashedPassword,
                &amp;i.OgLanguageID,
                &amp;i.NewLanguageID,
                &amp;i.Created,
        )
        return i, err
}</span>

const selectUserByName = `-- name: SelectUserByName :one
SELECT id, title_id, name, email, hashed_password, og_language_id, new_language_id, created FROM users WHERE  name = $1
`

func (q *Queries) SelectUserByName(ctx context.Context, name string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectUserByName, name)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.TitleID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.HashedPassword,
                &amp;i.OgLanguageID,
                &amp;i.NewLanguageID,
                &amp;i.Created,
        )
        return i, err
}</span>

const updateUserById = `-- name: UpdateUserById :one
UPDATE users
SET title_id = $1, email = $2, og_language_id = $3, new_language_id = $4, hashed_password = $5
WHERE id = $6
RETURNING id, title_id, name, email, hashed_password, og_language_id, new_language_id, created
`

type UpdateUserByIdParams struct {
        TitleID        int64  `json:"title_id"`
        Email          string `json:"email"`
        OgLanguageID   int16  `json:"og_language_id"`
        NewLanguageID  int16  `json:"new_language_id"`
        HashedPassword string `json:"hashed_password"`
        ID             int64  `json:"id"`
}

func (q *Queries) UpdateUserById(ctx context.Context, arg UpdateUserByIdParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateUserById,
                arg.TitleID,
                arg.Email,
                arg.OgLanguageID,
                arg.NewLanguageID,
                arg.HashedPassword,
                arg.ID,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.TitleID,
                &amp;i.Name,
                &amp;i.Email,
                &amp;i.HashedPassword,
                &amp;i.OgLanguageID,
                &amp;i.NewLanguageID,
                &amp;i.Created,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: voices.sql

package db

import (
        "context"

        "github.com/lib/pq"
)

const listVoices = `-- name: ListVoices :many
SELECT id, language_id, language_codes, ssml_gender, name, natural_sample_rate_hertz FROM voices
`

func (q *Queries) ListVoices(ctx context.Context) ([]Voice, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listVoices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Voice{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Voice
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.LanguageID,
                        pq.Array(&amp;i.LanguageCodes),
                        &amp;i.SsmlGender,
                        &amp;i.Name,
                        &amp;i.NaturalSampleRateHertz,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const selectVoiceById = `-- name: SelectVoiceById :one
SELECT id, language_id, language_codes, ssml_gender, name, natural_sample_rate_hertz FROM voices WHERE id = $1
`

func (q *Queries) SelectVoiceById(ctx context.Context, id int16) (Voice, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, selectVoiceById, id)
        var i Voice
        err := row.Scan(
                &amp;i.ID,
                &amp;i.LanguageID,
                pq.Array(&amp;i.LanguageCodes),
                &amp;i.SsmlGender,
                &amp;i.Name,
                &amp;i.NaturalSampleRateHertz,
        )
        return i, err
}</span>

const selectVoicesByLanguageId = `-- name: SelectVoicesByLanguageId :many
SELECT id, language_id, language_codes, ssml_gender, name, natural_sample_rate_hertz FROM voices WHERE language_id = $1
`

func (q *Queries) SelectVoicesByLanguageId(ctx context.Context, languageID int16) ([]Voice, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, selectVoicesByLanguageId, languageID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Voice{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Voice
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.LanguageID,
                        pq.Array(&amp;i.LanguageCodes),
                        &amp;i.SsmlGender,
                        &amp;i.Name,
                        &amp;i.NaturalSampleRateHertz,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package audiofile

import (
        "archive/zip"
        "bufio"
        "errors"
        "fmt"
        "github.com/labstack/echo/v4"
        "io"
        "iter"
        "mime/multipart"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "slices"
        "strings"
        db "talkliketv.click/tltv/db/sqlc"
        audio "talkliketv.click/tltv/internal/audio/pattern"
        "talkliketv.click/tltv/internal/util"
        "unicode"
)

// AudioPauseFilePath is a map to the silence mp3's of the embedded FS in
// internal/audio/silence/efs.go and after application startup will be stored
// at config.TTSBasePath
var AudioPauseFilePath = map[int]string{
        3:  "silence/3SecSilence.mp3",
        4:  "silence/4SecSilence.mp3",
        5:  "silence/5SecSilence.mp3",
        6:  "silence/6SecSilence.mp3",
        7:  "silence/7SecSilence.mp3",
        8:  "silence/8SecSilence.mp3",
        9:  "silence/9SecSilence.mp3",
        10: "silence/10SecSilence.mp3",
}

// endSentenceMap is a map to find the ending punctuation of a sentence
var (
        endSentenceMap = map[rune]bool{
                '!': true,
                '.': true,
                '?': true,
        }
        // Use a regular expression to match punctuation characters
        punctuationRe = regexp.MustCompile(`[.,!?;:'"]`)
)

const (
        minimumPhraseLength = 4
        maximumPhraseLength = 10
)

type AudioFileX interface {
        GetLines(echo.Context, multipart.File) ([]string, error)
        CreateMp3Zip(echo.Context, db.Title, string) (*os.File, error)
        BuildAudioInputFiles(echo.Context, []int64, db.Title, string, string, string, string) error
        CreatePhrasesZip(echo.Context, iter.Seq[[]string], string, string) (*os.File, error)
}

type AudioFile struct {
        cmdX cmdRunnerX
}

// cmdRunnerX creates an interface to allow for unit testing without having ffmpeg installed
type cmdRunnerX interface {
        CombinedOutput(cmd *exec.Cmd) ([]byte, error)
}

func New(cmdX cmdRunnerX) *AudioFile <span class="cov8" title="1">{
        return &amp;AudioFile{cmdX: cmdX}
}</span>

type RealCmdRunner struct{}

// CombinedOutput is a wrapper function for cmd.CombinedOutput() so this function
// can be interfaced for testing (ffmpeg will not have to be installed on machine
// for unit testing)
func (r *RealCmdRunner) CombinedOutput(cmd *exec.Cmd) ([]byte, error) <span class="cov0" title="0">{
        return cmd.CombinedOutput()
}</span>

// GetLines determines if the uploaded file is an srt, in paragraph form, or one phrase per
// line and then parses the file accordingly, returning a string slice containing the
// phrases to be translated
func (a *AudioFile) GetLines(e echo.Context, f multipart.File) ([]string, error) <span class="cov8" title="1">{

        // get file type, options are srt, single line text or paragraph
        fileType := ""
        scanner := bufio.NewScanner(f)
        //start at the first line again
        _, err := f.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">count := 0
        var line string

        // verify if file is srt
        for scanner.Scan() </span><span class="cov8" title="1">{
                if fileType != "" || count &gt; 5 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">line = scanner.Text()
                // if line contains "&gt;" and doesn't contain any letters it is srt file
                if strings.Contains(line, "&gt;") </span><span class="cov8" title="1">{
                        if strings.Contains(line, "&lt;font") </span><span class="cov0" title="0">{
                                fileType = "srt"
                        }</span> else<span class="cov8" title="1"> {
                                containsAlpha, err := regexp.MatchString("[a-zA-Z]", line)
                                if err != nil </span><span class="cov0" title="0">{
                                        e.Logger().Error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if !containsAlpha </span><span class="cov8" title="1">{
                                        fileType = "srt"
                                }</span>
                        }
                }
                <span class="cov8" title="1">count++</span>
        }
        //start at the first line again
        <span class="cov8" title="1">_, err = f.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">count = 0
        scanner = bufio.NewScanner(f)
        // verify if file is in paragraph form
        for scanner.Scan() </span><span class="cov8" title="1">{
                if fileType != "" || count &gt; 4 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">line = scanner.Text()
                // Split on punctuation characters
                re := regexp.MustCompile(`[.!?]`)
                result := re.Split(line, -1)
                if len(result) &gt; 3 </span><span class="cov8" title="1">{
                        fileType = "paragraph"
                }</span>
                <span class="cov8" title="1">count++</span>
        }
        // TODO somehow verify single phrase per line form (these can be multiple sentences per line)
        <span class="cov8" title="1">_, err = f.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">var stringsSlice []string
        if fileType == "srt" </span><span class="cov8" title="1">{
                stringsSlice = parseSrt(f)
        }</span>
        <span class="cov8" title="1">if fileType == "paragraph" </span><span class="cov8" title="1">{
                stringsSlice = parseParagraph(f)
        }</span>
        <span class="cov8" title="1">if fileType == "" </span><span class="cov8" title="1">{
                stringsSlice = parseSingle(f)
        }</span>
        <span class="cov8" title="1">if len(stringsSlice) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("unable to parse file")
        }</span>

        <span class="cov8" title="1">return stringsSlice, nil</span>
}

// parseSrt takes a srt multipart file and parses it into a slice of strings
func parseSrt(f multipart.File) []string <span class="cov8" title="1">{
        var stringsSlice []string
        scanner := bufio.NewScanner(f)
        scanner.Scan()
        var line string
        for scanner.Scan() </span><span class="cov8" title="1">{
                line = strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if line[0] &gt;= '0' &amp;&amp; line[0] &lt;= '9' </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if line[0] == '[' &amp;&amp; line[len(line)-1] == ']' </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if strings.Contains(line, "&lt;font") || strings.Contains(line, "font&gt;") </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        // if the next line following subtitle is not new line it is more dialogue so combine it
                        scanner.Scan()
                        nextLine := scanner.Text()
                        if nextLine != "" </span><span class="cov8" title="1">{
                                line = strings.ReplaceAll(line, "\n", "")
                                line = line + " " + nextLine
                                line = replaceFmt(line)
                        }</span> else<span class="cov0" title="0"> {
                                line = replaceFmt(line)
                        }</span>
                }

                <span class="cov8" title="1">phrases := splitBigPhrases(line)
                for _, phrase := range phrases </span><span class="cov8" title="1">{
                        stringsSlice = append(stringsSlice, phrase)
                }</span>
        }

        <span class="cov8" title="1">return stringsSlice</span>
}

func splitBigPhrases(line string) []string <span class="cov8" title="1">{

        var splitString []string

        words := strings.Fields(line)
        // if phrase is too short don't keep it
        if len(words) &lt;= minimumPhraseLength </span><span class="cov8" title="1">{
                return []string{}
        }</span> else<span class="cov8" title="1"> if len(words) &lt; maximumPhraseLength </span><span class="cov8" title="1">{
                // if phrase isn't too long don't split it
                return []string{line}
        }</span> else<span class="cov8" title="1"> {
                // split into an array of strings along punctuation
                last := 0
                for i, word := range words </span><span class="cov8" title="1">{
                        if unicode.IsPunct(rune(word[len(word)-1])) </span><span class="cov8" title="1">{
                                nextString := ""
                                for j := last; j &lt;= i; j++ </span><span class="cov8" title="1">{
                                        nextString = nextString + words[j] + " "
                                }</span>
                                <span class="cov8" title="1">splitString = append(splitString, nextString)
                                last = i + 1</span>
                        }
                }
                // if last word does not end in punctuation add that string
                <span class="cov8" title="1">if last &lt; len(words) </span><span class="cov8" title="1">{
                        splitString = append(splitString, strings.Join(words[last:len(words)], " "))
                }</span>
                // if long phrase has punctuation split on punctuation
                <span class="cov8" title="1">if len(splitString) &gt; 1 </span><span class="cov8" title="1">{
                        // combine any strings that are less than the minimumPhraseLength with the string after it
                        i := 0
                        for i &lt; len(splitString)-1 </span><span class="cov8" title="1">{
                                // if phrase is small combine it with the next one
                                wordsInString := strings.Fields(splitString[i])
                                if len(wordsInString) &lt; minimumPhraseLength </span><span class="cov8" title="1">{
                                        splitString[i] = splitString[i] + " " + splitString[i+1]
                                        // remove the next index of split string
                                        splitString = append(splitString[:i+1], splitString[i+2:]...)
                                }</span> else<span class="cov8" title="1"> {
                                        // if both combined are less than maximum than concat
                                        next := splitString[i] + " " + splitString[i+1]
                                        nextWordCount := strings.Fields(next)
                                        if len(nextWordCount) &lt;= maximumPhraseLength </span><span class="cov8" title="1">{
                                                splitString[i] = next
                                                splitString = append(splitString[:i+1], splitString[i+2:]...)
                                        }</span>
                                }
                                // else continue
                                <span class="cov8" title="1">i++</span>
                        }

                        // now check the last index and pen ultimate of the split string and combine if shorter than minimumPhraseLength
                        <span class="cov8" title="1">if len(splitString) &gt; 1 </span><span class="cov8" title="1">{
                                lastElem := len(splitString) - 1
                                lastElemCount := len(strings.Fields(splitString[lastElem]))
                                penUltimateElemCount := len(strings.Fields(splitString[lastElem-1]))
                                if lastElemCount &lt; minimumPhraseLength || penUltimateElemCount &lt; minimumPhraseLength </span><span class="cov8" title="1">{
                                        lastString := splitString[lastElem-1] + " " + splitString[lastElem]
                                        splitString[lastElem] = lastString
                                        splitString = splitString[:lastElem-1]
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        return []string{line}
                }</span>
        }

        <span class="cov8" title="1">for i := range splitString </span><span class="cov8" title="1">{
                splitString[i] = strings.ReplaceAll(splitString[i], "  ", " ")
                splitString[i] = strings.TrimSpace(splitString[i])
        }</span>
        <span class="cov8" title="1">return splitString</span>
}

// parseParagraph takes a txt multipart file in paragraph form and returns a slice of strings
func parseParagraph(f multipart.File) []string <span class="cov8" title="1">{
        var stringsSlice []string
        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                // Split on punctuation characters
                last := 0
                for i, c := range line </span><span class="cov8" title="1">{
                        if i == len(line)-1 </span><span class="cov8" title="1">{
                                sentence := strings.TrimSpace(line[last : i+1])
                                last = i + 1
                                words := strings.Fields(sentence)
                                if len(words) &gt; 3 </span><span class="cov8" title="1">{
                                        stringsSlice = append(stringsSlice, line)
                                }</span>
                        } else<span class="cov8" title="1"> if endSentenceMap[c] </span><span class="cov8" title="1">{
                                sentence := strings.TrimSpace(line[last : i+1])
                                last = i + 1
                                phrases := splitBigPhrases(sentence)
                                for _, phrase := range phrases </span><span class="cov8" title="1">{
                                        stringsSlice = append(stringsSlice, phrase)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return stringsSlice</span>
}

// parseSingle takes a txt multipart file with one phrase per line and parses it
// into a slice of strings
func parseSingle(f multipart.File) []string <span class="cov8" title="1">{
        var stringsSlice []string
        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                phrases := splitBigPhrases(line)
                for _, phrase := range phrases </span><span class="cov8" title="1">{
                        stringsSlice = append(stringsSlice, phrase)
                }</span>
        }

        <span class="cov8" title="1">return stringsSlice</span>
}

// replaceFmt is a helper function for parseSrt that replaces characters that are not part
// of the phrase like descriptions or tags
func replaceFmt(line string) string <span class="cov8" title="1">{
        // remove any characters between brackets and brackets [...] or {...} or &lt;...&gt;
        re := regexp.MustCompile("\\[.*?]")
        line = re.ReplaceAllString(line, "")
        re = regexp.MustCompile("\\{.*?}")
        line = re.ReplaceAllString(line, "")
        re = regexp.MustCompile("&lt;.*?&gt;")
        line = re.ReplaceAllString(line, "")
        line = strings.ReplaceAll(line, "-", "")
        line = strings.ReplaceAll(line, "\"", "")
        line = strings.ReplaceAll(line, "'", "")
        line = strings.ReplaceAll(line, "", "")
        line = strings.TrimSpace(line)

        return line
}</span>

// CreateMp3Zip takes the input txt files created with BuildAudioInputFiles and uses ffmpeg
// to build an output mp3's file and the zips them into a single file to be returned to the
// requester
func (a *AudioFile) CreateMp3Zip(e echo.Context, t db.Title, tmpDir string) (*os.File, error) <span class="cov8" title="1">{
        // get a list of files from the temp directory
        files, err := os.ReadDir(tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(files) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("no files found in CreateMp3Zip")
        }</span>
        // create outputs folder to hold all the mp3's to zip
        <span class="cov8" title="1">outDirPath := tmpDir + "outputs"
        err = os.MkdirAll(outDirPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">for i, f := range files </span><span class="cov8" title="1">{
                // ffmpeg -f concat -safe 0 -i ffmpeg_input.txt -c copy output.mp3
                outputString := fmt.Sprintf("%s/%s-%d.mp3", outDirPath, t.Title, i)
                cmd := exec.Command("ffmpeg", "-f", "concat", "-safe", "0", "-i", tmpDir+f.Name(), "-c", "copy", outputString)

                //Execute the command and get the output
                output, err := a.cmdX.CombinedOutput(cmd)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        e.Logger().Error("combined output: " + string(output))
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return createZipFile(e, tmpDir, t.Title, outDirPath)</span>
}

// addFileToZip is a helper function for CreateMp3Zip that adds each file to
// the zip.Writer
func addFileToZip(e echo.Context, zipWriter *zip.Writer, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        <span class="cov8" title="1">header, err := zip.FileInfoHeader(fInfo)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        <span class="cov8" title="1">header.Name = filepath.Base(filename)
        header.Method = zip.Deflate

        writer, err := zipWriter.CreateHeader(header)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = io.Copy(writer, file)
        e.Logger().Info("wrote file: %s", file.Name())
        return err</span>
}

// BuildAudioInputFiles creates a file with the filepaths of the mp3's used to construct
// the output files with ffmpeg in CreateMp3Zip
func (a *AudioFile) BuildAudioInputFiles(e echo.Context, ids []int64, t db.Title, pause, from, to, tmpDir string) error <span class="cov8" title="1">{

        // map phrase ids to zero through len(phrase ids) to map correctly to pattern.Pattern
        pMap := make(map[int]int64)
        for i, pid := range ids </span><span class="cov8" title="1">{
                pMap[i] = pid
        }</span>
        // maxP is the highest phrase id and determines the last block of mp3's that will be built
        <span class="cov8" title="1">maxP := slices.Max(ids)

        // get the pattern represented as an int from the context
        value, ok := e.Get("pattern").(int)
        if !ok </span><span class="cov0" title="0">{
                return util.ErrIntConversion
        }</span>
        <span class="cov8" title="1">pattern := audio.GetPattern(value)
        if pattern == nil </span><span class="cov0" title="0">{
                return errors.New("no pattern")
        }</span>
        // create chunks of []Audio pattern to split up audio files into ~15 minute lengths
        <span class="cov8" title="1">chunkedSlice := slices.Chunk(pattern, 125)
        count := 1
        last := false
        for chunk := range chunkedSlice </span><span class="cov8" title="1">{
                inputString := fmt.Sprintf("%s-input-%d", t.Title, count)
                count++
                f, err := os.Create(tmpDir + inputString)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">defer f.Close()

                for _, audioStruct := range chunk </span><span class="cov8" title="1">{
                        // if: we have reached the highest phrase id then this will be the last audio block
                        // else if: skip if phraseId does not exist (is greater than maxP)
                        // else if: native language then we add filepath for from audio mp3
                        // else: add audio filepath for language you want to learn
                        phraseId := pMap[audioStruct.Id]
                        if phraseId == maxP </span><span class="cov8" title="1">{
                                last = true
                        }</span>
                        <span class="cov8" title="1">if phraseId == 0 &amp;&amp; audioStruct.Id &gt; 0 </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> if audioStruct.Native == true </span><span class="cov8" title="1">{
                                _, err = f.WriteString(fmt.Sprintf("file '%s%d'\n", from, phraseId))
                                _, err = f.WriteString(fmt.Sprintf("file '%s'\n", pause))
                                if err != nil </span><span class="cov0" title="0">{
                                        e.Logger().Error(err)
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                _, err = f.WriteString(fmt.Sprintf("file '%s%d'\n", to, phraseId))
                                _, err = f.WriteString(fmt.Sprintf("file '%s'\n", pause))
                                if err != nil </span><span class="cov0" title="0">{
                                        e.Logger().Error(err)
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">if last </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// CreatePhrasesZip creates a zipped file of txt files from the file the user uploaded if it contains
// more phrases than the limit of config.MaxNumPhrases. It takes a iter.Seq of strings and outputs them
// to files, each chunk containing config.MaxNumPhrases and than zips them up. Sending them back to the
// user
func (a *AudioFile) CreatePhrasesZip(e echo.Context, chunkedPhrases iter.Seq[[]string], tmpPath, filename string) (*os.File, error) <span class="cov8" title="1">{

        // create outputs folder to hold all the txt files to zip
        err := os.MkdirAll(tmpPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">count := 0
        for chunk := range chunkedPhrases </span><span class="cov8" title="1">{
                file := fmt.Sprintf("%s-phrases-%d.txt", filename, count)
                count++
                f, err := os.Create(tmpPath + file)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer f.Close()

                for _, phrase := range chunk </span><span class="cov8" title="1">{
                        _, err = f.WriteString(phrase + "\n")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

        }

        <span class="cov8" title="1">return createZipFile(e, tmpPath, filename, tmpPath)</span>
}

// createZipFile takes a tmpDir which is the directory containing the files you want to zip.
// filename which is the name that you want the zipped files to have as their base name
// and outDirPath which is where the zip file will be stored and zips up the files
func createZipFile(e echo.Context, tmpDir, filename, outDirPath string) (*os.File, error) <span class="cov8" title="1">{
        // TODO add txt file of the phrases
        zipFile, err := os.Create(tmpDir + "/" + filename + ".zip")
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer zipFile.Close()

        zipWriter := zip.NewWriter(zipFile)
        defer zipWriter.Close()

        // get a list of files from the output directory
        files, err := os.ReadDir(outDirPath)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if !strings.HasSuffix(file.Name(), ".zip") </span><span class="cov8" title="1">{
                        err = addFileToZip(e, zipWriter, outDirPath+"/"+file.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return zipFile, err</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package audio

// Audio struct stores the phrase id's and whether the phrase should be
// native (from language) or not native (to language)
type Audio struct {
        Id     int
        Native bool
}

func GetPattern(i int) []Audio <span class="cov8" title="1">{
        switch i </span>{
        case 1:<span class="cov8" title="1">
                return Standard</span>
        case 2:<span class="cov0" title="0">
                return Advanced</span>
        case 3:<span class="cov0" title="0">
                return Review</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Standard is the pattern used to build the mp3 audio files.
// The program used to generate it is at https://github.com/dsaker/audio-pattern-builder/blob/main/main.go
// The pattern stored here can build audio for up to 200 phrases.
// Frequency of repetition can be adjusted in the program
// This pattern is set with multi := 8 (multiplier equal to 8)
var Standard = []Audio{{0, true}, {0, false}, {0, false}, {1, true}, {1, false}, {1, false}, {2, true}, {2, false}, {2, false}, {3, true}, {3, false}, {3, false}, {0, true}, {0, false}, {4, true}, {4, false}, {4, false}, {1, true}, {1, false}, {5, true}, {5, false}, {5, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {6, true}, {6, false}, {6, false}, {5, true}, {5, false}, {7, true}, {7, false}, {7, false}, {8, true}, {8, false}, {8, false}, {6, true}, {6, false}, {9, true}, {9, false}, {9, false}, {7, true}, {7, false}, {8, true}, {8, false}, {10, true}, {10, false}, {10, false}, {0, true}, {0, false}, {9, true}, {9, false}, {1, true}, {1, false}, {11, true}, {11, false}, {11, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {10, true}, {10, false}, {5, true}, {5, false}, {11, true}, {11, false}, {12, true}, {12, false}, {12, false}, {6, true}, {6, false}, {13, true}, {13, false}, {13, false}, {7, true}, {7, false}, {8, true}, {8, false}, {12, true}, {12, false}, {14, true}, {14, false}, {14, false}, {13, true}, {13, false}, {9, true}, {9, false}, {15, true}, {15, false}, {15, false}, {14, true}, {14, false}, {16, true}, {16, false}, {16, false}, {10, true}, {10, false}, {15, true}, {15, false}, {11, true}, {11, false}, {17, true}, {17, false}, {17, false}, {16, true}, {16, false}, {18, true}, {18, false}, {18, false}, {19, true}, {19, false}, {19, false}, {17, true}, {17, false}, {20, true}, {20, false}, {20, false}, {12, true}, {12, false}, {13, true}, {13, false}, {18, true}, {18, false}, {19, true}, {19, false}, {20, true}, {20, false}, {14, true}, {14, false}, {0, true}, {0, false}, {21, true}, {21, false}, {21, false}, {1, true}, {1, false}, {15, true}, {15, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {16, true}, {16, false}, {5, true}, {5, false}, {17, true}, {17, false}, {21, true}, {21, false}, {22, true}, {22, false}, {22, false}, {6, true}, {6, false}, {23, true}, {23, false}, {23, false}, {18, true}, {18, false}, {7, true}, {7, false}, {8, true}, {8, false}, {19, true}, {19, false}, {20, true}, {20, false}, {9, true}, {9, false}, {22, true}, {22, false}, {23, true}, {23, false}, {24, true}, {24, false}, {24, false}, {25, true}, {25, false}, {25, false}, {10, true}, {10, false}, {26, true}, {26, false}, {26, false}, {11, true}, {11, false}, {21, true}, {21, false}, {24, true}, {24, false}, {25, true}, {25, false}, {26, true}, {26, false}, {27, true}, {27, false}, {27, false}, {28, true}, {28, false}, {28, false}, {12, true}, {12, false}, {13, true}, {13, false}, {29, true}, {29, false}, {29, false}, {22, true}, {22, false}, {23, true}, {23, false}, {14, true}, {14, false}, {27, true}, {27, false}, {28, true}, {28, false}, {15, true}, {15, false}, {29, true}, {29, false}, {30, true}, {30, false}, {30, false}, {24, true}, {24, false}, {16, true}, {16, false}, {25, true}, {25, false}, {17, true}, {17, false}, {26, true}, {26, false}, {30, true}, {30, false}, {31, true}, {31, false}, {31, false}, {18, true}, {18, false}, {32, true}, {32, false}, {32, false}, {33, true}, {33, false}, {33, false}, {19, true}, {19, false}, {20, true}, {20, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {31, true}, {31, false}, {32, true}, {32, false}, {33, true}, {33, false}, {34, true}, {34, false}, {34, false}, {35, true}, {35, false}, {35, false}, {21, true}, {21, false}, {30, true}, {30, false}, {36, true}, {36, false}, {36, false}, {34, true}, {34, false}, {0, true}, {0, false}, {35, true}, {35, false}, {1, true}, {1, false}, {36, true}, {36, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {22, true}, {22, false}, {5, true}, {5, false}, {23, true}, {23, false}, {31, true}, {31, false}, {32, true}, {32, false}, {6, true}, {6, false}, {33, true}, {33, false}, {24, true}, {24, false}, {7, true}, {7, false}, {8, true}, {8, false}, {25, true}, {25, false}, {26, true}, {26, false}, {9, true}, {9, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {37, true}, {37, false}, {37, false}, {10, true}, {10, false}, {38, true}, {38, false}, {38, false}, {11, true}, {11, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {37, true}, {37, false}, {38, true}, {38, false}, {39, true}, {39, false}, {39, false}, {12, true}, {12, false}, {13, true}, {13, false}, {30, true}, {30, false}, {40, true}, {40, false}, {40, false}, {39, true}, {39, false}, {14, true}, {14, false}, {41, true}, {41, false}, {41, false}, {40, true}, {40, false}, {15, true}, {15, false}, {42, true}, {42, false}, {42, false}, {41, true}, {41, false}, {16, true}, {16, false}, {43, true}, {43, false}, {43, false}, {17, true}, {17, false}, {31, true}, {31, false}, {32, true}, {32, false}, {33, true}, {33, false}, {18, true}, {18, false}, {37, true}, {37, false}, {38, true}, {38, false}, {19, true}, {19, false}, {20, true}, {20, false}, {39, true}, {39, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {40, true}, {40, false}, {41, true}, {41, false}, {42, true}, {42, false}, {43, true}, {43, false}, {21, true}, {21, false}, {44, true}, {44, false}, {44, false}, {45, true}, {45, false}, {45, false}, {46, true}, {46, false}, {46, false}, {47, true}, {47, false}, {47, false}, {44, true}, {44, false}, {48, true}, {48, false}, {48, false}, {45, true}, {45, false}, {49, true}, {49, false}, {49, false}, {22, true}, {22, false}, {46, true}, {46, false}, {23, true}, {23, false}, {47, true}, {47, false}, {48, true}, {48, false}, {42, true}, {42, false}, {24, true}, {24, false}, {43, true}, {43, false}, {49, true}, {49, false}, {25, true}, {25, false}, {26, true}, {26, false}, {50, true}, {50, false}, {50, false}, {51, true}, {51, false}, {51, false}, {44, true}, {44, false}, {52, true}, {52, false}, {52, false}, {45, true}, {45, false}, {37, true}, {37, false}, {38, true}, {38, false}, {46, true}, {46, false}, {50, true}, {50, false}, {47, true}, {47, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {39, true}, {39, false}, {40, true}, {40, false}, {41, true}, {41, false}, {48, true}, {48, false}, {49, true}, {49, false}, {30, true}, {30, false}, {51, true}, {51, false}, {52, true}, {52, false}, {53, true}, {53, false}, {53, false}, {0, true}, {0, false}, {54, true}, {54, false}, {54, false}, {1, true}, {1, false}, {50, true}, {50, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {53, true}, {53, false}, {5, true}, {5, false}, {54, true}, {54, false}, {31, true}, {31, false}, {32, true}, {32, false}, {6, true}, {6, false}, {33, true}, {33, false}, {42, true}, {42, false}, {7, true}, {7, false}, {8, true}, {8, false}, {43, true}, {43, false}, {51, true}, {51, false}, {9, true}, {9, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {44, true}, {44, false}, {10, true}, {10, false}, {45, true}, {45, false}, {11, true}, {11, false}, {46, true}, {46, false}, {47, true}, {47, false}, {52, true}, {52, false}, {53, true}, {53, false}, {54, true}, {54, false}, {48, true}, {48, false}, {12, true}, {12, false}, {13, true}, {13, false}, {49, true}, {49, false}, {55, true}, {55, false}, {55, false}, {14, true}, {14, false}, {56, true}, {56, false}, {56, false}, {50, true}, {50, false}, {15, true}, {15, false}, {55, true}, {55, false}, {57, true}, {57, false}, {57, false}, {56, true}, {56, false}, {16, true}, {16, false}, {58, true}, {58, false}, {58, false}, {17, true}, {17, false}, {57, true}, {57, false}, {59, true}, {59, false}, {59, false}, {58, true}, {58, false}, {18, true}, {18, false}, {37, true}, {37, false}, {38, true}, {38, false}, {19, true}, {19, false}, {20, true}, {20, false}, {51, true}, {51, false}, {59, true}, {59, false}, {60, true}, {60, false}, {60, false}, {39, true}, {39, false}, {40, true}, {40, false}, {41, true}, {41, false}, {55, true}, {55, false}, {56, true}, {56, false}, {60, true}, {60, false}, {21, true}, {21, false}, {57, true}, {57, false}, {52, true}, {52, false}, {53, true}, {53, false}, {54, true}, {54, false}, {58, true}, {58, false}, {61, true}, {61, false}, {61, false}, {62, true}, {62, false}, {62, false}, {22, true}, {22, false}, {59, true}, {59, false}, {23, true}, {23, false}, {61, true}, {61, false}, {62, true}, {62, false}, {63, true}, {63, false}, {63, false}, {24, true}, {24, false}, {42, true}, {42, false}, {60, true}, {60, false}, {25, true}, {25, false}, {26, true}, {26, false}, {43, true}, {43, false}, {63, true}, {63, false}, {64, true}, {64, false}, {64, false}, {65, true}, {65, false}, {65, false}, {44, true}, {44, false}, {66, true}, {66, false}, {66, false}, {45, true}, {45, false}, {64, true}, {64, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {46, true}, {46, false}, {47, true}, {47, false}, {48, true}, {48, false}, {55, true}, {55, false}, {56, true}, {56, false}, {30, true}, {30, false}, {49, true}, {49, false}, {57, true}, {57, false}, {61, true}, {61, false}, {62, true}, {62, false}, {50, true}, {50, false}, {58, true}, {58, false}, {63, true}, {63, false}, {64, true}, {64, false}, {65, true}, {65, false}, {66, true}, {66, false}, {59, true}, {59, false}, {67, true}, {67, false}, {67, false}, {31, true}, {31, false}, {32, true}, {32, false}, {68, true}, {68, false}, {68, false}, {33, true}, {33, false}, {67, true}, {67, false}, {69, true}, {69, false}, {69, false}, {60, true}, {60, false}, {68, true}, {68, false}, {70, true}, {70, false}, {70, false}, {51, true}, {51, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {69, true}, {69, false}, {65, true}, {65, false}, {66, true}, {66, false}, {70, true}, {70, false}, {71, true}, {71, false}, {71, false}, {72, true}, {72, false}, {72, false}, {52, true}, {52, false}, {53, true}, {53, false}, {54, true}, {54, false}, {67, true}, {67, false}, {68, true}, {68, false}, {71, true}, {71, false}, {72, true}, {72, false}, {73, true}, {73, false}, {73, false}, {74, true}, {74, false}, {74, false}, {61, true}, {61, false}, {62, true}, {62, false}, {69, true}, {69, false}, {73, true}, {73, false}, {63, true}, {63, false}, {64, true}, {64, false}, {70, true}, {70, false}, {74, true}, {74, false}, {75, true}, {75, false}, {75, false}, {0, true}, {0, false}, {76, true}, {76, false}, {76, false}, {1, true}, {1, false}, {77, true}, {77, false}, {77, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {37, true}, {37, false}, {5, true}, {5, false}, {38, true}, {38, false}, {71, true}, {71, false}, {72, true}, {72, false}, {6, true}, {6, false}, {39, true}, {39, false}, {40, true}, {40, false}, {7, true}, {7, false}, {8, true}, {8, false}, {41, true}, {41, false}, {55, true}, {55, false}, {9, true}, {9, false}, {56, true}, {56, false}, {57, true}, {57, false}, {65, true}, {65, false}, {66, true}, {66, false}, {58, true}, {58, false}, {10, true}, {10, false}, {67, true}, {67, false}, {11, true}, {11, false}, {68, true}, {68, false}, {59, true}, {59, false}, {73, true}, {73, false}, {69, true}, {69, false}, {74, true}, {74, false}, {75, true}, {75, false}, {76, true}, {76, false}, {12, true}, {12, false}, {13, true}, {13, false}, {42, true}, {42, false}, {60, true}, {60, false}, {70, true}, {70, false}, {14, true}, {14, false}, {43, true}, {43, false}, {77, true}, {77, false}, {15, true}, {15, false}, {78, true}, {78, false}, {78, false}, {44, true}, {44, false}, {79, true}, {79, false}, {79, false}, {16, true}, {16, false}, {45, true}, {45, false}, {17, true}, {17, false}, {71, true}, {71, false}, {72, true}, {72, false}, {46, true}, {46, false}, {18, true}, {18, false}, {47, true}, {47, false}, {48, true}, {48, false}, {19, true}, {19, false}, {20, true}, {20, false}, {49, true}, {49, false}, {75, true}, {75, false}, {61, true}, {61, false}, {62, true}, {62, false}, {50, true}, {50, false}, {76, true}, {76, false}, {63, true}, {63, false}, {64, true}, {64, false}, {77, true}, {77, false}, {21, true}, {21, false}, {73, true}, {73, false}, {78, true}, {78, false}, {74, true}, {74, false}, {79, true}, {79, false}, {80, true}, {80, false}, {80, false}, {81, true}, {81, false}, {81, false}, {82, true}, {82, false}, {82, false}, {22, true}, {22, false}, {80, true}, {80, false}, {23, true}, {23, false}, {51, true}, {51, false}, {81, true}, {81, false}, {82, true}, {82, false}, {24, true}, {24, false}, {83, true}, {83, false}, {83, false}, {84, true}, {84, false}, {84, false}, {25, true}, {25, false}, {26, true}, {26, false}, {78, true}, {78, false}, {52, true}, {52, false}, {53, true}, {53, false}, {54, true}, {54, false}, {65, true}, {65, false}, {66, true}, {66, false}, {67, true}, {67, false}, {79, true}, {79, false}, {68, true}, {68, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {69, true}, {69, false}, {75, true}, {75, false}, {76, true}, {76, false}, {80, true}, {80, false}, {77, true}, {77, false}, {81, true}, {81, false}, {30, true}, {30, false}, {70, true}, {70, false}, {82, true}, {82, false}, {83, true}, {83, false}, {84, true}, {84, false}, {85, true}, {85, false}, {85, false}, {86, true}, {86, false}, {86, false}, {87, true}, {87, false}, {87, false}, {88, true}, {88, false}, {88, false}, {85, true}, {85, false}, {89, true}, {89, false}, {89, false}, {71, true}, {71, false}, {31, true}, {31, false}, {32, true}, {32, false}, {72, true}, {72, false}, {33, true}, {33, false}, {86, true}, {86, false}, {87, true}, {87, false}, {88, true}, {88, false}, {83, true}, {83, false}, {78, true}, {78, false}, {55, true}, {55, false}, {84, true}, {84, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {56, true}, {56, false}, {57, true}, {57, false}, {58, true}, {58, false}, {79, true}, {79, false}, {73, true}, {73, false}, {59, true}, {59, false}, {74, true}, {74, false}, {85, true}, {85, false}, {80, true}, {80, false}, {86, true}, {86, false}, {81, true}, {81, false}, {87, true}, {87, false}, {88, true}, {88, false}, {82, true}, {82, false}, {60, true}, {60, false}, {89, true}, {89, false}, {90, true}, {90, false}, {90, false}, {91, true}, {91, false}, {91, false}, {92, true}, {92, false}, {92, false}, {93, true}, {93, false}, {93, false}, {90, true}, {90, false}, {94, true}, {94, false}, {94, false}, {91, true}, {91, false}, {95, true}, {95, false}, {95, false}, {92, true}, {92, false}, {93, true}, {93, false}, {94, true}, {94, false}, {96, true}, {96, false}, {96, false}, {95, true}, {95, false}, {97, true}, {97, false}, {97, false}, {83, true}, {83, false}, {37, true}, {37, false}, {89, true}, {89, false}, {38, true}, {38, false}, {84, true}, {84, false}, {96, true}, {96, false}, {61, true}, {61, false}, {39, true}, {39, false}, {40, true}, {40, false}, {62, true}, {62, false}, {63, true}, {63, false}, {41, true}, {41, false}, {64, true}, {64, false}, {75, true}, {75, false}, {76, true}, {76, false}, {77, true}, {77, false}, {85, true}, {85, false}, {86, true}, {86, false}, {87, true}, {87, false}, {88, true}, {88, false}, {90, true}, {90, false}, {91, true}, {91, false}, {92, true}, {92, false}, {93, true}, {93, false}, {94, true}, {94, false}, {95, true}, {95, false}, {96, true}, {96, false}, {97, true}, {97, false}, {98, true}, {98, false}, {98, false}, {42, true}, {42, false}, {99, true}, {99, false}, {99, false}, {78, true}, {78, false}, {100, true}, {100, false}, {100, false}, {43, true}, {43, false}, {98, true}, {98, false}, {99, true}, {99, false}, {101, true}, {101, false}, {101, false}, {44, true}, {44, false}, {65, true}, {65, false}, {66, true}, {66, false}, {45, true}, {45, false}, {67, true}, {67, false}, {68, true}, {68, false}, {79, true}, {79, false}, {46, true}, {46, false}, {69, true}, {69, false}, {47, true}, {47, false}, {48, true}, {48, false}, {80, true}, {80, false}, {81, true}, {81, false}, {0, true}, {0, false}, {49, true}, {49, false}, {1, true}, {1, false}, {70, true}, {70, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {50, true}, {50, false}, {5, true}, {5, false}, {82, true}, {82, false}, {89, true}, {89, false}, {71, true}, {71, false}, {6, true}, {6, false}, {90, true}, {90, false}, {72, true}, {72, false}, {7, true}, {7, false}, {8, true}, {8, false}, {83, true}, {83, false}, {91, true}, {91, false}, {9, true}, {9, false}, {84, true}, {84, false}, {92, true}, {92, false}, {51, true}, {51, false}, {93, true}, {93, false}, {10, true}, {10, false}, {94, true}, {94, false}, {11, true}, {11, false}, {95, true}, {95, false}, {73, true}, {73, false}, {96, true}, {96, false}, {74, true}, {74, false}, {52, true}, {52, false}, {53, true}, {53, false}, {12, true}, {12, false}, {13, true}, {13, false}, {54, true}, {54, false}, {85, true}, {85, false}, {86, true}, {86, false}, {14, true}, {14, false}, {87, true}, {87, false}, {88, true}, {88, false}, {15, true}, {15, false}, {97, true}, {97, false}, {98, true}, {98, false}, {99, true}, {99, false}, {16, true}, {16, false}, {100, true}, {100, false}, {17, true}, {17, false}, {101, true}, {101, false}, {102, true}, {102, false}, {102, false}, {103, true}, {103, false}, {103, false}, {18, true}, {18, false}, {104, true}, {104, false}, {104, false}, {105, true}, {105, false}, {105, false}, {19, true}, {19, false}, {20, true}, {20, false}, {102, true}, {102, false}, {103, true}, {103, false}, {104, true}, {104, false}, {105, true}, {105, false}, {106, true}, {106, false}, {106, false}, {107, true}, {107, false}, {107, false}, {100, true}, {100, false}, {108, true}, {108, false}, {108, false}, {21, true}, {21, false}, {101, true}, {101, false}, {55, true}, {55, false}, {75, true}, {75, false}, {76, true}, {76, false}, {77, true}, {77, false}, {106, true}, {106, false}, {56, true}, {56, false}, {57, true}, {57, false}, {22, true}, {22, false}, {58, true}, {58, false}, {23, true}, {23, false}, {59, true}, {59, false}, {89, true}, {89, false}, {90, true}, {90, false}, {24, true}, {24, false}, {97, true}, {97, false}, {98, true}, {98, false}, {25, true}, {25, false}, {26, true}, {26, false}, {60, true}, {60, false}, {78, true}, {78, false}, {91, true}, {91, false}, {92, true}, {92, false}, {93, true}, {93, false}, {99, true}, {99, false}, {94, true}, {94, false}, {102, true}, {102, false}, {95, true}, {95, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {79, true}, {79, false}, {96, true}, {96, false}, {100, true}, {100, false}, {103, true}, {103, false}, {104, true}, {104, false}, {30, true}, {30, false}, {80, true}, {80, false}, {81, true}, {81, false}, {101, true}, {101, false}, {105, true}, {105, false}, {61, true}, {61, false}, {106, true}, {106, false}, {107, true}, {107, false}, {62, true}, {62, false}, {63, true}, {63, false}, {108, true}, {108, false}, {64, true}, {64, false}, {82, true}, {82, false}, {31, true}, {31, false}, {32, true}, {32, false}, {109, true}, {109, false}, {109, false}, {33, true}, {33, false}, {110, true}, {110, false}, {110, false}, {111, true}, {111, false}, {111, false}, {83, true}, {83, false}, {109, true}, {109, false}, {112, true}, {112, false}, {112, false}, {110, true}, {110, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {84, true}, {84, false}, {107, true}, {107, false}, {102, true}, {102, false}, {108, true}, {108, false}, {111, true}, {111, false}, {112, true}, {112, false}, {113, true}, {113, false}, {113, false}, {114, true}, {114, false}, {114, false}, {115, true}, {115, false}, {115, false}, {103, true}, {103, false}, {65, true}, {65, false}, {66, true}, {66, false}, {85, true}, {85, false}, {67, true}, {67, false}, {68, true}, {68, false}, {86, true}, {86, false}, {87, true}, {87, false}, {69, true}, {69, false}, {88, true}, {88, false}, {97, true}, {97, false}, {98, true}, {98, false}, {104, true}, {104, false}, {105, true}, {105, false}, {106, true}, {106, false}, {70, true}, {70, false}, {109, true}, {109, false}, {110, true}, {110, false}, {99, true}, {99, false}, {37, true}, {37, false}, {111, true}, {111, false}, {38, true}, {38, false}, {112, true}, {112, false}, {71, true}, {71, false}, {113, true}, {113, false}, {39, true}, {39, false}, {40, true}, {40, false}, {72, true}, {72, false}, {100, true}, {100, false}, {41, true}, {41, false}, {107, true}, {107, false}, {108, true}, {108, false}, {114, true}, {114, false}, {115, true}, {115, false}, {101, true}, {101, false}, {116, true}, {116, false}, {116, false}, {117, true}, {117, false}, {117, false}, {118, true}, {118, false}, {118, false}, {119, true}, {119, false}, {119, false}, {116, true}, {116, false}, {73, true}, {73, false}, {113, true}, {113, false}, {74, true}, {74, false}, {117, true}, {117, false}, {89, true}, {89, false}, {90, true}, {90, false}, {118, true}, {118, false}, {42, true}, {42, false}, {114, true}, {114, false}, {115, true}, {115, false}, {119, true}, {119, false}, {43, true}, {43, false}, {120, true}, {120, false}, {120, false}, {109, true}, {109, false}, {91, true}, {91, false}, {44, true}, {44, false}, {92, true}, {92, false}, {93, true}, {93, false}, {45, true}, {45, false}, {94, true}, {94, false}, {95, true}, {95, false}, {102, true}, {102, false}, {46, true}, {46, false}, {110, true}, {110, false}, {47, true}, {47, false}, {48, true}, {48, false}, {96, true}, {96, false}, {103, true}, {103, false}, {49, true}, {49, false}, {111, true}, {111, false}, {112, true}, {112, false}, {116, true}, {116, false}, {117, true}, {117, false}, {50, true}, {50, false}, {118, true}, {118, false}, {119, true}, {119, false}, {120, true}, {120, false}, {121, true}, {121, false}, {121, false}, {104, true}, {104, false}, {105, true}, {105, false}, {75, true}, {75, false}, {76, true}, {76, false}, {77, true}, {77, false}, {106, true}, {106, false}, {113, true}, {113, false}, {114, true}, {114, false}, {115, true}, {115, false}, {121, true}, {121, false}, {51, true}, {51, false}, {122, true}, {122, false}, {122, false}, {123, true}, {123, false}, {123, false}, {124, true}, {124, false}, {124, false}, {120, true}, {120, false}, {125, true}, {125, false}, {125, false}, {122, true}, {122, false}, {126, true}, {126, false}, {126, false}, {107, true}, {107, false}, {108, true}, {108, false}, {52, true}, {52, false}, {53, true}, {53, false}, {78, true}, {78, false}, {123, true}, {123, false}, {54, true}, {54, false}, {124, true}, {124, false}, {121, true}, {121, false}, {125, true}, {125, false}, {126, true}, {126, false}, {127, true}, {127, false}, {127, false}, {116, true}, {116, false}, {79, true}, {79, false}, {117, true}, {117, false}, {118, true}, {118, false}, {119, true}, {119, false}, {122, true}, {122, false}, {97, true}, {97, false}, {80, true}, {80, false}, {81, true}, {81, false}, {98, true}, {98, false}, {109, true}, {109, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {99, true}, {99, false}, {126, true}, {126, false}, {127, true}, {127, false}, {82, true}, {82, false}, {128, true}, {128, false}, {128, false}, {129, true}, {129, false}, {129, false}, {110, true}, {110, false}, {120, true}, {120, false}, {0, true}, {0, false}, {128, true}, {128, false}, {1, true}, {1, false}, {55, true}, {55, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {83, true}, {83, false}, {5, true}, {5, false}, {56, true}, {56, false}, {57, true}, {57, false}, {84, true}, {84, false}, {6, true}, {6, false}, {58, true}, {58, false}, {59, true}, {59, false}, {7, true}, {7, false}, {8, true}, {8, false}, {100, true}, {100, false}, {101, true}, {101, false}, {9, true}, {9, false}, {111, true}, {111, false}, {112, true}, {112, false}, {60, true}, {60, false}, {85, true}, {85, false}, {10, true}, {10, false}, {86, true}, {86, false}, {11, true}, {11, false}, {87, true}, {87, false}, {88, true}, {88, false}, {113, true}, {113, false}, {114, true}, {114, false}, {115, true}, {115, false}, {121, true}, {121, false}, {12, true}, {12, false}, {13, true}, {13, false}, {102, true}, {102, false}, {122, true}, {122, false}, {123, true}, {123, false}, {14, true}, {14, false}, {124, true}, {124, false}, {125, true}, {125, false}, {103, true}, {103, false}, {15, true}, {15, false}, {126, true}, {126, false}, {61, true}, {61, false}, {116, true}, {116, false}, {16, true}, {16, false}, {117, true}, {117, false}, {62, true}, {62, false}, {17, true}, {17, false}, {63, true}, {63, false}, {64, true}, {64, false}, {118, true}, {118, false}, {104, true}, {104, false}, {18, true}, {18, false}, {105, true}, {105, false}, {119, true}, {119, false}, {19, true}, {19, false}, {20, true}, {20, false}, {106, true}, {106, false}, {127, true}, {127, false}, {128, true}, {128, false}, {129, true}, {129, false}, {130, true}, {130, false}, {130, false}, {120, true}, {120, false}, {89, true}, {89, false}, {90, true}, {90, false}, {21, true}, {21, false}, {130, true}, {130, false}, {131, true}, {131, false}, {131, false}, {107, true}, {107, false}, {108, true}, {108, false}, {132, true}, {132, false}, {132, false}, {131, true}, {131, false}, {91, true}, {91, false}, {133, true}, {133, false}, {133, false}, {22, true}, {22, false}, {65, true}, {65, false}, {23, true}, {23, false}, {66, true}, {66, false}, {67, true}, {67, false}, {68, true}, {68, false}, {24, true}, {24, false}, {92, true}, {92, false}, {69, true}, {69, false}, {93, true}, {93, false}, {25, true}, {25, false}, {26, true}, {26, false}, {94, true}, {94, false}, {95, true}, {95, false}, {96, true}, {96, false}, {109, true}, {109, false}, {70, true}, {70, false}, {129, true}, {129, false}, {130, true}, {130, false}, {131, true}, {131, false}, {127, true}, {127, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {71, true}, {71, false}, {121, true}, {121, false}, {110, true}, {110, false}, {122, true}, {122, false}, {123, true}, {123, false}, {72, true}, {72, false}, {30, true}, {30, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {128, true}, {128, false}, {132, true}, {132, false}, {133, true}, {133, false}, {134, true}, {134, false}, {134, false}, {135, true}, {135, false}, {135, false}, {136, true}, {136, false}, {136, false}, {73, true}, {73, false}, {31, true}, {31, false}, {32, true}, {32, false}, {74, true}, {74, false}, {33, true}, {33, false}, {134, true}, {134, false}, {111, true}, {111, false}, {112, true}, {112, false}, {135, true}, {135, false}, {136, true}, {136, false}, {132, true}, {132, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {129, true}, {129, false}, {130, true}, {130, false}, {113, true}, {113, false}, {114, true}, {114, false}, {97, true}, {97, false}, {115, true}, {115, false}, {131, true}, {131, false}, {98, true}, {98, false}, {133, true}, {133, false}, {134, true}, {134, false}, {137, true}, {137, false}, {137, false}, {135, true}, {135, false}, {136, true}, {136, false}, {99, true}, {99, false}, {138, true}, {138, false}, {138, false}, {137, true}, {137, false}, {139, true}, {139, false}, {139, false}, {140, true}, {140, false}, {140, false}, {116, true}, {116, false}, {138, true}, {138, false}, {117, true}, {117, false}, {139, true}, {139, false}, {140, true}, {140, false}, {141, true}, {141, false}, {141, false}, {118, true}, {118, false}, {142, true}, {142, false}, {142, false}, {143, true}, {143, false}, {143, false}, {75, true}, {75, false}, {76, true}, {76, false}, {77, true}, {77, false}, {119, true}, {119, false}, {127, true}, {127, false}, {37, true}, {37, false}, {137, true}, {137, false}, {132, true}, {132, false}, {38, true}, {38, false}, {138, true}, {138, false}, {139, true}, {139, false}, {120, true}, {120, false}, {39, true}, {39, false}, {40, true}, {40, false}, {100, true}, {100, false}, {101, true}, {101, false}, {41, true}, {41, false}, {140, true}, {140, false}, {141, true}, {141, false}, {128, true}, {128, false}, {133, true}, {133, false}, {134, true}, {134, false}, {78, true}, {78, false}, {135, true}, {135, false}, {136, true}, {136, false}, {142, true}, {142, false}, {143, true}, {143, false}, {144, true}, {144, false}, {144, false}, {145, true}, {145, false}, {145, false}, {146, true}, {146, false}, {146, false}, {79, true}, {79, false}, {102, true}, {102, false}, {144, true}, {144, false}, {141, true}, {141, false}, {42, true}, {42, false}, {103, true}, {103, false}, {145, true}, {145, false}, {80, true}, {80, false}, {43, true}, {43, false}, {81, true}, {81, false}, {146, true}, {146, false}, {129, true}, {129, false}, {44, true}, {44, false}, {130, true}, {130, false}, {137, true}, {137, false}, {45, true}, {45, false}, {104, true}, {104, false}, {131, true}, {131, false}, {82, true}, {82, false}, {105, true}, {105, false}, {46, true}, {46, false}, {121, true}, {121, false}, {47, true}, {47, false}, {48, true}, {48, false}, {106, true}, {106, false}, {122, true}, {122, false}, {49, true}, {49, false}, {123, true}, {123, false}, {124, true}, {124, false}, {83, true}, {83, false}, {125, true}, {125, false}, {50, true}, {50, false}, {126, true}, {126, false}, {84, true}, {84, false}, {107, true}, {107, false}, {108, true}, {108, false}, {138, true}, {138, false}, {139, true}, {139, false}, {140, true}, {140, false}, {142, true}, {142, false}, {141, true}, {141, false}, {143, true}, {143, false}, {132, true}, {132, false}, {144, true}, {144, false}, {145, true}, {145, false}, {85, true}, {85, false}, {51, true}, {51, false}, {86, true}, {86, false}, {146, true}, {146, false}, {87, true}, {87, false}, {88, true}, {88, false}, {147, true}, {147, false}, {147, false}, {148, true}, {148, false}, {148, false}, {149, true}, {149, false}, {149, false}, {52, true}, {52, false}, {53, true}, {53, false}, {109, true}, {109, false}, {133, true}, {133, false}, {54, true}, {54, false}, {134, true}, {134, false}, {135, true}, {135, false}, {136, true}, {136, false}, {147, true}, {147, false}, {148, true}, {148, false}, {110, true}, {110, false}, {149, true}, {149, false}, {150, true}, {150, false}, {150, false}, {151, true}, {151, false}, {151, false}, {152, true}, {152, false}, {152, false}, {153, true}, {153, false}, {153, false}, {150, true}, {150, false}, {154, true}, {154, false}, {154, false}, {151, true}, {151, false}, {155, true}, {155, false}, {155, false}, {142, true}, {142, false}, {152, true}, {152, false}, {127, true}, {127, false}, {143, true}, {143, false}, {137, true}, {137, false}, {144, true}, {144, false}, {145, true}, {145, false}, {147, true}, {147, false}, {148, true}, {148, false}, {149, true}, {149, false}, {146, true}, {146, false}, {89, true}, {89, false}, {90, true}, {90, false}, {111, true}, {111, false}, {112, true}, {112, false}, {150, true}, {150, false}, {55, true}, {55, false}, {151, true}, {151, false}, {128, true}, {128, false}, {152, true}, {152, false}, {91, true}, {91, false}, {153, true}, {153, false}, {56, true}, {56, false}, {57, true}, {57, false}, {113, true}, {113, false}, {114, true}, {114, false}, {58, true}, {58, false}, {59, true}, {59, false}, {115, true}, {115, false}, {138, true}, {138, false}, {92, true}, {92, false}, {139, true}, {139, false}, {93, true}, {93, false}, {140, true}, {140, false}, {141, true}, {141, false}, {94, true}, {94, false}, {60, true}, {60, false}, {95, true}, {95, false}, {96, true}, {96, false}, {116, true}, {116, false}, {117, true}, {117, false}, {129, true}, {129, false}, {153, true}, {153, false}, {130, true}, {130, false}, {154, true}, {154, false}, {118, true}, {118, false}, {147, true}, {147, false}, {131, true}, {131, false}, {148, true}, {148, false}, {149, true}, {149, false}, {155, true}, {155, false}, {119, true}, {119, false}, {156, true}, {156, false}, {156, false}, {150, true}, {150, false}, {157, true}, {157, false}, {157, false}, {151, true}, {151, false}, {158, true}, {158, false}, {158, false}, {156, true}, {156, false}, {152, true}, {152, false}, {120, true}, {120, false}, {61, true}, {61, false}, {157, true}, {157, false}, {154, true}, {154, false}, {62, true}, {62, false}, {158, true}, {158, false}, {63, true}, {63, false}, {64, true}, {64, false}, {159, true}, {159, false}, {159, false}, {155, true}, {155, false}, {160, true}, {160, false}, {160, false}, {142, true}, {142, false}, {159, true}, {159, false}, {143, true}, {143, false}, {156, true}, {156, false}, {132, true}, {132, false}, {144, true}, {144, false}, {145, true}, {145, false}, {157, true}, {157, false}, {146, true}, {146, false}, {160, true}, {160, false}, {158, true}, {158, false}, {153, true}, {153, false}, {161, true}, {161, false}, {161, false}, {97, true}, {97, false}, {162, true}, {162, false}, {162, false}, {163, true}, {163, false}, {163, false}, {98, true}, {98, false}, {159, true}, {159, false}, {161, true}, {161, false}, {0, true}, {0, false}, {162, true}, {162, false}, {1, true}, {1, false}, {65, true}, {65, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {66, true}, {66, false}, {5, true}, {5, false}, {67, true}, {67, false}, {68, true}, {68, false}, {69, true}, {69, false}, {6, true}, {6, false}, {99, true}, {99, false}, {121, true}, {121, false}, {7, true}, {7, false}, {8, true}, {8, false}, {70, true}, {70, false}, {122, true}, {122, false}, {9, true}, {9, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {10, true}, {10, false}, {71, true}, {71, false}, {11, true}, {11, false}, {133, true}, {133, false}, {134, true}, {134, false}, {72, true}, {72, false}, {100, true}, {100, false}, {101, true}, {101, false}, {135, true}, {135, false}, {136, true}, {136, false}, {12, true}, {12, false}, {13, true}, {13, false}, {137, true}, {137, false}, {147, true}, {147, false}, {148, true}, {148, false}, {14, true}, {14, false}, {149, true}, {149, false}, {150, true}, {150, false}, {15, true}, {15, false}, {73, true}, {73, false}, {151, true}, {151, false}, {74, true}, {74, false}, {16, true}, {16, false}, {138, true}, {138, false}, {17, true}, {17, false}, {102, true}, {102, false}, {139, true}, {139, false}, {140, true}, {140, false}, {103, true}, {103, false}, {18, true}, {18, false}, {141, true}, {141, false}, {152, true}, {152, false}, {19, true}, {19, false}, {20, true}, {20, false}, {153, true}, {153, false}, {154, true}, {154, false}, {155, true}, {155, false}, {156, true}, {156, false}, {104, true}, {104, false}, {157, true}, {157, false}, {105, true}, {105, false}, {158, true}, {158, false}, {21, true}, {21, false}, {159, true}, {159, false}, {127, true}, {127, false}, {160, true}, {160, false}, {106, true}, {106, false}, {161, true}, {161, false}, {162, true}, {162, false}, {163, true}, {163, false}, {164, true}, {164, false}, {164, false}, {165, true}, {165, false}, {165, false}, {22, true}, {22, false}, {166, true}, {166, false}, {166, false}, {23, true}, {23, false}, {164, true}, {164, false}, {107, true}, {107, false}, {108, true}, {108, false}, {165, true}, {165, false}, {24, true}, {24, false}, {75, true}, {75, false}, {76, true}, {76, false}, {25, true}, {25, false}, {26, true}, {26, false}, {77, true}, {77, false}, {128, true}, {128, false}, {142, true}, {142, false}, {143, true}, {143, false}, {144, true}, {144, false}, {145, true}, {145, false}, {146, true}, {146, false}, {163, true}, {163, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {164, true}, {164, false}, {165, true}, {165, false}, {166, true}, {166, false}, {78, true}, {78, false}, {167, true}, {167, false}, {167, false}, {109, true}, {109, false}, {30, true}, {30, false}, {129, true}, {129, false}, {130, true}, {130, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {131, true}, {131, false}, {167, true}, {167, false}, {79, true}, {79, false}, {110, true}, {110, false}, {168, true}, {168, false}, {168, false}, {169, true}, {169, false}, {169, false}, {31, true}, {31, false}, {32, true}, {32, false}, {80, true}, {80, false}, {33, true}, {33, false}, {81, true}, {81, false}, {166, true}, {166, false}, {168, true}, {168, false}, {169, true}, {169, false}, {170, true}, {170, false}, {170, false}, {154, true}, {154, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {82, true}, {82, false}, {155, true}, {155, false}, {156, true}, {156, false}, {157, true}, {157, false}, {111, true}, {111, false}, {112, true}, {112, false}, {158, true}, {158, false}, {132, true}, {132, false}, {159, true}, {159, false}, {163, true}, {163, false}, {83, true}, {83, false}, {164, true}, {164, false}, {147, true}, {147, false}, {148, true}, {148, false}, {84, true}, {84, false}, {113, true}, {113, false}, {114, true}, {114, false}, {149, true}, {149, false}, {150, true}, {150, false}, {115, true}, {115, false}, {151, true}, {151, false}, {165, true}, {165, false}, {167, true}, {167, false}, {168, true}, {168, false}, {169, true}, {169, false}, {170, true}, {170, false}, {85, true}, {85, false}, {171, true}, {171, false}, {171, false}, {86, true}, {86, false}, {116, true}, {116, false}, {87, true}, {87, false}, {37, true}, {37, false}, {88, true}, {88, false}, {38, true}, {38, false}, {117, true}, {117, false}, {118, true}, {118, false}, {152, true}, {152, false}, {39, true}, {39, false}, {40, true}, {40, false}, {153, true}, {153, false}, {166, true}, {166, false}, {41, true}, {41, false}, {119, true}, {119, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {170, true}, {170, false}, {120, true}, {120, false}, {171, true}, {171, false}, {172, true}, {172, false}, {172, false}, {133, true}, {133, false}, {134, true}, {134, false}, {173, true}, {173, false}, {173, false}, {172, true}, {172, false}, {135, true}, {135, false}, {136, true}, {136, false}, {174, true}, {174, false}, {174, false}, {173, true}, {173, false}, {137, true}, {137, false}, {167, true}, {167, false}, {42, true}, {42, false}, {168, true}, {168, false}, {169, true}, {169, false}, {174, true}, {174, false}, {43, true}, {43, false}, {171, true}, {171, false}, {175, true}, {175, false}, {175, false}, {44, true}, {44, false}, {89, true}, {89, false}, {90, true}, {90, false}, {45, true}, {45, false}, {138, true}, {138, false}, {139, true}, {139, false}, {140, true}, {140, false}, {46, true}, {46, false}, {141, true}, {141, false}, {91, true}, {91, false}, {47, true}, {47, false}, {48, true}, {48, false}, {163, true}, {163, false}, {164, true}, {164, false}, {49, true}, {49, false}, {170, true}, {170, false}, {172, true}, {172, false}, {173, true}, {173, false}, {92, true}, {92, false}, {174, true}, {174, false}, {50, true}, {50, false}, {93, true}, {93, false}, {165, true}, {165, false}, {94, true}, {94, false}, {175, true}, {175, false}, {121, true}, {121, false}, {95, true}, {95, false}, {96, true}, {96, false}, {176, true}, {176, false}, {176, false}, {122, true}, {122, false}, {177, true}, {177, false}, {177, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {154, true}, {154, false}, {51, true}, {51, false}, {171, true}, {171, false}, {176, true}, {176, false}, {155, true}, {155, false}, {156, true}, {156, false}, {157, true}, {157, false}, {166, true}, {166, false}, {158, true}, {158, false}, {175, true}, {175, false}, {142, true}, {142, false}, {52, true}, {52, false}, {53, true}, {53, false}, {143, true}, {143, false}, {144, true}, {144, false}, {54, true}, {54, false}, {145, true}, {145, false}, {146, true}, {146, false}, {159, true}, {159, false}, {172, true}, {172, false}, {173, true}, {173, false}, {174, true}, {174, false}, {176, true}, {176, false}, {167, true}, {167, false}, {177, true}, {177, false}, {168, true}, {168, false}, {169, true}, {169, false}, {178, true}, {178, false}, {178, false}, {179, true}, {179, false}, {179, false}, {180, true}, {180, false}, {180, false}, {181, true}, {181, false}, {181, false}, {178, true}, {178, false}, {182, true}, {182, false}, {182, false}, {179, true}, {179, false}, {97, true}, {97, false}, {180, true}, {180, false}, {181, true}, {181, false}, {98, true}, {98, false}, {182, true}, {182, false}, {183, true}, {183, false}, {183, false}, {177, true}, {177, false}, {184, true}, {184, false}, {184, false}, {127, true}, {127, false}, {183, true}, {183, false}, {55, true}, {55, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {170, true}, {170, false}, {175, true}, {175, false}, {56, true}, {56, false}, {57, true}, {57, false}, {178, true}, {178, false}, {99, true}, {99, false}, {58, true}, {58, false}, {59, true}, {59, false}, {179, true}, {179, false}, {180, true}, {180, false}, {176, true}, {176, false}, {181, true}, {181, false}, {182, true}, {182, false}, {147, true}, {147, false}, {148, true}, {148, false}, {60, true}, {60, false}, {128, true}, {128, false}, {183, true}, {183, false}, {149, true}, {149, false}, {150, true}, {150, false}, {171, true}, {171, false}, {151, true}, {151, false}, {184, true}, {184, false}, {100, true}, {100, false}, {101, true}, {101, false}, {185, true}, {185, false}, {185, false}, {186, true}, {186, false}, {186, false}, {187, true}, {187, false}, {187, false}, {177, true}, {177, false}, {185, true}, {185, false}, {186, true}, {186, false}, {188, true}, {188, false}, {188, false}, {129, true}, {129, false}, {130, true}, {130, false}, {163, true}, {163, false}, {164, true}, {164, false}, {61, true}, {61, false}, {131, true}, {131, false}, {152, true}, {152, false}, {62, true}, {62, false}, {102, true}, {102, false}, {63, true}, {63, false}, {64, true}, {64, false}, {103, true}, {103, false}, {153, true}, {153, false}, {165, true}, {165, false}, {172, true}, {172, false}, {173, true}, {173, false}, {174, true}, {174, false}, {178, true}, {178, false}, {179, true}, {179, false}, {180, true}, {180, false}, {104, true}, {104, false}, {181, true}, {181, false}, {105, true}, {105, false}, {182, true}, {182, false}, {183, true}, {183, false}, {184, true}, {184, false}, {185, true}, {185, false}, {106, true}, {106, false}, {186, true}, {186, false}, {166, true}, {166, false}, {187, true}, {187, false}, {132, true}, {132, false}, {188, true}, {188, false}, {189, true}, {189, false}, {189, false}, {190, true}, {190, false}, {190, false}, {175, true}, {175, false}, {65, true}, {65, false}, {191, true}, {191, false}, {191, false}, {107, true}, {107, false}, {108, true}, {108, false}, {66, true}, {66, false}, {189, true}, {189, false}, {67, true}, {67, false}, {68, true}, {68, false}, {69, true}, {69, false}, {176, true}, {176, false}, {167, true}, {167, false}, {187, true}, {187, false}, {168, true}, {168, false}, {70, true}, {70, false}, {169, true}, {169, false}, {188, true}, {188, false}, {190, true}, {190, false}, {191, true}, {191, false}, {192, true}, {192, false}, {192, false}, {193, true}, {193, false}, {193, false}, {71, true}, {71, false}, {189, true}, {189, false}, {192, true}, {192, false}, {194, true}, {194, false}, {194, false}, {72, true}, {72, false}, {109, true}, {109, false}, {177, true}, {177, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {193, true}, {193, false}, {154, true}, {154, false}, {190, true}, {190, false}, {110, true}, {110, false}, {191, true}, {191, false}, {155, true}, {155, false}, {133, true}, {133, false}, {134, true}, {134, false}, {73, true}, {73, false}, {156, true}, {156, false}, {74, true}, {74, false}, {135, true}, {135, false}, {136, true}, {136, false}, {157, true}, {157, false}, {158, true}, {158, false}, {137, true}, {137, false}, {170, true}, {170, false}, {178, true}, {178, false}, {179, true}, {179, false}, {159, true}, {159, false}, {180, true}, {180, false}, {181, true}, {181, false}, {182, true}, {182, false}, {171, true}, {171, false}, {183, true}, {183, false}, {111, true}, {111, false}, {112, true}, {112, false}, {187, true}, {187, false}, {138, true}, {138, false}, {139, true}, {139, false}, {140, true}, {140, false}, {188, true}, {188, false}, {141, true}, {141, false}, {189, true}, {189, false}, {192, true}, {192, false}, {193, true}, {193, false}, {113, true}, {113, false}, {114, true}, {114, false}, {194, true}, {194, false}, {190, true}, {190, false}, {115, true}, {115, false}, {191, true}, {191, false}, {195, true}, {195, false}, {195, false}, {196, true}, {196, false}, {196, false}, {197, true}, {197, false}, {197, false}, {198, true}, {198, false}, {198, false}, {195, true}, {195, false}, {0, true}, {0, false}, {75, true}, {75, false}, {1, true}, {1, false}, {76, true}, {76, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {77, true}, {77, false}, {5, true}, {5, false}, {116, true}, {116, false}, {117, true}, {117, false}, {118, true}, {118, false}, {6, true}, {6, false}, {160, true}, {160, false}, {161, true}, {161, false}, {7, true}, {7, false}, {8, true}, {8, false}, {119, true}, {119, false}, {162, true}, {162, false}, {9, true}, {9, false}, {78, true}, {78, false}, {120, true}, {120, false}, {142, true}, {142, false}, {143, true}, {143, false}, {10, true}, {10, false}, {144, true}, {144, false}, {11, true}, {11, false}, {145, true}, {145, false}, {146, true}, {146, false}, {79, true}, {79, false}, {172, true}, {172, false}, {173, true}, {173, false}, {174, true}, {174, false}, {175, true}, {175, false}, {12, true}, {12, false}, {13, true}, {13, false}, {80, true}, {80, false}, {163, true}, {163, false}, {81, true}, {81, false}, {14, true}, {14, false}, {164, true}, {164, false}, {176, true}, {176, false}, {15, true}, {15, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {16, true}, {16, false}, {82, true}, {82, false}, {17, true}, {17, false}, {165, true}, {165, false}, {187, true}, {187, false}, {177, true}, {177, false}, {18, true}, {18, false}, {188, true}, {188, false}, {189, true}, {189, false}, {19, true}, {19, false}, {20, true}, {20, false}, {83, true}, {83, false}, {190, true}, {190, false}, {191, true}, {191, false}, {84, true}, {84, false}, {192, true}, {192, false}, {193, true}, {193, false}, {121, true}, {121, false}, {166, true}, {166, false}, {194, true}, {194, false}, {21, true}, {21, false}, {195, true}, {195, false}, {122, true}, {122, false}, {196, true}, {196, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {85, true}, {85, false}, {126, true}, {126, false}, {86, true}, {86, false}, {22, true}, {22, false}, {87, true}, {87, false}, {23, true}, {23, false}, {88, true}, {88, false}, {147, true}, {147, false}, {148, true}, {148, false}, {24, true}, {24, false}, {149, true}, {149, false}, {150, true}, {150, false}, {25, true}, {25, false}, {26, true}, {26, false}, {151, true}, {151, false}, {167, true}, {167, false}, {168, true}, {168, false}, {169, true}, {169, false}, {178, true}, {178, false}, {179, true}, {179, false}, {180, true}, {180, false}, {181, true}, {181, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {152, true}, {152, false}, {182, true}, {182, false}, {183, true}, {183, false}, {196, true}, {196, false}, {153, true}, {153, false}, {194, true}, {194, false}, {30, true}, {30, false}, {195, true}, {195, false}, {197, true}, {197, false}, {198, true}, {198, false}, {199, true}, {199, false}, {199, false}, {199, true}, {199, false}, {89, true}, {89, false}, {90, true}, {90, false}, {31, true}, {31, false}, {32, true}, {32, false}, {127, true}, {127, false}, {33, true}, {33, false}, {170, true}, {170, false}, {91, true}, {91, false}, {197, true}, {197, false}, {198, true}, {198, false}, {171, true}, {171, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {192, true}, {192, false}, {193, true}, {193, false}, {92, true}, {92, false}, {199, true}, {199, false}, {93, true}, {93, false}, {94, true}, {94, false}, {95, true}, {95, false}, {96, true}, {96, false}, {128, true}, {128, false}, {196, true}, {196, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {129, true}, {129, false}, {130, true}, {130, false}, {187, true}, {187, false}, {188, true}, {188, false}, {154, true}, {154, false}, {131, true}, {131, false}, {37, true}, {37, false}, {189, true}, {189, false}, {155, true}, {155, false}, {38, true}, {38, false}, {190, true}, {190, false}, {191, true}, {191, false}, {156, true}, {156, false}, {39, true}, {39, false}, {40, true}, {40, false}, {194, true}, {194, false}, {157, true}, {157, false}, {41, true}, {41, false}, {158, true}, {158, false}, {195, true}, {195, false}, {197, true}, {197, false}, {198, true}, {198, false}, {159, true}, {159, false}, {199, true}, {199, false}, {172, true}, {172, false}, {173, true}, {173, false}, {174, true}, {174, false}, {97, true}, {97, false}, {175, true}, {175, false}, {98, true}, {98, false}, {132, true}, {132, false}, {42, true}, {42, false}, {176, true}, {176, false}, {43, true}, {43, false}, {44, true}, {44, false}, {45, true}, {45, false}, {177, true}, {177, false}, {99, true}, {99, false}, {46, true}, {46, false}, {196, true}, {196, false}, {47, true}, {47, false}, {48, true}, {48, false}, {49, true}, {49, false}, {50, true}, {50, false}, {160, true}, {160, false}, {100, true}, {100, false}, {101, true}, {101, false}, {161, true}, {161, false}, {162, true}, {162, false}, {133, true}, {133, false}, {134, true}, {134, false}, {51, true}, {51, false}, {192, true}, {192, false}, {135, true}, {135, false}, {136, true}, {136, false}, {193, true}, {193, false}, {137, true}, {137, false}, {102, true}, {102, false}, {197, true}, {197, false}, {52, true}, {52, false}, {53, true}, {53, false}, {103, true}, {103, false}, {163, true}, {163, false}, {54, true}, {54, false}, {164, true}, {164, false}, {178, true}, {178, false}, {179, true}, {179, false}, {180, true}, {180, false}, {138, true}, {138, false}, {104, true}, {104, false}, {139, true}, {139, false}, {105, true}, {105, false}, {140, true}, {140, false}, {141, true}, {141, false}, {165, true}, {165, false}, {181, true}, {181, false}, {106, true}, {106, false}, {182, true}, {182, false}, {183, true}, {183, false}, {198, true}, {198, false}, {199, true}, {199, false}, {107, true}, {107, false}, {108, true}, {108, false}, {166, true}, {166, false}, {194, true}, {194, false}, {55, true}, {55, false}, {195, true}, {195, false}, {56, true}, {56, false}, {57, true}, {57, false}, {58, true}, {58, false}, {59, true}, {59, false}, {142, true}, {142, false}, {109, true}, {109, false}, {143, true}, {143, false}, {144, true}, {144, false}, {60, true}, {60, false}, {145, true}, {145, false}, {146, true}, {146, false}, {167, true}, {167, false}, {168, true}, {168, false}, {169, true}, {169, false}, {110, true}, {110, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {187, true}, {187, false}, {188, true}, {188, false}, {196, true}, {196, false}, {189, true}, {189, false}, {190, true}, {190, false}, {191, true}, {191, false}, {61, true}, {61, false}, {62, true}, {62, false}, {63, true}, {63, false}, {64, true}, {64, false}, {111, true}, {111, false}, {112, true}, {112, false}, {170, true}, {170, false}, {171, true}, {171, false}, {113, true}, {113, false}, {114, true}, {114, false}, {115, true}, {115, false}, {197, true}, {197, false}, {65, true}, {65, false}, {147, true}, {147, false}, {148, true}, {148, false}, {66, true}, {66, false}, {149, true}, {149, false}, {116, true}, {116, false}, {67, true}, {67, false}, {68, true}, {68, false}, {69, true}, {69, false}, {117, true}, {117, false}, {118, true}, {118, false}, {150, true}, {150, false}, {119, true}, {119, false}, {70, true}, {70, false}, {151, true}, {151, false}, {198, true}, {198, false}, {120, true}, {120, false}, {199, true}, {199, false}, {152, true}, {152, false}, {71, true}, {71, false}, {153, true}, {153, false}, {72, true}, {72, false}, {192, true}, {192, false}, {193, true}, {193, false}, {172, true}, {172, false}, {173, true}, {173, false}, {174, true}, {174, false}, {73, true}, {73, false}, {175, true}, {175, false}, {74, true}, {74, false}, {176, true}, {176, false}, {177, true}, {177, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {194, true}, {194, false}, {195, true}, {195, false}, {75, true}, {75, false}, {154, true}, {154, false}, {76, true}, {76, false}, {155, true}, {155, false}, {77, true}, {77, false}, {156, true}, {156, false}, {157, true}, {157, false}, {158, true}, {158, false}, {159, true}, {159, false}, {78, true}, {78, false}, {178, true}, {178, false}, {179, true}, {179, false}, {180, true}, {180, false}, {79, true}, {79, false}, {196, true}, {196, false}, {181, true}, {181, false}, {80, true}, {80, false}, {127, true}, {127, false}, {81, true}, {81, false}, {182, true}, {182, false}, {183, true}, {183, false}, {82, true}, {82, false}, {83, true}, {83, false}, {128, true}, {128, false}, {84, true}, {84, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {197, true}, {197, false}, {85, true}, {85, false}, {129, true}, {129, false}, {86, true}, {86, false}, {130, true}, {130, false}, {87, true}, {87, false}, {131, true}, {131, false}, {88, true}, {88, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {187, true}, {187, false}, {188, true}, {188, false}, {163, true}, {163, false}, {164, true}, {164, false}, {189, true}, {189, false}, {0, true}, {0, false}, {190, true}, {190, false}, {1, true}, {1, false}, {191, true}, {191, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {198, true}, {198, false}, {5, true}, {5, false}, {165, true}, {165, false}, {199, true}, {199, false}, {6, true}, {6, false}, {7, true}, {7, false}, {8, true}, {8, false}, {132, true}, {132, false}, {9, true}, {9, false}, {166, true}, {166, false}, {10, true}, {10, false}, {89, true}, {89, false}, {11, true}, {11, false}, {90, true}, {90, false}, {91, true}, {91, false}, {12, true}, {12, false}, {13, true}, {13, false}, {14, true}, {14, false}, {15, true}, {15, false}, {92, true}, {92, false}, {93, true}, {93, false}, {16, true}, {16, false}, {94, true}, {94, false}, {17, true}, {17, false}, {95, true}, {95, false}, {96, true}, {96, false}, {18, true}, {18, false}, {167, true}, {167, false}, {168, true}, {168, false}, {19, true}, {19, false}, {20, true}, {20, false}, {133, true}, {133, false}, {134, true}, {134, false}, {169, true}, {169, false}, {135, true}, {135, false}, {136, true}, {136, false}, {137, true}, {137, false}, {21, true}, {21, false}, {192, true}, {192, false}, {193, true}, {193, false}, {22, true}, {22, false}, {23, true}, {23, false}, {138, true}, {138, false}, {139, true}, {139, false}, {170, true}, {170, false}, {24, true}, {24, false}, {140, true}, {140, false}, {141, true}, {141, false}, {25, true}, {25, false}, {26, true}, {26, false}, {171, true}, {171, false}, {97, true}, {97, false}, {27, true}, {27, false}, {28, true}, {28, false}, {29, true}, {29, false}, {98, true}, {98, false}, {30, true}, {30, false}, {194, true}, {194, false}, {99, true}, {99, false}, {195, true}, {195, false}, {31, true}, {31, false}, {32, true}, {32, false}, {33, true}, {33, false}, {142, true}, {142, false}, {143, true}, {143, false}, {144, true}, {144, false}, {145, true}, {145, false}, {146, true}, {146, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {100, true}, {100, false}, {101, true}, {101, false}, {172, true}, {172, false}, {173, true}, {173, false}, {174, true}, {174, false}, {175, true}, {175, false}, {102, true}, {102, false}, {196, true}, {196, false}, {176, true}, {176, false}, {103, true}, {103, false}, {37, true}, {37, false}, {104, true}, {104, false}, {38, true}, {38, false}, {105, true}, {105, false}, {177, true}, {177, false}, {39, true}, {39, false}, {40, true}, {40, false}, {106, true}, {106, false}, {41, true}, {41, false}, {107, true}, {107, false}, {108, true}, {108, false}, {147, true}, {147, false}, {148, true}, {148, false}, {149, true}, {149, false}, {197, true}, {197, false}, {150, true}, {150, false}, {42, true}, {42, false}, {151, true}, {151, false}, {43, true}, {43, false}, {152, true}, {152, false}, {44, true}, {44, false}, {45, true}, {45, false}, {153, true}, {153, false}, {109, true}, {109, false}, {46, true}, {46, false}, {47, true}, {47, false}, {48, true}, {48, false}, {178, true}, {178, false}, {179, true}, {179, false}, {49, true}, {49, false}, {110, true}, {110, false}, {180, true}, {180, false}, {198, true}, {198, false}, {50, true}, {50, false}, {181, true}, {181, false}, {199, true}, {199, false}, {182, true}, {182, false}, {183, true}, {183, false}, {51, true}, {51, false}, {111, true}, {111, false}, {112, true}, {112, false}, {52, true}, {52, false}, {53, true}, {53, false}, {113, true}, {113, false}, {114, true}, {114, false}, {54, true}, {54, false}, {115, true}, {115, false}, {154, true}, {154, false}, {155, true}, {155, false}, {156, true}, {156, false}, {116, true}, {116, false}, {184, true}, {184, false}, {185, true}, {185, false}, {157, true}, {157, false}, {186, true}, {186, false}, {117, true}, {117, false}, {118, true}, {118, false}, {158, true}, {158, false}, {119, true}, {119, false}, {159, true}, {159, false}, {187, true}, {187, false}, {188, true}, {188, false}, {120, true}, {120, false}, {55, true}, {55, false}, {189, true}, {189, false}, {190, true}, {190, false}, {191, true}, {191, false}, {56, true}, {56, false}, {57, true}, {57, false}, {58, true}, {58, false}, {59, true}, {59, false}, {60, true}, {60, false}, {160, true}, {160, false}, {61, true}, {61, false}, {121, true}, {121, false}, {161, true}, {161, false}, {62, true}, {62, false}, {162, true}, {162, false}, {63, true}, {63, false}, {64, true}, {64, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {65, true}, {65, false}, {66, true}, {66, false}, {67, true}, {67, false}, {68, true}, {68, false}, {69, true}, {69, false}, {70, true}, {70, false}, {71, true}, {71, false}, {72, true}, {72, false}, {73, true}, {73, false}, {74, true}, {74, false}, {75, true}, {75, false}, {76, true}, {76, false}, {77, true}}

// Review each phrase is only repeated one time
var Review = []Audio{{0, true}, {0, false}, {0, false}, {1, true}, {1, false}, {1, false}, {2, true}, {2, false}, {2, false}, {3, true}, {3, false}, {3, false}, {4, true}, {4, false}, {4, false}, {5, true}, {5, false}, {5, false}, {6, true}, {6, false}, {6, false}, {7, true}, {7, false}, {7, false}, {8, true}, {8, false}, {8, false}, {9, true}, {9, false}, {9, false}, {10, true}, {10, false}, {10, false}, {11, true}, {11, false}, {11, false}, {12, true}, {12, false}, {12, false}, {13, true}, {13, false}, {13, false}, {14, true}, {14, false}, {14, false}, {15, true}, {15, false}, {15, false}, {16, true}, {16, false}, {16, false}, {17, true}, {17, false}, {17, false}, {18, true}, {18, false}, {18, false}, {19, true}, {19, false}, {19, false}, {20, true}, {20, false}, {20, false}, {21, true}, {21, false}, {21, false}, {22, true}, {22, false}, {22, false}, {23, true}, {23, false}, {23, false}, {24, true}, {24, false}, {24, false}, {25, true}, {25, false}, {25, false}, {26, true}, {26, false}, {26, false}, {27, true}, {27, false}, {27, false}, {28, true}, {28, false}, {28, false}, {29, true}, {29, false}, {29, false}, {30, true}, {30, false}, {30, false}, {31, true}, {31, false}, {31, false}, {32, true}, {32, false}, {32, false}, {33, true}, {33, false}, {33, false}, {34, true}, {34, false}, {34, false}, {35, true}, {35, false}, {35, false}, {36, true}, {36, false}, {36, false}, {37, true}, {37, false}, {37, false}, {38, true}, {38, false}, {38, false}, {39, true}, {39, false}, {39, false}, {40, true}, {40, false}, {40, false}, {41, true}, {41, false}, {41, false}, {42, true}, {42, false}, {42, false}, {43, true}, {43, false}, {43, false}, {44, true}, {44, false}, {44, false}, {45, true}, {45, false}, {45, false}, {46, true}, {46, false}, {46, false}, {47, true}, {47, false}, {47, false}, {48, true}, {48, false}, {48, false}, {49, true}, {49, false}, {49, false}, {50, true}, {50, false}, {50, false}, {51, true}, {51, false}, {51, false}, {52, true}, {52, false}, {52, false}, {53, true}, {53, false}, {53, false}, {54, true}, {54, false}, {54, false}, {55, true}, {55, false}, {55, false}, {56, true}, {56, false}, {56, false}, {57, true}, {57, false}, {57, false}, {58, true}, {58, false}, {58, false}, {59, true}, {59, false}, {59, false}, {60, true}, {60, false}, {60, false}, {61, true}, {61, false}, {61, false}, {62, true}, {62, false}, {62, false}, {63, true}, {63, false}, {63, false}, {64, true}, {64, false}, {64, false}, {65, true}, {65, false}, {65, false}, {66, true}, {66, false}, {66, false}, {67, true}, {67, false}, {67, false}, {68, true}, {68, false}, {68, false}, {69, true}, {69, false}, {69, false}, {70, true}, {70, false}, {70, false}, {71, true}, {71, false}, {71, false}, {72, true}, {72, false}, {72, false}, {73, true}, {73, false}, {73, false}, {74, true}, {74, false}, {74, false}, {75, true}, {75, false}, {75, false}, {76, true}, {76, false}, {76, false}, {77, true}, {77, false}, {77, false}, {78, true}, {78, false}, {78, false}, {79, true}, {79, false}, {79, false}, {80, true}, {80, false}, {80, false}, {81, true}, {81, false}, {81, false}, {82, true}, {82, false}, {82, false}, {83, true}, {83, false}, {83, false}, {84, true}, {84, false}, {84, false}, {85, true}, {85, false}, {85, false}, {86, true}, {86, false}, {86, false}, {87, true}, {87, false}, {87, false}, {88, true}, {88, false}, {88, false}, {89, true}, {89, false}, {89, false}, {90, true}, {90, false}, {90, false}, {91, true}, {91, false}, {91, false}, {92, true}, {92, false}, {92, false}, {93, true}, {93, false}, {93, false}, {94, true}, {94, false}, {94, false}, {95, true}, {95, false}, {95, false}, {96, true}, {96, false}, {96, false}, {97, true}, {97, false}, {97, false}, {98, true}, {98, false}, {98, false}, {99, true}, {99, false}, {99, false}, {100, true}, {100, false}, {100, false}, {101, true}, {101, false}, {101, false}, {102, true}, {102, false}, {102, false}, {103, true}, {103, false}, {103, false}, {104, true}, {104, false}, {104, false}, {105, true}, {105, false}, {105, false}, {106, true}, {106, false}, {106, false}, {107, true}, {107, false}, {107, false}, {108, true}, {108, false}, {108, false}, {109, true}, {109, false}, {109, false}, {110, true}, {110, false}, {110, false}, {111, true}, {111, false}, {111, false}, {112, true}, {112, false}, {112, false}, {113, true}, {113, false}, {113, false}, {114, true}, {114, false}, {114, false}, {115, true}, {115, false}, {115, false}, {116, true}, {116, false}, {116, false}, {117, true}, {117, false}, {117, false}, {118, true}, {118, false}, {118, false}, {119, true}, {119, false}, {119, false}, {120, true}, {120, false}, {120, false}, {121, true}, {121, false}, {121, false}, {122, true}, {122, false}, {122, false}, {123, true}, {123, false}, {123, false}, {124, true}, {124, false}, {124, false}, {125, true}, {125, false}, {125, false}, {126, true}, {126, false}, {126, false}, {127, true}, {127, false}, {127, false}, {128, true}, {128, false}, {128, false}, {129, true}, {129, false}, {129, false}, {130, true}, {130, false}, {130, false}, {131, true}, {131, false}, {131, false}, {132, true}, {132, false}, {132, false}, {133, true}, {133, false}, {133, false}, {134, true}, {134, false}, {134, false}, {135, true}, {135, false}, {135, false}, {136, true}, {136, false}, {136, false}, {137, true}, {137, false}, {137, false}, {138, true}, {138, false}, {138, false}, {139, true}, {139, false}, {139, false}, {140, true}, {140, false}, {140, false}, {141, true}, {141, false}, {141, false}, {142, true}, {142, false}, {142, false}, {143, true}, {143, false}, {143, false}, {144, true}, {144, false}, {144, false}, {145, true}, {145, false}, {145, false}, {146, true}, {146, false}, {146, false}, {147, true}, {147, false}, {147, false}, {148, true}, {148, false}, {148, false}, {149, true}, {149, false}, {149, false}, {150, true}, {150, false}, {150, false}, {151, true}, {151, false}, {151, false}, {152, true}, {152, false}, {152, false}, {153, true}, {153, false}, {153, false}, {154, true}, {154, false}, {154, false}, {155, true}, {155, false}, {155, false}, {156, true}, {156, false}, {156, false}, {157, true}, {157, false}, {157, false}, {158, true}, {158, false}, {158, false}, {159, true}, {159, false}, {159, false}, {160, true}, {160, false}, {160, false}, {161, true}, {161, false}, {161, false}, {162, true}, {162, false}, {162, false}, {163, true}, {163, false}, {163, false}, {164, true}, {164, false}, {164, false}, {165, true}, {165, false}, {165, false}, {166, true}, {166, false}, {166, false}, {167, true}, {167, false}, {167, false}, {168, true}, {168, false}, {168, false}, {169, true}, {169, false}, {169, false}, {170, true}, {170, false}, {170, false}, {171, true}, {171, false}, {171, false}, {172, true}, {172, false}, {172, false}, {173, true}, {173, false}, {173, false}, {174, true}, {174, false}, {174, false}, {175, true}, {175, false}, {175, false}, {176, true}, {176, false}, {176, false}, {177, true}, {177, false}, {177, false}, {178, true}, {178, false}, {178, false}, {179, true}, {179, false}, {179, false}, {180, true}, {180, false}, {180, false}, {181, true}, {181, false}, {181, false}, {182, true}, {182, false}, {182, false}, {183, true}, {183, false}, {183, false}, {184, true}, {184, false}, {184, false}, {185, true}, {185, false}, {185, false}, {186, true}, {186, false}, {186, false}, {187, true}, {187, false}, {187, false}, {188, true}, {188, false}, {188, false}, {189, true}, {189, false}, {189, false}, {190, true}, {190, false}, {190, false}, {191, true}, {191, false}, {191, false}, {192, true}, {192, false}, {192, false}, {193, true}, {193, false}, {193, false}, {194, true}, {194, false}, {194, false}, {195, true}, {195, false}, {195, false}, {196, true}, {196, false}, {196, false}, {197, true}, {197, false}, {197, false}, {198, true}, {198, false}, {198, false}, {199, true}, {199, false}, {199, false}}

// Advanced has the multiplier set to 25 in audioPatternBuilder
// each phrase is repeated seven or eight times
var Advanced = []Audio{{0, true}, {0, false}, {0, false}, {1, true}, {1, false}, {1, false}, {2, true}, {2, false}, {2, false}, {3, true}, {3, false}, {3, false}, {4, true}, {4, false}, {4, false}, {5, true}, {5, false}, {5, false}, {6, true}, {6, false}, {6, false}, {7, true}, {7, false}, {7, false}, {8, true}, {8, false}, {8, false}, {0, true}, {0, false}, {9, true}, {9, false}, {9, false}, {1, true}, {1, false}, {10, true}, {10, false}, {10, false}, {2, true}, {2, false}, {11, true}, {11, false}, {11, false}, {3, true}, {3, false}, {12, true}, {12, false}, {12, false}, {4, true}, {4, false}, {13, true}, {13, false}, {13, false}, {5, true}, {5, false}, {14, true}, {14, false}, {14, false}, {6, true}, {6, false}, {15, true}, {15, false}, {15, false}, {7, true}, {7, false}, {16, true}, {16, false}, {16, false}, {8, true}, {8, false}, {17, true}, {17, false}, {17, false}, {9, true}, {9, false}, {18, true}, {18, false}, {18, false}, {10, true}, {10, false}, {19, true}, {19, false}, {19, false}, {11, true}, {11, false}, {20, true}, {20, false}, {20, false}, {12, true}, {12, false}, {21, true}, {21, false}, {21, false}, {13, true}, {13, false}, {22, true}, {22, false}, {22, false}, {14, true}, {14, false}, {23, true}, {23, false}, {23, false}, {15, true}, {15, false}, {24, true}, {24, false}, {24, false}, {16, true}, {16, false}, {25, true}, {25, false}, {25, false}, {17, true}, {17, false}, {26, true}, {26, false}, {26, false}, {18, true}, {18, false}, {27, true}, {27, false}, {27, false}, {19, true}, {19, false}, {28, true}, {28, false}, {28, false}, {20, true}, {20, false}, {29, true}, {29, false}, {29, false}, {21, true}, {21, false}, {30, true}, {30, false}, {30, false}, {22, true}, {22, false}, {31, true}, {31, false}, {31, false}, {23, true}, {23, false}, {32, true}, {32, false}, {32, false}, {24, true}, {24, false}, {33, true}, {33, false}, {33, false}, {25, true}, {25, false}, {34, true}, {34, false}, {34, false}, {26, true}, {26, false}, {35, true}, {35, false}, {35, false}, {27, true}, {27, false}, {36, true}, {36, false}, {36, false}, {28, true}, {28, false}, {37, true}, {37, false}, {37, false}, {29, true}, {29, false}, {38, true}, {38, false}, {38, false}, {30, true}, {30, false}, {39, true}, {39, false}, {39, false}, {31, true}, {31, false}, {40, true}, {40, false}, {40, false}, {32, true}, {32, false}, {41, true}, {41, false}, {41, false}, {33, true}, {33, false}, {0, true}, {0, false}, {34, true}, {34, false}, {1, true}, {1, false}, {35, true}, {35, false}, {2, true}, {2, false}, {36, true}, {36, false}, {3, true}, {3, false}, {37, true}, {37, false}, {4, true}, {4, false}, {38, true}, {38, false}, {5, true}, {5, false}, {39, true}, {39, false}, {6, true}, {6, false}, {40, true}, {40, false}, {7, true}, {7, false}, {41, true}, {41, false}, {8, true}, {8, false}, {42, true}, {42, false}, {42, false}, {9, true}, {9, false}, {43, true}, {43, false}, {43, false}, {10, true}, {10, false}, {44, true}, {44, false}, {44, false}, {11, true}, {11, false}, {45, true}, {45, false}, {45, false}, {12, true}, {12, false}, {46, true}, {46, false}, {46, false}, {13, true}, {13, false}, {47, true}, {47, false}, {47, false}, {14, true}, {14, false}, {48, true}, {48, false}, {48, false}, {15, true}, {15, false}, {49, true}, {49, false}, {49, false}, {16, true}, {16, false}, {50, true}, {50, false}, {50, false}, {17, true}, {17, false}, {42, true}, {42, false}, {18, true}, {18, false}, {43, true}, {43, false}, {19, true}, {19, false}, {44, true}, {44, false}, {20, true}, {20, false}, {45, true}, {45, false}, {21, true}, {21, false}, {46, true}, {46, false}, {22, true}, {22, false}, {47, true}, {47, false}, {23, true}, {23, false}, {48, true}, {48, false}, {24, true}, {24, false}, {49, true}, {49, false}, {25, true}, {25, false}, {50, true}, {50, false}, {26, true}, {26, false}, {51, true}, {51, false}, {51, false}, {27, true}, {27, false}, {52, true}, {52, false}, {52, false}, {28, true}, {28, false}, {53, true}, {53, false}, {53, false}, {29, true}, {29, false}, {54, true}, {54, false}, {54, false}, {30, true}, {30, false}, {55, true}, {55, false}, {55, false}, {31, true}, {31, false}, {56, true}, {56, false}, {56, false}, {32, true}, {32, false}, {33, true}, {33, false}, {57, true}, {57, false}, {57, false}, {34, true}, {34, false}, {58, true}, {58, false}, {58, false}, {35, true}, {35, false}, {51, true}, {51, false}, {36, true}, {36, false}, {52, true}, {52, false}, {37, true}, {37, false}, {53, true}, {53, false}, {38, true}, {38, false}, {54, true}, {54, false}, {39, true}, {39, false}, {55, true}, {55, false}, {40, true}, {40, false}, {56, true}, {56, false}, {41, true}, {41, false}, {57, true}, {57, false}, {58, true}, {58, false}, {59, true}, {59, false}, {59, false}, {60, true}, {60, false}, {60, false}, {61, true}, {61, false}, {61, false}, {62, true}, {62, false}, {62, false}, {63, true}, {63, false}, {63, false}, {64, true}, {64, false}, {64, false}, {65, true}, {65, false}, {65, false}, {66, true}, {66, false}, {66, false}, {42, true}, {42, false}, {67, true}, {67, false}, {67, false}, {43, true}, {43, false}, {59, true}, {59, false}, {44, true}, {44, false}, {60, true}, {60, false}, {45, true}, {45, false}, {61, true}, {61, false}, {46, true}, {46, false}, {62, true}, {62, false}, {47, true}, {47, false}, {63, true}, {63, false}, {48, true}, {48, false}, {64, true}, {64, false}, {49, true}, {49, false}, {65, true}, {65, false}, {50, true}, {50, false}, {66, true}, {66, false}, {67, true}, {67, false}, {68, true}, {68, false}, {68, false}, {69, true}, {69, false}, {69, false}, {70, true}, {70, false}, {70, false}, {71, true}, {71, false}, {71, false}, {72, true}, {72, false}, {72, false}, {73, true}, {73, false}, {73, false}, {74, true}, {74, false}, {74, false}, {75, true}, {75, false}, {75, false}, {51, true}, {51, false}, {76, true}, {76, false}, {76, false}, {52, true}, {52, false}, {68, true}, {68, false}, {53, true}, {53, false}, {69, true}, {69, false}, {54, true}, {54, false}, {70, true}, {70, false}, {55, true}, {55, false}, {71, true}, {71, false}, {56, true}, {56, false}, {72, true}, {72, false}, {57, true}, {57, false}, {0, true}, {0, false}, {58, true}, {58, false}, {1, true}, {1, false}, {73, true}, {73, false}, {2, true}, {2, false}, {74, true}, {74, false}, {3, true}, {3, false}, {75, true}, {75, false}, {4, true}, {4, false}, {76, true}, {76, false}, {5, true}, {5, false}, {77, true}, {77, false}, {77, false}, {6, true}, {6, false}, {78, true}, {78, false}, {78, false}, {7, true}, {7, false}, {79, true}, {79, false}, {79, false}, {8, true}, {8, false}, {80, true}, {80, false}, {80, false}, {9, true}, {9, false}, {59, true}, {59, false}, {10, true}, {10, false}, {60, true}, {60, false}, {11, true}, {11, false}, {61, true}, {61, false}, {12, true}, {12, false}, {62, true}, {62, false}, {13, true}, {13, false}, {63, true}, {63, false}, {14, true}, {14, false}, {64, true}, {64, false}, {15, true}, {15, false}, {65, true}, {65, false}, {16, true}, {16, false}, {66, true}, {66, false}, {17, true}, {17, false}, {67, true}, {67, false}, {18, true}, {18, false}, {77, true}, {77, false}, {19, true}, {19, false}, {78, true}, {78, false}, {20, true}, {20, false}, {79, true}, {79, false}, {21, true}, {21, false}, {80, true}, {80, false}, {22, true}, {22, false}, {81, true}, {81, false}, {81, false}, {23, true}, {23, false}, {82, true}, {82, false}, {82, false}, {24, true}, {24, false}, {68, true}, {68, false}, {25, true}, {25, false}, {69, true}, {69, false}, {26, true}, {26, false}, {70, true}, {70, false}, {27, true}, {27, false}, {71, true}, {71, false}, {28, true}, {28, false}, {72, true}, {72, false}, {29, true}, {29, false}, {81, true}, {81, false}, {30, true}, {30, false}, {73, true}, {73, false}, {31, true}, {31, false}, {74, true}, {74, false}, {32, true}, {32, false}, {33, true}, {33, false}, {75, true}, {75, false}, {34, true}, {34, false}, {76, true}, {76, false}, {35, true}, {35, false}, {82, true}, {82, false}, {36, true}, {36, false}, {83, true}, {83, false}, {83, false}, {37, true}, {37, false}, {84, true}, {84, false}, {84, false}, {38, true}, {38, false}, {85, true}, {85, false}, {85, false}, {39, true}, {39, false}, {86, true}, {86, false}, {86, false}, {40, true}, {40, false}, {87, true}, {87, false}, {87, false}, {41, true}, {41, false}, {88, true}, {88, false}, {88, false}, {89, true}, {89, false}, {89, false}, {90, true}, {90, false}, {90, false}, {91, true}, {91, false}, {91, false}, {83, true}, {83, false}, {92, true}, {92, false}, {92, false}, {84, true}, {84, false}, {93, true}, {93, false}, {93, false}, {85, true}, {85, false}, {94, true}, {94, false}, {94, false}, {86, true}, {86, false}, {95, true}, {95, false}, {95, false}, {77, true}, {77, false}, {87, true}, {87, false}, {78, true}, {78, false}, {88, true}, {88, false}, {42, true}, {42, false}, {79, true}, {79, false}, {43, true}, {43, false}, {80, true}, {80, false}, {44, true}, {44, false}, {89, true}, {89, false}, {45, true}, {45, false}, {90, true}, {90, false}, {46, true}, {46, false}, {91, true}, {91, false}, {47, true}, {47, false}, {92, true}, {92, false}, {48, true}, {48, false}, {93, true}, {93, false}, {49, true}, {49, false}, {94, true}, {94, false}, {50, true}, {50, false}, {95, true}, {95, false}, {96, true}, {96, false}, {96, false}, {81, true}, {81, false}, {97, true}, {97, false}, {97, false}, {98, true}, {98, false}, {98, false}, {99, true}, {99, false}, {99, false}, {100, true}, {100, false}, {100, false}, {101, true}, {101, false}, {101, false}, {102, true}, {102, false}, {102, false}, {103, true}, {103, false}, {103, false}, {82, true}, {82, false}, {51, true}, {51, false}, {96, true}, {96, false}, {52, true}, {52, false}, {97, true}, {97, false}, {53, true}, {53, false}, {98, true}, {98, false}, {54, true}, {54, false}, {99, true}, {99, false}, {55, true}, {55, false}, {100, true}, {100, false}, {56, true}, {56, false}, {101, true}, {101, false}, {57, true}, {57, false}, {102, true}, {102, false}, {58, true}, {58, false}, {103, true}, {103, false}, {104, true}, {104, false}, {104, false}, {83, true}, {83, false}, {105, true}, {105, false}, {105, false}, {84, true}, {84, false}, {106, true}, {106, false}, {106, false}, {85, true}, {85, false}, {107, true}, {107, false}, {107, false}, {86, true}, {86, false}, {108, true}, {108, false}, {108, false}, {87, true}, {87, false}, {109, true}, {109, false}, {109, false}, {88, true}, {88, false}, {110, true}, {110, false}, {110, false}, {59, true}, {59, false}, {111, true}, {111, false}, {111, false}, {60, true}, {60, false}, {104, true}, {104, false}, {61, true}, {61, false}, {89, true}, {89, false}, {62, true}, {62, false}, {90, true}, {90, false}, {63, true}, {63, false}, {91, true}, {91, false}, {64, true}, {64, false}, {92, true}, {92, false}, {65, true}, {65, false}, {93, true}, {93, false}, {66, true}, {66, false}, {94, true}, {94, false}, {67, true}, {67, false}, {95, true}, {95, false}, {105, true}, {105, false}, {106, true}, {106, false}, {107, true}, {107, false}, {108, true}, {108, false}, {109, true}, {109, false}, {110, true}, {110, false}, {111, true}, {111, false}, {112, true}, {112, false}, {112, false}, {68, true}, {68, false}, {96, true}, {96, false}, {69, true}, {69, false}, {97, true}, {97, false}, {70, true}, {70, false}, {98, true}, {98, false}, {71, true}, {71, false}, {99, true}, {99, false}, {72, true}, {72, false}, {100, true}, {100, false}, {101, true}, {101, false}, {73, true}, {73, false}, {102, true}, {102, false}, {74, true}, {74, false}, {103, true}, {103, false}, {112, true}, {112, false}, {75, true}, {75, false}, {113, true}, {113, false}, {113, false}, {76, true}, {76, false}, {114, true}, {114, false}, {114, false}, {115, true}, {115, false}, {115, false}, {116, true}, {116, false}, {116, false}, {117, true}, {117, false}, {117, false}, {118, true}, {118, false}, {118, false}, {119, true}, {119, false}, {119, false}, {104, true}, {104, false}, {120, true}, {120, false}, {120, false}, {113, true}, {113, false}, {121, true}, {121, false}, {121, false}, {114, true}, {114, false}, {122, true}, {122, false}, {122, false}, {115, true}, {115, false}, {123, true}, {123, false}, {123, false}, {116, true}, {116, false}, {124, true}, {124, false}, {124, false}, {117, true}, {117, false}, {125, true}, {125, false}, {125, false}, {118, true}, {118, false}, {119, true}, {119, false}, {77, true}, {77, false}, {126, true}, {126, false}, {126, false}, {78, true}, {78, false}, {105, true}, {105, false}, {79, true}, {79, false}, {106, true}, {106, false}, {80, true}, {80, false}, {107, true}, {107, false}, {108, true}, {108, false}, {109, true}, {109, false}, {110, true}, {110, false}, {111, true}, {111, false}, {120, true}, {120, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {0, true}, {0, false}, {124, true}, {124, false}, {1, true}, {1, false}, {125, true}, {125, false}, {2, true}, {2, false}, {81, true}, {81, false}, {3, true}, {3, false}, {126, true}, {126, false}, {4, true}, {4, false}, {127, true}, {127, false}, {127, false}, {5, true}, {5, false}, {128, true}, {128, false}, {128, false}, {6, true}, {6, false}, {112, true}, {112, false}, {7, true}, {7, false}, {129, true}, {129, false}, {129, false}, {8, true}, {8, false}, {130, true}, {130, false}, {130, false}, {9, true}, {9, false}, {82, true}, {82, false}, {10, true}, {10, false}, {131, true}, {131, false}, {131, false}, {11, true}, {11, false}, {132, true}, {132, false}, {132, false}, {12, true}, {12, false}, {127, true}, {127, false}, {13, true}, {13, false}, {128, true}, {128, false}, {14, true}, {14, false}, {133, true}, {133, false}, {133, false}, {15, true}, {15, false}, {113, true}, {113, false}, {16, true}, {16, false}, {129, true}, {129, false}, {17, true}, {17, false}, {114, true}, {114, false}, {18, true}, {18, false}, {83, true}, {83, false}, {19, true}, {19, false}, {84, true}, {84, false}, {20, true}, {20, false}, {85, true}, {85, false}, {21, true}, {21, false}, {86, true}, {86, false}, {22, true}, {22, false}, {87, true}, {87, false}, {23, true}, {23, false}, {88, true}, {88, false}, {24, true}, {24, false}, {115, true}, {115, false}, {25, true}, {25, false}, {89, true}, {89, false}, {26, true}, {26, false}, {90, true}, {90, false}, {27, true}, {27, false}, {91, true}, {91, false}, {28, true}, {28, false}, {92, true}, {92, false}, {29, true}, {29, false}, {93, true}, {93, false}, {30, true}, {30, false}, {94, true}, {94, false}, {31, true}, {31, false}, {95, true}, {95, false}, {32, true}, {32, false}, {33, true}, {33, false}, {116, true}, {116, false}, {34, true}, {34, false}, {117, true}, {117, false}, {35, true}, {35, false}, {118, true}, {118, false}, {36, true}, {36, false}, {96, true}, {96, false}, {37, true}, {37, false}, {97, true}, {97, false}, {38, true}, {38, false}, {98, true}, {98, false}, {39, true}, {39, false}, {99, true}, {99, false}, {40, true}, {40, false}, {100, true}, {100, false}, {41, true}, {41, false}, {101, true}, {101, false}, {102, true}, {102, false}, {103, true}, {103, false}, {119, true}, {119, false}, {120, true}, {120, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {127, true}, {127, false}, {128, true}, {128, false}, {129, true}, {129, false}, {104, true}, {104, false}, {42, true}, {42, false}, {130, true}, {130, false}, {43, true}, {43, false}, {131, true}, {131, false}, {44, true}, {44, false}, {132, true}, {132, false}, {45, true}, {45, false}, {133, true}, {133, false}, {46, true}, {46, false}, {134, true}, {134, false}, {134, false}, {47, true}, {47, false}, {135, true}, {135, false}, {135, false}, {48, true}, {48, false}, {136, true}, {136, false}, {136, false}, {49, true}, {49, false}, {137, true}, {137, false}, {137, false}, {50, true}, {50, false}, {138, true}, {138, false}, {138, false}, {105, true}, {105, false}, {139, true}, {139, false}, {139, false}, {106, true}, {106, false}, {140, true}, {140, false}, {140, false}, {107, true}, {107, false}, {108, true}, {108, false}, {109, true}, {109, false}, {110, true}, {110, false}, {111, true}, {111, false}, {134, true}, {134, false}, {135, true}, {135, false}, {136, true}, {136, false}, {137, true}, {137, false}, {51, true}, {51, false}, {138, true}, {138, false}, {52, true}, {52, false}, {139, true}, {139, false}, {53, true}, {53, false}, {140, true}, {140, false}, {54, true}, {54, false}, {141, true}, {141, false}, {141, false}, {55, true}, {55, false}, {142, true}, {142, false}, {142, false}, {56, true}, {56, false}, {143, true}, {143, false}, {143, false}, {57, true}, {57, false}, {112, true}, {112, false}, {58, true}, {58, false}, {144, true}, {144, false}, {144, false}, {145, true}, {145, false}, {145, false}, {146, true}, {146, false}, {146, false}, {147, true}, {147, false}, {147, false}, {141, true}, {141, false}, {148, true}, {148, false}, {148, false}, {142, true}, {142, false}, {149, true}, {149, false}, {149, false}, {143, true}, {143, false}, {150, true}, {150, false}, {150, false}, {113, true}, {113, false}, {59, true}, {59, false}, {130, true}, {130, false}, {60, true}, {60, false}, {114, true}, {114, false}, {61, true}, {61, false}, {131, true}, {131, false}, {62, true}, {62, false}, {132, true}, {132, false}, {63, true}, {63, false}, {133, true}, {133, false}, {64, true}, {64, false}, {144, true}, {144, false}, {65, true}, {65, false}, {145, true}, {145, false}, {66, true}, {66, false}, {146, true}, {146, false}, {67, true}, {67, false}, {147, true}, {147, false}, {148, true}, {148, false}, {115, true}, {115, false}, {149, true}, {149, false}, {150, true}, {150, false}, {151, true}, {151, false}, {151, false}, {134, true}, {134, false}, {135, true}, {135, false}, {136, true}, {136, false}, {137, true}, {137, false}, {68, true}, {68, false}, {138, true}, {138, false}, {69, true}, {69, false}, {139, true}, {139, false}, {70, true}, {70, false}, {140, true}, {140, false}, {71, true}, {71, false}, {152, true}, {152, false}, {152, false}, {72, true}, {72, false}, {151, true}, {151, false}, {153, true}, {153, false}, {153, false}, {73, true}, {73, false}, {116, true}, {116, false}, {74, true}, {74, false}, {117, true}, {117, false}, {118, true}, {118, false}, {75, true}, {75, false}, {154, true}, {154, false}, {154, false}, {76, true}, {76, false}, {141, true}, {141, false}, {155, true}, {155, false}, {155, false}, {142, true}, {142, false}, {152, true}, {152, false}, {143, true}, {143, false}, {153, true}, {153, false}, {156, true}, {156, false}, {156, false}, {157, true}, {157, false}, {157, false}, {158, true}, {158, false}, {158, false}, {159, true}, {159, false}, {159, false}, {119, true}, {119, false}, {120, true}, {120, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {127, true}, {127, false}, {128, true}, {128, false}, {129, true}, {129, false}, {77, true}, {77, false}, {144, true}, {144, false}, {78, true}, {78, false}, {145, true}, {145, false}, {79, true}, {79, false}, {146, true}, {146, false}, {80, true}, {80, false}, {147, true}, {147, false}, {148, true}, {148, false}, {149, true}, {149, false}, {150, true}, {150, false}, {154, true}, {154, false}, {155, true}, {155, false}, {156, true}, {156, false}, {157, true}, {157, false}, {158, true}, {158, false}, {159, true}, {159, false}, {160, true}, {160, false}, {160, false}, {161, true}, {161, false}, {161, false}, {81, true}, {81, false}, {151, true}, {151, false}, {162, true}, {162, false}, {162, false}, {163, true}, {163, false}, {163, false}, {164, true}, {164, false}, {164, false}, {165, true}, {165, false}, {165, false}, {166, true}, {166, false}, {166, false}, {167, true}, {167, false}, {167, false}, {82, true}, {82, false}, {152, true}, {152, false}, {160, true}, {160, false}, {153, true}, {153, false}, {161, true}, {161, false}, {162, true}, {162, false}, {168, true}, {168, false}, {168, false}, {163, true}, {163, false}, {169, true}, {169, false}, {169, false}, {164, true}, {164, false}, {170, true}, {170, false}, {170, false}, {165, true}, {165, false}, {171, true}, {171, false}, {171, false}, {166, true}, {166, false}, {167, true}, {167, false}, {172, true}, {172, false}, {172, false}, {83, true}, {83, false}, {173, true}, {173, false}, {173, false}, {84, true}, {84, false}, {174, true}, {174, false}, {174, false}, {85, true}, {85, false}, {175, true}, {175, false}, {175, false}, {86, true}, {86, false}, {168, true}, {168, false}, {87, true}, {87, false}, {169, true}, {169, false}, {88, true}, {88, false}, {170, true}, {170, false}, {171, true}, {171, false}, {130, true}, {130, false}, {89, true}, {89, false}, {172, true}, {172, false}, {90, true}, {90, false}, {131, true}, {131, false}, {91, true}, {91, false}, {132, true}, {132, false}, {92, true}, {92, false}, {133, true}, {133, false}, {93, true}, {93, false}, {154, true}, {154, false}, {94, true}, {94, false}, {155, true}, {155, false}, {95, true}, {95, false}, {156, true}, {156, false}, {157, true}, {157, false}, {158, true}, {158, false}, {159, true}, {159, false}, {173, true}, {173, false}, {174, true}, {174, false}, {96, true}, {96, false}, {134, true}, {134, false}, {97, true}, {97, false}, {135, true}, {135, false}, {98, true}, {98, false}, {136, true}, {136, false}, {99, true}, {99, false}, {137, true}, {137, false}, {100, true}, {100, false}, {138, true}, {138, false}, {101, true}, {101, false}, {102, true}, {102, false}, {103, true}, {103, false}, {139, true}, {139, false}, {140, true}, {140, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {163, true}, {163, false}, {164, true}, {164, false}, {165, true}, {165, false}, {141, true}, {141, false}, {166, true}, {166, false}, {142, true}, {142, false}, {104, true}, {104, false}, {143, true}, {143, false}, {167, true}, {167, false}, {168, true}, {168, false}, {169, true}, {169, false}, {170, true}, {170, false}, {171, true}, {171, false}, {175, true}, {175, false}, {172, true}, {172, false}, {176, true}, {176, false}, {176, false}, {177, true}, {177, false}, {177, false}, {178, true}, {178, false}, {178, false}, {179, true}, {179, false}, {179, false}, {105, true}, {105, false}, {180, true}, {180, false}, {180, false}, {106, true}, {106, false}, {181, true}, {181, false}, {181, false}, {107, true}, {107, false}, {108, true}, {108, false}, {109, true}, {109, false}, {110, true}, {110, false}, {111, true}, {111, false}, {144, true}, {144, false}, {145, true}, {145, false}, {146, true}, {146, false}, {147, true}, {147, false}, {148, true}, {148, false}, {149, true}, {149, false}, {150, true}, {150, false}, {173, true}, {173, false}, {174, true}, {174, false}, {176, true}, {176, false}, {177, true}, {177, false}, {178, true}, {178, false}, {179, true}, {179, false}, {180, true}, {180, false}, {112, true}, {112, false}, {0, true}, {0, false}, {151, true}, {151, false}, {1, true}, {1, false}, {181, true}, {181, false}, {2, true}, {2, false}, {182, true}, {182, false}, {182, false}, {3, true}, {3, false}, {183, true}, {183, false}, {183, false}, {4, true}, {4, false}, {184, true}, {184, false}, {184, false}, {5, true}, {5, false}, {185, true}, {185, false}, {185, false}, {6, true}, {6, false}, {152, true}, {152, false}, {7, true}, {7, false}, {153, true}, {153, false}, {8, true}, {8, false}, {113, true}, {113, false}, {9, true}, {9, false}, {186, true}, {186, false}, {186, false}, {10, true}, {10, false}, {114, true}, {114, false}, {11, true}, {11, false}, {175, true}, {175, false}, {12, true}, {12, false}, {182, true}, {182, false}, {13, true}, {13, false}, {183, true}, {183, false}, {14, true}, {14, false}, {184, true}, {184, false}, {15, true}, {15, false}, {185, true}, {185, false}, {16, true}, {16, false}, {186, true}, {186, false}, {17, true}, {17, false}, {187, true}, {187, false}, {187, false}, {18, true}, {18, false}, {115, true}, {115, false}, {19, true}, {19, false}, {188, true}, {188, false}, {188, false}, {20, true}, {20, false}, {189, true}, {189, false}, {189, false}, {21, true}, {21, false}, {190, true}, {190, false}, {190, false}, {22, true}, {22, false}, {191, true}, {191, false}, {191, false}, {23, true}, {23, false}, {192, true}, {192, false}, {192, false}, {24, true}, {24, false}, {193, true}, {193, false}, {193, false}, {25, true}, {25, false}, {187, true}, {187, false}, {26, true}, {26, false}, {154, true}, {154, false}, {27, true}, {27, false}, {155, true}, {155, false}, {28, true}, {28, false}, {156, true}, {156, false}, {29, true}, {29, false}, {116, true}, {116, false}, {30, true}, {30, false}, {117, true}, {117, false}, {31, true}, {31, false}, {118, true}, {118, false}, {32, true}, {32, false}, {33, true}, {33, false}, {157, true}, {157, false}, {34, true}, {34, false}, {158, true}, {158, false}, {35, true}, {35, false}, {159, true}, {159, false}, {36, true}, {36, false}, {176, true}, {176, false}, {37, true}, {37, false}, {177, true}, {177, false}, {38, true}, {38, false}, {178, true}, {178, false}, {39, true}, {39, false}, {119, true}, {119, false}, {40, true}, {40, false}, {120, true}, {120, false}, {41, true}, {41, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {127, true}, {127, false}, {128, true}, {128, false}, {129, true}, {129, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {163, true}, {163, false}, {164, true}, {164, false}, {42, true}, {42, false}, {165, true}, {165, false}, {43, true}, {43, false}, {166, true}, {166, false}, {44, true}, {44, false}, {167, true}, {167, false}, {45, true}, {45, false}, {168, true}, {168, false}, {46, true}, {46, false}, {169, true}, {169, false}, {47, true}, {47, false}, {170, true}, {170, false}, {48, true}, {48, false}, {171, true}, {171, false}, {49, true}, {49, false}, {172, true}, {172, false}, {50, true}, {50, false}, {179, true}, {179, false}, {180, true}, {180, false}, {181, true}, {181, false}, {182, true}, {182, false}, {173, true}, {173, false}, {174, true}, {174, false}, {183, true}, {183, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {187, true}, {187, false}, {188, true}, {188, false}, {189, true}, {189, false}, {190, true}, {190, false}, {51, true}, {51, false}, {191, true}, {191, false}, {52, true}, {52, false}, {192, true}, {192, false}, {53, true}, {53, false}, {193, true}, {193, false}, {54, true}, {54, false}, {194, true}, {194, false}, {194, false}, {55, true}, {55, false}, {195, true}, {195, false}, {195, false}, {56, true}, {56, false}, {196, true}, {196, false}, {196, false}, {57, true}, {57, false}, {197, true}, {197, false}, {197, false}, {58, true}, {58, false}, {198, true}, {198, false}, {198, false}, {199, true}, {199, false}, {199, false}, {175, true}, {175, false}, {130, true}, {130, false}, {194, true}, {194, false}, {195, true}, {195, false}, {131, true}, {131, false}, {196, true}, {196, false}, {132, true}, {132, false}, {197, true}, {197, false}, {133, true}, {133, false}, {59, true}, {59, false}, {198, true}, {198, false}, {60, true}, {60, false}, {199, true}, {199, false}, {61, true}, {61, false}, {62, true}, {62, false}, {63, true}, {63, false}, {64, true}, {64, false}, {65, true}, {65, false}, {66, true}, {66, false}, {134, true}, {134, false}, {67, true}, {67, false}, {135, true}, {135, false}, {136, true}, {136, false}, {137, true}, {137, false}, {138, true}, {138, false}, {139, true}, {139, false}, {140, true}, {140, false}, {68, true}, {68, false}, {188, true}, {188, false}, {69, true}, {69, false}, {189, true}, {189, false}, {70, true}, {70, false}, {190, true}, {190, false}, {71, true}, {71, false}, {141, true}, {141, false}, {72, true}, {72, false}, {142, true}, {142, false}, {191, true}, {191, false}, {143, true}, {143, false}, {73, true}, {73, false}, {176, true}, {176, false}, {74, true}, {74, false}, {177, true}, {177, false}, {178, true}, {178, false}, {75, true}, {75, false}, {192, true}, {192, false}, {76, true}, {76, false}, {193, true}, {193, false}, {194, true}, {194, false}, {195, true}, {195, false}, {196, true}, {196, false}, {197, true}, {197, false}, {198, true}, {198, false}, {199, true}, {199, false}, {144, true}, {144, false}, {145, true}, {145, false}, {146, true}, {146, false}, {147, true}, {147, false}, {148, true}, {148, false}, {149, true}, {149, false}, {77, true}, {77, false}, {150, true}, {150, false}, {78, true}, {78, false}, {79, true}, {79, false}, {80, true}, {80, false}, {151, true}, {151, false}, {179, true}, {179, false}, {180, true}, {180, false}, {181, true}, {181, false}, {182, true}, {182, false}, {152, true}, {152, false}, {81, true}, {81, false}, {153, true}, {153, false}, {183, true}, {183, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {187, true}, {187, false}, {82, true}, {82, false}, {83, true}, {83, false}, {84, true}, {84, false}, {85, true}, {85, false}, {86, true}, {86, false}, {87, true}, {87, false}, {154, true}, {154, false}, {88, true}, {88, false}, {155, true}, {155, false}, {156, true}, {156, false}, {89, true}, {89, false}, {90, true}, {90, false}, {91, true}, {91, false}, {92, true}, {92, false}, {93, true}, {93, false}, {157, true}, {157, false}, {94, true}, {94, false}, {158, true}, {158, false}, {95, true}, {95, false}, {159, true}, {159, false}, {96, true}, {96, false}, {97, true}, {97, false}, {98, true}, {98, false}, {188, true}, {188, false}, {99, true}, {99, false}, {189, true}, {189, false}, {100, true}, {100, false}, {190, true}, {190, false}, {101, true}, {101, false}, {102, true}, {102, false}, {103, true}, {103, false}, {191, true}, {191, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {163, true}, {163, false}, {164, true}, {164, false}, {192, true}, {192, false}, {165, true}, {165, false}, {193, true}, {193, false}, {166, true}, {166, false}, {194, true}, {194, false}, {104, true}, {104, false}, {167, true}, {167, false}, {168, true}, {168, false}, {169, true}, {169, false}, {195, true}, {195, false}, {170, true}, {170, false}, {196, true}, {196, false}, {171, true}, {171, false}, {197, true}, {197, false}, {172, true}, {172, false}, {198, true}, {198, false}, {199, true}, {199, false}, {173, true}, {173, false}, {174, true}, {174, false}, {105, true}, {105, false}, {106, true}, {106, false}, {107, true}, {107, false}, {108, true}, {108, false}, {109, true}, {109, false}, {110, true}, {110, false}, {111, true}, {111, false}, {112, true}, {112, false}, {175, true}, {175, false}, {113, true}, {113, false}, {114, true}, {114, false}, {115, true}, {115, false}, {176, true}, {176, false}, {116, true}, {116, false}, {177, true}, {177, false}, {117, true}, {117, false}, {178, true}, {178, false}, {118, true}, {118, false}, {119, true}, {119, false}, {120, true}, {120, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {127, true}, {127, false}, {128, true}, {128, false}, {129, true}, {129, false}, {179, true}, {179, false}, {180, true}, {180, false}, {181, true}, {181, false}, {182, true}, {182, false}, {183, true}, {183, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {187, true}, {187, false}, {130, true}, {130, false}, {131, true}, {131, false}, {132, true}, {132, false}, {133, true}, {133, false}, {0, true}, {0, false}, {134, true}, {134, false}, {1, true}, {1, false}, {135, true}, {135, false}, {2, true}, {2, false}, {136, true}, {136, false}, {3, true}, {3, false}, {137, true}, {137, false}, {4, true}, {4, false}, {138, true}, {138, false}, {5, true}, {5, false}, {139, true}, {139, false}, {6, true}, {6, false}, {140, true}, {140, false}, {7, true}, {7, false}, {188, true}, {188, false}, {8, true}, {8, false}, {141, true}, {141, false}, {9, true}, {9, false}, {142, true}, {142, false}, {10, true}, {10, false}, {143, true}, {143, false}, {11, true}, {11, false}, {189, true}, {189, false}, {12, true}, {12, false}, {190, true}, {190, false}, {13, true}, {13, false}, {191, true}, {191, false}, {14, true}, {14, false}, {192, true}, {192, false}, {15, true}, {15, false}, {193, true}, {193, false}, {16, true}, {16, false}, {194, true}, {194, false}, {17, true}, {17, false}, {195, true}, {195, false}, {18, true}, {18, false}, {196, true}, {196, false}, {19, true}, {19, false}, {197, true}, {197, false}, {20, true}, {20, false}, {198, true}, {198, false}, {21, true}, {21, false}, {199, true}, {199, false}, {22, true}, {22, false}, {23, true}, {23, false}, {24, true}, {24, false}, {144, true}, {144, false}, {25, true}, {25, false}, {145, true}, {145, false}, {26, true}, {26, false}, {146, true}, {146, false}, {27, true}, {27, false}, {147, true}, {147, false}, {28, true}, {28, false}, {148, true}, {148, false}, {29, true}, {29, false}, {149, true}, {149, false}, {30, true}, {30, false}, {150, true}, {150, false}, {31, true}, {31, false}, {32, true}, {32, false}, {33, true}, {33, false}, {151, true}, {151, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {37, true}, {37, false}, {152, true}, {152, false}, {38, true}, {38, false}, {153, true}, {153, false}, {39, true}, {39, false}, {40, true}, {40, false}, {41, true}, {41, false}, {42, true}, {42, false}, {43, true}, {43, false}, {44, true}, {44, false}, {45, true}, {45, false}, {46, true}, {46, false}, {47, true}, {47, false}, {48, true}, {48, false}, {49, true}, {49, false}, {154, true}, {154, false}, {50, true}, {50, false}, {155, true}, {155, false}, {156, true}, {156, false}, {157, true}, {157, false}, {158, true}, {158, false}, {159, true}, {159, false}, {51, true}, {51, false}, {52, true}, {52, false}, {53, true}, {53, false}, {54, true}, {54, false}, {55, true}, {55, false}, {56, true}, {56, false}, {57, true}, {57, false}, {58, true}, {58, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {163, true}, {163, false}, {164, true}, {164, false}, {165, true}, {165, false}, {166, true}, {166, false}, {59, true}, {59, false}, {60, true}, {60, false}, {167, true}, {167, false}, {61, true}, {61, false}, {168, true}, {168, false}, {62, true}, {62, false}, {169, true}, {169, false}, {63, true}, {63, false}, {170, true}, {170, false}, {64, true}, {64, false}, {171, true}, {171, false}, {65, true}, {65, false}, {172, true}, {172, false}, {66, true}, {66, false}, {173, true}, {173, false}, {67, true}, {67, false}, {174, true}, {174, false}, {68, true}, {68, false}, {69, true}, {69, false}, {70, true}, {70, false}, {71, true}, {71, false}, {72, true}, {72, false}, {73, true}, {73, false}, {74, true}, {74, false}, {75, true}, {75, false}, {175, true}, {175, false}, {76, true}, {76, false}, {77, true}, {77, false}, {78, true}, {78, false}, {79, true}, {79, false}, {80, true}, {80, false}, {81, true}, {81, false}, {176, true}, {176, false}, {177, true}, {177, false}, {178, true}, {178, false}, {82, true}, {82, false}, {83, true}, {83, false}, {84, true}, {84, false}, {85, true}, {85, false}, {86, true}, {86, false}, {87, true}, {87, false}, {88, true}, {88, false}, {89, true}, {89, false}, {90, true}, {90, false}, {91, true}, {91, false}, {179, true}, {179, false}, {92, true}, {92, false}, {180, true}, {180, false}, {93, true}, {93, false}, {181, true}, {181, false}, {94, true}, {94, false}, {182, true}, {182, false}, {95, true}, {95, false}, {183, true}, {183, false}, {184, true}, {184, false}, {185, true}, {185, false}, {186, true}, {186, false}, {187, true}, {187, false}, {96, true}, {96, false}, {97, true}, {97, false}, {98, true}, {98, false}, {99, true}, {99, false}, {100, true}, {100, false}, {101, true}, {101, false}, {102, true}, {102, false}, {103, true}, {103, false}, {104, true}, {104, false}, {105, true}, {105, false}, {106, true}, {106, false}, {107, true}, {107, false}, {108, true}, {108, false}, {109, true}, {109, false}, {110, true}, {110, false}, {111, true}, {111, false}, {188, true}, {188, false}, {112, true}, {112, false}, {189, true}, {189, false}, {190, true}, {190, false}, {191, true}, {191, false}, {192, true}, {192, false}, {193, true}, {193, false}, {113, true}, {113, false}, {194, true}, {194, false}, {195, true}, {195, false}, {114, true}, {114, false}, {196, true}, {196, false}, {197, true}, {197, false}, {198, true}, {198, false}, {199, true}, {199, false}, {115, true}, {115, false}, {116, true}, {116, false}, {117, true}, {117, false}, {118, true}, {118, false}, {119, true}, {119, false}, {120, true}, {120, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {127, true}, {127, false}, {128, true}, {128, false}, {129, true}, {129, false}, {130, true}, {130, false}, {131, true}, {131, false}, {132, true}, {132, false}, {133, true}, {133, false}, {134, true}, {134, false}, {135, true}, {135, false}, {136, true}, {136, false}, {137, true}, {137, false}, {138, true}, {138, false}, {139, true}, {139, false}, {140, true}, {140, false}, {141, true}, {141, false}, {142, true}, {142, false}, {143, true}, {143, false}, {144, true}, {144, false}, {145, true}, {145, false}, {146, true}, {146, false}, {147, true}, {147, false}, {148, true}, {148, false}, {149, true}, {149, false}, {150, true}, {150, false}, {151, true}, {151, false}, {152, true}, {152, false}, {153, true}, {153, false}, {154, true}, {154, false}, {155, true}, {155, false}, {156, true}, {156, false}, {157, true}, {157, false}, {158, true}, {158, false}, {159, true}, {159, false}, {160, true}, {160, false}, {161, true}, {161, false}, {162, true}, {162, false}, {163, true}, {163, false}, {164, true}, {164, false}, {165, true}, {165, false}, {166, true}, {166, false}, {167, true}, {167, false}, {168, true}, {168, false}, {169, true}, {169, false}, {170, true}, {170, false}, {171, true}, {171, false}, {172, true}, {172, false}, {173, true}, {173, false}, {174, true}, {174, false}, {0, true}, {0, false}, {175, true}, {175, false}, {1, true}, {1, false}, {2, true}, {2, false}, {3, true}, {3, false}, {4, true}, {4, false}, {5, true}, {5, false}, {6, true}, {6, false}, {7, true}, {7, false}, {8, true}, {8, false}, {9, true}, {9, false}, {10, true}, {10, false}, {11, true}, {11, false}, {12, true}, {12, false}, {13, true}, {13, false}, {14, true}, {14, false}, {15, true}, {15, false}, {16, true}, {16, false}, {17, true}, {17, false}, {18, true}, {18, false}, {19, true}, {19, false}, {20, true}, {20, false}, {21, true}, {21, false}, {22, true}, {22, false}, {23, true}, {23, false}, {24, true}, {24, false}, {25, true}, {25, false}, {26, true}, {26, false}, {27, true}, {27, false}, {176, true}, {176, false}, {28, true}, {28, false}, {177, true}, {177, false}, {29, true}, {29, false}, {178, true}, {178, false}, {30, true}, {30, false}, {31, true}, {31, false}, {32, true}, {32, false}, {33, true}, {33, false}, {34, true}, {34, false}, {35, true}, {35, false}, {36, true}, {36, false}, {37, true}, {37, false}, {38, true}, {38, false}, {39, true}, {39, false}, {40, true}, {40, false}, {41, true}, {41, false}, {42, true}, {42, false}, {179, true}, {179, false}, {43, true}, {43, false}, {180, true}, {180, false}, {44, true}, {44, false}, {181, true}, {181, false}, {45, true}, {45, false}, {182, true}, {182, false}, {46, true}, {46, false}, {183, true}, {183, false}, {47, true}, {47, false}, {184, true}, {184, false}, {48, true}, {48, false}, {185, true}, {185, false}, {49, true}, {49, false}, {186, true}, {186, false}, {50, true}, {50, false}, {187, true}, {187, false}, {51, true}, {51, false}, {52, true}, {52, false}, {53, true}, {53, false}, {54, true}, {54, false}, {55, true}, {55, false}, {56, true}, {56, false}, {57, true}, {57, false}, {58, true}, {58, false}, {59, true}, {59, false}, {60, true}, {60, false}, {61, true}, {61, false}, {62, true}, {62, false}, {63, true}, {63, false}, {64, true}, {64, false}, {65, true}, {65, false}, {66, true}, {66, false}, {67, true}, {67, false}, {188, true}, {188, false}, {68, true}, {68, false}, {189, true}, {189, false}, {69, true}, {69, false}, {190, true}, {190, false}, {70, true}, {70, false}, {191, true}, {191, false}, {71, true}, {71, false}, {192, true}, {192, false}, {72, true}, {72, false}, {193, true}, {193, false}, {194, true}, {194, false}, {73, true}, {73, false}, {195, true}, {195, false}, {74, true}, {74, false}, {196, true}, {196, false}, {197, true}, {197, false}, {75, true}, {75, false}, {198, true}, {198, false}, {76, true}, {76, false}, {199, true}, {199, false}, {77, true}, {77, false}, {78, true}, {78, false}, {79, true}, {79, false}, {80, true}, {80, false}, {81, true}, {81, false}, {82, true}, {82, false}, {83, true}, {83, false}, {84, true}, {84, false}, {85, true}, {85, false}, {86, true}, {86, false}, {87, true}, {87, false}, {88, true}, {88, false}, {89, true}, {89, false}, {90, true}, {90, false}, {91, true}, {91, false}, {92, true}, {92, false}, {93, true}, {93, false}, {94, true}, {94, false}, {95, true}, {95, false}, {96, true}, {96, false}, {97, true}, {97, false}, {98, true}, {98, false}, {99, true}, {99, false}, {100, true}, {100, false}, {101, true}, {101, false}, {102, true}, {102, false}, {103, true}, {103, false}, {104, true}, {104, false}, {105, true}, {105, false}, {106, true}, {106, false}, {107, true}, {107, false}, {108, true}, {108, false}, {109, true}, {109, false}, {110, true}, {110, false}, {111, true}, {111, false}, {112, true}, {112, false}, {113, true}, {113, false}, {114, true}, {114, false}, {115, true}, {115, false}, {116, true}, {116, false}, {117, true}, {117, false}, {118, true}, {118, false}, {119, true}, {119, false}, {120, true}, {120, false}, {121, true}, {121, false}, {122, true}, {122, false}, {123, true}, {123, false}, {124, true}, {124, false}, {125, true}, {125, false}, {126, true}, {126, false}, {127, true}, {127, false}, {128, true}, {128, false}, {129, true}, {129, false}, {130, true}, {130, false}, {131, true}, {131, false}, {132, true}, {132, false}, {133, true}, {133, false}, {134, true}, {134, false}, {135, true}, {135, false}, {136, true}, {136, false}, {137, true}, {137, false}, {138, true}, {138, false}, {139, true}, {139, false}, {140, true}, {140, false}, {141, true}, {141, false}, {142, true}, {142, false}, {143, true}, {143, false}, {144, true}, {144, false}, {145, true}, {145, false}, {146, true}, {146, false}, {147, true}, {147, false}, {148, true}, {148, false}, {149, true}, {149, false}, {150, true}, {150, false}, {151, true}, {151, false}, {152, true}, {152, false}, {153, true}, {153, false}, {154, true}, {154, false}}
</pre>
		
		<pre class="file" id="file19" style="display: none">package config

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "github.com/gomiddleware/realip"
        _ "github.com/lib/pq"
        "golang.org/x/time/rate"
        "net/http"
        "sync"
        "time"
)

// Config Update the config struct to hold the SMTP server settings.
type Config struct {
        Port            string
        Env             string
        CtxTimeout      time.Duration
        JWTDuration     time.Duration
        PhrasePause     int
        AudioPattern    int
        MaxNumPhrases   int
        TTSBasePath     string
        FileUploadLimit int64
        Db              struct {
                Dsn          string
                MaxOpenConns int
                MaxIdleConns int
                MaxIdleTime  string
        }
        Limiter struct {
                Enabled bool
                Rps     float64
                Burst   int
        }
}

func SetConfigs(config *Config) error <span class="cov8" title="1">{

        // get port and debug from commandline flags... if not present use defaults
        flag.StringVar(&amp;config.Port, "port", "8080", "API server port")

        flag.StringVar(&amp;config.Env, "env", "development", "Environment (development|staging|cloud)")
        flag.DurationVar(&amp;config.CtxTimeout, "ctx-timeout", 3*time.Second, "Context timeout for db queries in seconds")

        flag.StringVar(&amp;config.Db.Dsn, "db-dsn", "", "PostgreSQL DSN")

        flag.IntVar(&amp;config.Db.MaxOpenConns, "db-max-open-conns", 25, "PostgreSQL max open connections")
        flag.IntVar(&amp;config.Db.MaxIdleConns, "db-max-idle-conns", 25, "PostgreSQL max idle connections")
        flag.StringVar(&amp;config.Db.MaxIdleTime, "db-max-idle-time", "15m", "PostgreSQL max connection idle time")

        flag.BoolVar(&amp;config.Limiter.Enabled, "limiter-enabled", true, "Enable rate limiter")
        flag.Float64Var(&amp;config.Limiter.Rps, "limiter-rps", 2, "Rate limiter maximum requests per second")
        flag.IntVar(&amp;config.Limiter.Burst, "limiter-burst", 4, "Rate limiter maximum burst")

        flag.StringVar(&amp;config.TTSBasePath, "tts-base-path", "/tmp/audio/", "text-to-speech base path temporary storage of mp3 audio files")

        flag.DurationVar(&amp;config.JWTDuration, "jwt-duration", 24, "JWT duration in hours")
        flag.Int64Var(&amp;config.FileUploadLimit, "upload-size-limit", 8*8000, "File upload size limit in KB (default is 8)")
        flag.IntVar(&amp;config.PhrasePause, "phrase-pause", 4, "Pause in seconds between phrases (must be between 3 and 10)'")
        flag.IntVar(&amp;config.MaxNumPhrases, "maximum-number-phrases", 50, "Maximum number of phrases to be turned into audio files")
        flag.IntVar(&amp;config.AudioPattern, "audio-pattern", 1, "Audio pattern to be used in constructing mp3's {1: standard, 2: advanced, 3: review}")

        if !isValidPause(config.PhrasePause) </span><span class="cov0" title="0">{
                return errors.New("invalid pause value (must be between 3 and 10)")
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func isValidPause(port int) bool <span class="cov8" title="1">{
        return port &gt;= 3 &amp;&amp; port &lt;= 10
}</span>

func (cfg *Config) RateLimit(next http.Handler) http.Handler <span class="cov0" title="0">{
        // Define a client struct to hold the rate limiter and last seen time for each
        // client.
        type client struct {
                limiter  *rate.Limiter
                lastSeen time.Time
        }

        var (
                mu sync.Mutex
                // Update the map so the values are pointers to a client struct.
                clients = make(map[string]*client)
        )

        // Launch a background goroutine which removes old entries from the clients map once
        // every minute.
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(time.Minute)

                        // Lock the mutex to prevent any rate limiter checks from happening while
                        // the cleanup is taking place.
                        mu.Lock()

                        // Loop through all clients. If they haven't been seen within the last three
                        // minutes, delete the corresponding entry from the map.
                        for ip, client := range clients </span><span class="cov0" title="0">{
                                if time.Since(client.lastSeen) &gt; 3*time.Minute </span><span class="cov0" title="0">{
                                        delete(clients, ip)
                                }</span>
                        }

                        // Importantly, unlock the mutex when the cleanup is complete.
                        <span class="cov0" title="0">mu.Unlock()</span>
                }
        }()

        <span class="cov0" title="0">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if cfg.Limiter.Enabled </span><span class="cov0" title="0">{
                        // Use the realip.FromRequest() function to get the client's real IP address.
                        ip := realip.RealIpFromRequest(r)

                        mu.Lock()

                        if _, found := clients[ip]; !found </span><span class="cov0" title="0">{
                                clients[ip] = &amp;client{
                                        limiter: rate.NewLimiter(rate.Limit(cfg.Limiter.Rps), cfg.Limiter.Burst),
                                }
                        }</span>

                        <span class="cov0" title="0">clients[ip].lastSeen = time.Now()

                        if !clients[ip].limiter.Allow() </span><span class="cov0" title="0">{
                                mu.Unlock()
                                rateLimitExceededResponse(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">mu.Unlock()</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func rateLimitExceededResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        message := "rate limit exceeded"
        type envelope map[string]interface{}
        env := envelope{"error": message}

        js, err := json.MarshalIndent(env, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("error in rateLimitExceededResponse: %s, %s, %s", err, r.Method, r.URL.String())
                w.WriteHeader(http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusTooManyRequests)
        _, err = w.Write(js)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("error in rateLimitExceededResponse Write: %s, %s, %s", err, r.Method, r.URL.String())
        }</span>
}

func (cfg *Config) OpenDB() (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", cfg.Db.Dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the maximum number of open (in-use + idle) connections in the pool. Note that
        // passing a value less than or equal to 0 will mean there is no limit.
        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.Db.MaxOpenConns)

        // Set the maximum number of idle connections in the pool. Again, passing a value
        // less than or equal to 0 will mean there is no limit.
        db.SetMaxIdleConns(cfg.Db.MaxIdleConns)

        // Use the time.ParseDuration() function to convert the idle timeout duration string
        // to a time.Duration type.
        duration, err := time.ParseDuration(cfg.Db.MaxIdleTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set the maximum idle timeout.
        <span class="cov0" title="0">db.SetConnMaxIdleTime(duration)

        ctx, cancel := context.WithTimeout(context.Background(), cfg.CtxTimeout)
        defer cancel()
        err = db.PingContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/audio/audiofile/audiofile.go
//
// Generated by this command:
//
//        mockgen -package mocka -destination=internal/mock/audiofile/audiofile.go -source=internal/audio/audiofile/audiofile.go
//

// Package mocka is a generated GoMock package.
package mocka

import (
        iter "iter"
        multipart "mime/multipart"
        os "os"
        exec "os/exec"
        reflect "reflect"

        echo "github.com/labstack/echo/v4"
        gomock "go.uber.org/mock/gomock"
        db "talkliketv.click/tltv/db/sqlc"
)

// MockAudioFileX is a mock of AudioFileX interface.
type MockAudioFileX struct {
        ctrl     *gomock.Controller
        recorder *MockAudioFileXMockRecorder
        isgomock struct{}
}

// MockAudioFileXMockRecorder is the mock recorder for MockAudioFileX.
type MockAudioFileXMockRecorder struct {
        mock *MockAudioFileX
}

// NewMockAudioFileX creates a new mock instance.
func NewMockAudioFileX(ctrl *gomock.Controller) *MockAudioFileX <span class="cov8" title="1">{
        mock := &amp;MockAudioFileX{ctrl: ctrl}
        mock.recorder = &amp;MockAudioFileXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAudioFileX) EXPECT() *MockAudioFileXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// BuildAudioInputFiles mocks base method.
func (m *MockAudioFileX) BuildAudioInputFiles(arg0 echo.Context, arg1 []int64, arg2 db.Title, arg3, arg4, arg5, arg6 string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BuildAudioInputFiles", arg0, arg1, arg2, arg3, arg4, arg5, arg6)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// BuildAudioInputFiles indicates an expected call of BuildAudioInputFiles.
func (mr *MockAudioFileXMockRecorder) BuildAudioInputFiles(arg0, arg1, arg2, arg3, arg4, arg5, arg6 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildAudioInputFiles", reflect.TypeOf((*MockAudioFileX)(nil).BuildAudioInputFiles), arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}</span>

// CreateMp3Zip mocks base method.
func (m *MockAudioFileX) CreateMp3Zip(arg0 echo.Context, arg1 db.Title, arg2 string) (*os.File, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateMp3Zip", arg0, arg1, arg2)
        ret0, _ := ret[0].(*os.File)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateMp3Zip indicates an expected call of CreateMp3Zip.
func (mr *MockAudioFileXMockRecorder) CreateMp3Zip(arg0, arg1, arg2 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMp3Zip", reflect.TypeOf((*MockAudioFileX)(nil).CreateMp3Zip), arg0, arg1, arg2)
}</span>

// CreatePhrasesZip mocks base method.
func (m *MockAudioFileX) CreatePhrasesZip(arg0 echo.Context, arg1 iter.Seq[[]string], arg2, arg3 string) (*os.File, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePhrasesZip", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].(*os.File)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreatePhrasesZip indicates an expected call of CreatePhrasesZip.
func (mr *MockAudioFileXMockRecorder) CreatePhrasesZip(arg0, arg1, arg2, arg3 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePhrasesZip", reflect.TypeOf((*MockAudioFileX)(nil).CreatePhrasesZip), arg0, arg1, arg2, arg3)
}</span>

// GetLines mocks base method.
func (m *MockAudioFileX) GetLines(arg0 echo.Context, arg1 multipart.File) ([]string, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLines", arg0, arg1)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetLines indicates an expected call of GetLines.
func (mr *MockAudioFileXMockRecorder) GetLines(arg0, arg1 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLines", reflect.TypeOf((*MockAudioFileX)(nil).GetLines), arg0, arg1)
}</span>

// MockcmdRunnerX is a mock of cmdRunnerX interface.
type MockcmdRunnerX struct {
        ctrl     *gomock.Controller
        recorder *MockcmdRunnerXMockRecorder
        isgomock struct{}
}

// MockcmdRunnerXMockRecorder is the mock recorder for MockcmdRunnerX.
type MockcmdRunnerXMockRecorder struct {
        mock *MockcmdRunnerX
}

// NewMockcmdRunnerX creates a new mock instance.
func NewMockcmdRunnerX(ctrl *gomock.Controller) *MockcmdRunnerX <span class="cov8" title="1">{
        mock := &amp;MockcmdRunnerX{ctrl: ctrl}
        mock.recorder = &amp;MockcmdRunnerXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcmdRunnerX) EXPECT() *MockcmdRunnerXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CombinedOutput mocks base method.
func (m *MockcmdRunnerX) CombinedOutput(cmd *exec.Cmd) ([]byte, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CombinedOutput", cmd)
        ret0, _ := ret[0].([]byte)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CombinedOutput indicates an expected call of CombinedOutput.
func (mr *MockcmdRunnerXMockRecorder) CombinedOutput(cmd any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CombinedOutput", reflect.TypeOf((*MockcmdRunnerX)(nil).CombinedOutput), cmd)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: talkliketv.click/tltv/db/sqlc (interfaces: Querier)
//
// Generated by this command:
//
//        mockgen -package mockdb -destination internal/mock/db/store.go talkliketv.click/tltv/db/sqlc Querier
//

// Package mockdb is a generated GoMock package.
package mockdb

import (
        context "context"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
        db "talkliketv.click/tltv/db/sqlc"
)

// MockQuerier is a mock of Querier interface.
type MockQuerier struct {
        ctrl     *gomock.Controller
        recorder *MockQuerierMockRecorder
        isgomock struct{}
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder struct {
        mock *MockQuerier
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier(ctrl *gomock.Controller) *MockQuerier <span class="cov8" title="1">{
        mock := &amp;MockQuerier{ctrl: ctrl}
        mock.recorder = &amp;MockQuerierMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier) EXPECT() *MockQuerierMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// DeleteTitleById mocks base method.
func (m *MockQuerier) DeleteTitleById(ctx context.Context, id int64) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteTitleById", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteTitleById indicates an expected call of DeleteTitleById.
func (mr *MockQuerierMockRecorder) DeleteTitleById(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTitleById", reflect.TypeOf((*MockQuerier)(nil).DeleteTitleById), ctx, id)
}</span>

// DeleteTranslatesByLanguageId mocks base method.
func (m *MockQuerier) DeleteTranslatesByLanguageId(ctx context.Context, arg db.DeleteTranslatesByLanguageIdParams) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteTranslatesByLanguageId", ctx, arg)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteTranslatesByLanguageId indicates an expected call of DeleteTranslatesByLanguageId.
func (mr *MockQuerierMockRecorder) DeleteTranslatesByLanguageId(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTranslatesByLanguageId", reflect.TypeOf((*MockQuerier)(nil).DeleteTranslatesByLanguageId), ctx, arg)
}</span>

// DeleteUserById mocks base method.
func (m *MockQuerier) DeleteUserById(ctx context.Context, id int64) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUserById", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUserById indicates an expected call of DeleteUserById.
func (mr *MockQuerierMockRecorder) DeleteUserById(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUserById", reflect.TypeOf((*MockQuerier)(nil).DeleteUserById), ctx, id)
}</span>

// DeleteUserPermissionById mocks base method.
func (m *MockQuerier) DeleteUserPermissionById(ctx context.Context, arg db.DeleteUserPermissionByIdParams) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUserPermissionById", ctx, arg)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUserPermissionById indicates an expected call of DeleteUserPermissionById.
func (mr *MockQuerierMockRecorder) DeleteUserPermissionById(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUserPermissionById", reflect.TypeOf((*MockQuerier)(nil).DeleteUserPermissionById), ctx, arg)
}</span>

// InsertPhrases mocks base method.
func (m *MockQuerier) InsertPhrases(ctx context.Context, titleID int64) (db.Phrase, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertPhrases", ctx, titleID)
        ret0, _ := ret[0].(db.Phrase)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertPhrases indicates an expected call of InsertPhrases.
func (mr *MockQuerierMockRecorder) InsertPhrases(ctx, titleID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertPhrases", reflect.TypeOf((*MockQuerier)(nil).InsertPhrases), ctx, titleID)
}</span>

// InsertTitle mocks base method.
func (m *MockQuerier) InsertTitle(ctx context.Context, arg db.InsertTitleParams) (db.Title, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertTitle", ctx, arg)
        ret0, _ := ret[0].(db.Title)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertTitle indicates an expected call of InsertTitle.
func (mr *MockQuerierMockRecorder) InsertTitle(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertTitle", reflect.TypeOf((*MockQuerier)(nil).InsertTitle), ctx, arg)
}</span>

// InsertTranslates mocks base method.
func (m *MockQuerier) InsertTranslates(ctx context.Context, arg db.InsertTranslatesParams) (db.Translate, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertTranslates", ctx, arg)
        ret0, _ := ret[0].(db.Translate)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertTranslates indicates an expected call of InsertTranslates.
func (mr *MockQuerierMockRecorder) InsertTranslates(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertTranslates", reflect.TypeOf((*MockQuerier)(nil).InsertTranslates), ctx, arg)
}</span>

// InsertUser mocks base method.
func (m *MockQuerier) InsertUser(ctx context.Context, arg db.InsertUserParams) (db.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertUser", ctx, arg)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertUser indicates an expected call of InsertUser.
func (mr *MockQuerierMockRecorder) InsertUser(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertUser", reflect.TypeOf((*MockQuerier)(nil).InsertUser), ctx, arg)
}</span>

// InsertUserPermission mocks base method.
func (m *MockQuerier) InsertUserPermission(ctx context.Context, arg db.InsertUserPermissionParams) (db.UsersPermission, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertUserPermission", ctx, arg)
        ret0, _ := ret[0].(db.UsersPermission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertUserPermission indicates an expected call of InsertUserPermission.
func (mr *MockQuerierMockRecorder) InsertUserPermission(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertUserPermission", reflect.TypeOf((*MockQuerier)(nil).InsertUserPermission), ctx, arg)
}</span>

// ListLanguages mocks base method.
func (m *MockQuerier) ListLanguages(ctx context.Context) ([]db.Language, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListLanguages", ctx)
        ret0, _ := ret[0].([]db.Language)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListLanguages indicates an expected call of ListLanguages.
func (mr *MockQuerierMockRecorder) ListLanguages(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLanguages", reflect.TypeOf((*MockQuerier)(nil).ListLanguages), ctx)
}</span>

// ListLanguagesSimilar mocks base method.
func (m *MockQuerier) ListLanguagesSimilar(ctx context.Context, similarity string) ([]db.ListLanguagesSimilarRow, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListLanguagesSimilar", ctx, similarity)
        ret0, _ := ret[0].([]db.ListLanguagesSimilarRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListLanguagesSimilar indicates an expected call of ListLanguagesSimilar.
func (mr *MockQuerierMockRecorder) ListLanguagesSimilar(ctx, similarity any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLanguagesSimilar", reflect.TypeOf((*MockQuerier)(nil).ListLanguagesSimilar), ctx, similarity)
}</span>

// ListTitles mocks base method.
func (m *MockQuerier) ListTitles(ctx context.Context, arg db.ListTitlesParams) ([]db.ListTitlesRow, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListTitles", ctx, arg)
        ret0, _ := ret[0].([]db.ListTitlesRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListTitles indicates an expected call of ListTitles.
func (mr *MockQuerierMockRecorder) ListTitles(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTitles", reflect.TypeOf((*MockQuerier)(nil).ListTitles), ctx, arg)
}</span>

// ListTitlesByOgLanguage mocks base method.
func (m *MockQuerier) ListTitlesByOgLanguage(ctx context.Context, arg db.ListTitlesByOgLanguageParams) ([]db.ListTitlesByOgLanguageRow, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListTitlesByOgLanguage", ctx, arg)
        ret0, _ := ret[0].([]db.ListTitlesByOgLanguageRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListTitlesByOgLanguage indicates an expected call of ListTitlesByOgLanguage.
func (mr *MockQuerierMockRecorder) ListTitlesByOgLanguage(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTitlesByOgLanguage", reflect.TypeOf((*MockQuerier)(nil).ListTitlesByOgLanguage), ctx, arg)
}</span>

// ListVoices mocks base method.
func (m *MockQuerier) ListVoices(ctx context.Context) ([]db.Voice, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListVoices", ctx)
        ret0, _ := ret[0].([]db.Voice)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListVoices indicates an expected call of ListVoices.
func (mr *MockQuerierMockRecorder) ListVoices(ctx any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListVoices", reflect.TypeOf((*MockQuerier)(nil).ListVoices), ctx)
}</span>

// SelectExistsTranslates mocks base method.
func (m *MockQuerier) SelectExistsTranslates(ctx context.Context, arg db.SelectExistsTranslatesParams) (bool, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectExistsTranslates", ctx, arg)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectExistsTranslates indicates an expected call of SelectExistsTranslates.
func (mr *MockQuerierMockRecorder) SelectExistsTranslates(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectExistsTranslates", reflect.TypeOf((*MockQuerier)(nil).SelectExistsTranslates), ctx, arg)
}</span>

// SelectLanguagesById mocks base method.
func (m *MockQuerier) SelectLanguagesById(ctx context.Context, id int16) (db.Language, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectLanguagesById", ctx, id)
        ret0, _ := ret[0].(db.Language)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectLanguagesById indicates an expected call of SelectLanguagesById.
func (mr *MockQuerierMockRecorder) SelectLanguagesById(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectLanguagesById", reflect.TypeOf((*MockQuerier)(nil).SelectLanguagesById), ctx, id)
}</span>

// SelectPermissionByCode mocks base method.
func (m *MockQuerier) SelectPermissionByCode(ctx context.Context, code string) (db.Permission, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectPermissionByCode", ctx, code)
        ret0, _ := ret[0].(db.Permission)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectPermissionByCode indicates an expected call of SelectPermissionByCode.
func (mr *MockQuerierMockRecorder) SelectPermissionByCode(ctx, code any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectPermissionByCode", reflect.TypeOf((*MockQuerier)(nil).SelectPermissionByCode), ctx, code)
}</span>

// SelectPhraseIdsByTitleId mocks base method.
func (m *MockQuerier) SelectPhraseIdsByTitleId(ctx context.Context, titleID int64) ([]int64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectPhraseIdsByTitleId", ctx, titleID)
        ret0, _ := ret[0].([]int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectPhraseIdsByTitleId indicates an expected call of SelectPhraseIdsByTitleId.
func (mr *MockQuerierMockRecorder) SelectPhraseIdsByTitleId(ctx, titleID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectPhraseIdsByTitleId", reflect.TypeOf((*MockQuerier)(nil).SelectPhraseIdsByTitleId), ctx, titleID)
}</span>

// SelectTitleById mocks base method.
func (m *MockQuerier) SelectTitleById(ctx context.Context, id int64) (db.Title, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectTitleById", ctx, id)
        ret0, _ := ret[0].(db.Title)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectTitleById indicates an expected call of SelectTitleById.
func (mr *MockQuerierMockRecorder) SelectTitleById(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectTitleById", reflect.TypeOf((*MockQuerier)(nil).SelectTitleById), ctx, id)
}</span>

// SelectTranslatesByTitleIdLangId mocks base method.
func (m *MockQuerier) SelectTranslatesByTitleIdLangId(ctx context.Context, arg db.SelectTranslatesByTitleIdLangIdParams) ([]db.Translate, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectTranslatesByTitleIdLangId", ctx, arg)
        ret0, _ := ret[0].([]db.Translate)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectTranslatesByTitleIdLangId indicates an expected call of SelectTranslatesByTitleIdLangId.
func (mr *MockQuerierMockRecorder) SelectTranslatesByTitleIdLangId(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectTranslatesByTitleIdLangId", reflect.TypeOf((*MockQuerier)(nil).SelectTranslatesByTitleIdLangId), ctx, arg)
}</span>

// SelectTranslatesWithCorrect mocks base method.
func (m *MockQuerier) SelectTranslatesWithCorrect(ctx context.Context, arg db.SelectTranslatesWithCorrectParams) ([]db.SelectTranslatesWithCorrectRow, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectTranslatesWithCorrect", ctx, arg)
        ret0, _ := ret[0].([]db.SelectTranslatesWithCorrectRow)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectTranslatesWithCorrect indicates an expected call of SelectTranslatesWithCorrect.
func (mr *MockQuerierMockRecorder) SelectTranslatesWithCorrect(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectTranslatesWithCorrect", reflect.TypeOf((*MockQuerier)(nil).SelectTranslatesWithCorrect), ctx, arg)
}</span>

// SelectUserById mocks base method.
func (m *MockQuerier) SelectUserById(ctx context.Context, id int64) (db.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectUserById", ctx, id)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectUserById indicates an expected call of SelectUserById.
func (mr *MockQuerierMockRecorder) SelectUserById(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectUserById", reflect.TypeOf((*MockQuerier)(nil).SelectUserById), ctx, id)
}</span>

// SelectUserByName mocks base method.
func (m *MockQuerier) SelectUserByName(ctx context.Context, name string) (db.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectUserByName", ctx, name)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectUserByName indicates an expected call of SelectUserByName.
func (mr *MockQuerierMockRecorder) SelectUserByName(ctx, name any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectUserByName", reflect.TypeOf((*MockQuerier)(nil).SelectUserByName), ctx, name)
}</span>

// SelectUserPermissions mocks base method.
func (m *MockQuerier) SelectUserPermissions(ctx context.Context, userID int64) ([]string, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectUserPermissions", ctx, userID)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectUserPermissions indicates an expected call of SelectUserPermissions.
func (mr *MockQuerierMockRecorder) SelectUserPermissions(ctx, userID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectUserPermissions", reflect.TypeOf((*MockQuerier)(nil).SelectUserPermissions), ctx, userID)
}</span>

// SelectUsersPhrasesByCorrect mocks base method.
func (m *MockQuerier) SelectUsersPhrasesByCorrect(ctx context.Context, arg db.SelectUsersPhrasesByCorrectParams) ([]int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectUsersPhrasesByCorrect", ctx, arg)
        ret0, _ := ret[0].([]int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectUsersPhrasesByCorrect indicates an expected call of SelectUsersPhrasesByCorrect.
func (mr *MockQuerierMockRecorder) SelectUsersPhrasesByCorrect(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectUsersPhrasesByCorrect", reflect.TypeOf((*MockQuerier)(nil).SelectUsersPhrasesByCorrect), ctx, arg)
}</span>

// SelectUsersPhrasesByIds mocks base method.
func (m *MockQuerier) SelectUsersPhrasesByIds(ctx context.Context, arg db.SelectUsersPhrasesByIdsParams) (db.UsersPhrase, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectUsersPhrasesByIds", ctx, arg)
        ret0, _ := ret[0].(db.UsersPhrase)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectUsersPhrasesByIds indicates an expected call of SelectUsersPhrasesByIds.
func (mr *MockQuerierMockRecorder) SelectUsersPhrasesByIds(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectUsersPhrasesByIds", reflect.TypeOf((*MockQuerier)(nil).SelectUsersPhrasesByIds), ctx, arg)
}</span>

// SelectVoiceById mocks base method.
func (m *MockQuerier) SelectVoiceById(ctx context.Context, id int16) (db.Voice, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectVoiceById", ctx, id)
        ret0, _ := ret[0].(db.Voice)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectVoiceById indicates an expected call of SelectVoiceById.
func (mr *MockQuerierMockRecorder) SelectVoiceById(ctx, id any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectVoiceById", reflect.TypeOf((*MockQuerier)(nil).SelectVoiceById), ctx, id)
}</span>

// SelectVoicesByLanguageId mocks base method.
func (m *MockQuerier) SelectVoicesByLanguageId(ctx context.Context, languageID int16) ([]db.Voice, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SelectVoicesByLanguageId", ctx, languageID)
        ret0, _ := ret[0].([]db.Voice)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SelectVoicesByLanguageId indicates an expected call of SelectVoicesByLanguageId.
func (mr *MockQuerierMockRecorder) SelectVoicesByLanguageId(ctx, languageID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectVoicesByLanguageId", reflect.TypeOf((*MockQuerier)(nil).SelectVoicesByLanguageId), ctx, languageID)
}</span>

// UpdateUserById mocks base method.
func (m *MockQuerier) UpdateUserById(ctx context.Context, arg db.UpdateUserByIdParams) (db.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUserById", ctx, arg)
        ret0, _ := ret[0].(db.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUserById indicates an expected call of UpdateUserById.
func (mr *MockQuerierMockRecorder) UpdateUserById(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUserById", reflect.TypeOf((*MockQuerier)(nil).UpdateUserById), ctx, arg)
}</span>

// UpdateUsersPhrasesByThreeIds mocks base method.
func (m *MockQuerier) UpdateUsersPhrasesByThreeIds(ctx context.Context, arg db.UpdateUsersPhrasesByThreeIdsParams) (db.UsersPhrase, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUsersPhrasesByThreeIds", ctx, arg)
        ret0, _ := ret[0].(db.UsersPhrase)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUsersPhrasesByThreeIds indicates an expected call of UpdateUsersPhrasesByThreeIds.
func (mr *MockQuerierMockRecorder) UpdateUsersPhrasesByThreeIds(ctx, arg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUsersPhrasesByThreeIds", reflect.TypeOf((*MockQuerier)(nil).UpdateUsersPhrasesByThreeIds), ctx, arg)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/translates/translates.go
//
// Generated by this command:
//
//        mockgen -package mockt -destination=internal/mock/translates/translates.go -source=internal/translates/translates.go
//

// Package mockt is a generated GoMock package.
package mockt

import (
        context "context"
        reflect "reflect"

        texttospeechpb "cloud.google.com/go/texttospeech/apiv1/texttospeechpb"
        translate "cloud.google.com/go/translate"
        gax "github.com/googleapis/gax-go/v2"
        echo "github.com/labstack/echo/v4"
        gomock "go.uber.org/mock/gomock"
        language "golang.org/x/text/language"
        db "talkliketv.click/tltv/db/sqlc"
        util "talkliketv.click/tltv/internal/util"
)

// MockTranslateClientX is a mock of TranslateClientX interface.
type MockTranslateClientX struct {
        ctrl     *gomock.Controller
        recorder *MockTranslateClientXMockRecorder
        isgomock struct{}
}

// MockTranslateClientXMockRecorder is the mock recorder for MockTranslateClientX.
type MockTranslateClientXMockRecorder struct {
        mock *MockTranslateClientX
}

// NewMockTranslateClientX creates a new mock instance.
func NewMockTranslateClientX(ctrl *gomock.Controller) *MockTranslateClientX <span class="cov8" title="1">{
        mock := &amp;MockTranslateClientX{ctrl: ctrl}
        mock.recorder = &amp;MockTranslateClientXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTranslateClientX) EXPECT() *MockTranslateClientXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Translate mocks base method.
func (m *MockTranslateClientX) Translate(arg0 context.Context, arg1 []string, arg2 language.Tag, arg3 *translate.Options) ([]translate.Translation, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Translate", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].([]translate.Translation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Translate indicates an expected call of Translate.
func (mr *MockTranslateClientXMockRecorder) Translate(arg0, arg1, arg2, arg3 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Translate", reflect.TypeOf((*MockTranslateClientX)(nil).Translate), arg0, arg1, arg2, arg3)
}</span>

// MockTTSClientX is a mock of TTSClientX interface.
type MockTTSClientX struct {
        ctrl     *gomock.Controller
        recorder *MockTTSClientXMockRecorder
        isgomock struct{}
}

// MockTTSClientXMockRecorder is the mock recorder for MockTTSClientX.
type MockTTSClientXMockRecorder struct {
        mock *MockTTSClientX
}

// NewMockTTSClientX creates a new mock instance.
func NewMockTTSClientX(ctrl *gomock.Controller) *MockTTSClientX <span class="cov8" title="1">{
        mock := &amp;MockTTSClientX{ctrl: ctrl}
        mock.recorder = &amp;MockTTSClientXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTTSClientX) EXPECT() *MockTTSClientXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// SynthesizeSpeech mocks base method.
func (m *MockTTSClientX) SynthesizeSpeech(arg0 context.Context, arg1 *texttospeechpb.SynthesizeSpeechRequest, arg2 ...gax.CallOption) (*texttospeechpb.SynthesizeSpeechResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []any{arg0, arg1}
        for _, a := range arg2 </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "SynthesizeSpeech", varargs...)
        ret0, _ := ret[0].(*texttospeechpb.SynthesizeSpeechResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// SynthesizeSpeech indicates an expected call of SynthesizeSpeech.
func (mr *MockTTSClientXMockRecorder) SynthesizeSpeech(arg0, arg1 any, arg2 ...any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SynthesizeSpeech", reflect.TypeOf((*MockTTSClientX)(nil).SynthesizeSpeech), varargs...)
}</span>

// MockTranslateX is a mock of TranslateX interface.
type MockTranslateX struct {
        ctrl     *gomock.Controller
        recorder *MockTranslateXMockRecorder
        isgomock struct{}
}

// MockTranslateXMockRecorder is the mock recorder for MockTranslateX.
type MockTranslateXMockRecorder struct {
        mock *MockTranslateX
}

// NewMockTranslateX creates a new mock instance.
func NewMockTranslateX(ctrl *gomock.Controller) *MockTranslateX <span class="cov8" title="1">{
        mock := &amp;MockTranslateX{ctrl: ctrl}
        mock.recorder = &amp;MockTranslateXMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTranslateX) EXPECT() *MockTranslateXMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateTTS mocks base method.
func (m *MockTranslateX) CreateTTS(arg0 echo.Context, arg1 db.Querier, arg2 db.Title, arg3 int16, arg4 string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTTS", arg0, arg1, arg2, arg3, arg4)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateTTS indicates an expected call of CreateTTS.
func (mr *MockTranslateXMockRecorder) CreateTTS(arg0, arg1, arg2, arg3, arg4 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTTS", reflect.TypeOf((*MockTranslateX)(nil).CreateTTS), arg0, arg1, arg2, arg3, arg4)
}</span>

// InsertNewPhrases mocks base method.
func (m *MockTranslateX) InsertNewPhrases(arg0 echo.Context, arg1 db.Title, arg2 db.Querier, arg3 []string) ([]db.Translate, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertNewPhrases", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].([]db.Translate)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertNewPhrases indicates an expected call of InsertNewPhrases.
func (mr *MockTranslateXMockRecorder) InsertNewPhrases(arg0, arg1, arg2, arg3 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertNewPhrases", reflect.TypeOf((*MockTranslateX)(nil).InsertNewPhrases), arg0, arg1, arg2, arg3)
}</span>

// InsertTranslates mocks base method.
func (m *MockTranslateX) InsertTranslates(arg0 echo.Context, arg1 db.Querier, arg2 int16, arg3 []util.TranslatesReturn) ([]db.Translate, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InsertTranslates", arg0, arg1, arg2, arg3)
        ret0, _ := ret[0].([]db.Translate)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// InsertTranslates indicates an expected call of InsertTranslates.
func (mr *MockTranslateXMockRecorder) InsertTranslates(arg0, arg1, arg2, arg3 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertTranslates", reflect.TypeOf((*MockTranslateX)(nil).InsertTranslates), arg0, arg1, arg2, arg3)
}</span>

// TranslatePhrases mocks base method.
func (m *MockTranslateX) TranslatePhrases(arg0 echo.Context, arg1 []db.Translate, arg2 db.Language) ([]util.TranslatesReturn, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "TranslatePhrases", arg0, arg1, arg2)
        ret0, _ := ret[0].([]util.TranslatesReturn)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// TranslatePhrases indicates an expected call of TranslatePhrases.
func (mr *MockTranslateXMockRecorder) TranslatePhrases(arg0, arg1, arg2 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TranslatePhrases", reflect.TypeOf((*MockTranslateX)(nil).TranslatePhrases), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package oapi

import (
        "bytes"
        "compress/gzip"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for PatchRequestAddReplaceTestOp.
const (
        Add     PatchRequestAddReplaceTestOp = "add"
        Replace PatchRequestAddReplaceTestOp = "replace"
        Test    PatchRequestAddReplaceTestOp = "test"
)

// AudioFromTitle defines model for AudioFromTitle.
type AudioFromTitle struct {
        FromVoiceId int16 `json:"fromVoiceId"`

        // Pattern pattern is the pattern used to construct the audio files. You have 3 choices:
        // 1 is standard and should be used if you are at a beginner or intermediate level of language learning
        // 2 is advanced and repeats phrases less often and should only be used if you are at an advanced level
        // 3 is review and only repeats each phrase one time and can be used to review already learned phrases
        Pattern *int `json:"pattern,omitempty"`

        // Pause the pause in seconds between phrases in the audio file (default is 4)
        Pause     *int  `json:"pause,omitempty"`
        TitleId   int64 `json:"titleId"`
        ToVoiceId int16 `json:"toVoiceId"`
}

// Error defines model for Error.
type Error struct {
        // Code Error code
        Code int32 `json:"code"`

        // Message Error message
        Message string `json:"message"`
}

// Language defines model for Language.
type Language struct {
        // Id id of language
        Id int16 `json:"id"`

        // Language string of language
        Language string `json:"language"`

        // Tag language tag used for google language methods
        Tag string `json:"tag"`
}

// NewTitle defines model for NewTitle.
type NewTitle struct {
        // Filename the file to upload
        Filename openapi_types.File `json:"filename"`

        // OgLanguageId Language id of title
        OgLanguageId int16 `json:"ogLanguageId"`

        // Title Name of the title
        Title string `json:"title"`
}

// NewUser defines model for NewUser.
type NewUser struct {
        // Email Email of user
        Email string `json:"email"`

        // Name Username of user. Must be alphanumeric.
        Name string `json:"name"`

        // NewLanguageId Id of language to learn
        NewLanguageId int16 `json:"newLanguageId"`

        // OgLanguageId Id of native language
        OgLanguageId int16 `json:"ogLanguageId"`

        // Password Password of user
        Password string `json:"password"`

        // TitleId Id of title to learn
        TitleId int64 `json:"titleId"`
}

// NewUserPermission defines model for NewUserPermission.
type NewUserPermission struct {
        // PermissionId Permission id of permission
        PermissionId int16 `json:"permissionId"`

        // UserId User id of user
        UserId int64 `json:"userId"`
}

// PatchRequest defines model for PatchRequest.
type PatchRequest = []PatchRequest_Item

// PatchRequest_Item defines model for PatchRequest.Item.
type PatchRequest_Item struct {
        union json.RawMessage
}

// PatchRequestAddReplaceTest defines model for PatchRequestAddReplaceTest.
type PatchRequestAddReplaceTest struct {
        // Op The operation to perform.
        Op PatchRequestAddReplaceTestOp `json:"op"`

        // Path A JSON Pointer path.
        Path string `json:"path"`

        // Value The value to add, replace or test.
        Value interface{} `json:"value"`
}

// PatchRequestAddReplaceTestOp The operation to perform.
type PatchRequestAddReplaceTestOp string

// Phrase defines model for Phrase.
type Phrase struct {
        // Id id of phrase
        Id int64 `json:"id"`

        // TitleId id of movie
        TitleId int64 `json:"titleId"`
}

// Title defines model for Title.
type Title struct {
        // Filename the file to upload
        Filename openapi_types.File `json:"filename"`

        // Id Unique id of the title
        Id int64 `json:"id"`

        // OgLanguageId Language id of title
        OgLanguageId int16 `json:"ogLanguageId"`

        // Title Name of the title
        Title string `json:"title"`
}

// TitlesTranslateRequest defines model for TitlesTranslateRequest.
type TitlesTranslateRequest struct {
        // NewLanguageId id of language to translate to
        NewLanguageId int16 `json:"newLanguageId"`

        // TitleId title id of title to translate from
        TitleId int64 `json:"titleId"`
}

// Translates defines model for Translates.
type Translates struct {
        LanguageId int16  `json:"languageId"`
        Phrase     string `json:"phrase"`
        PhraseHint string `json:"phraseHint"`
        PhraseId   int64  `json:"phraseId"`
}

// User defines model for User.
type User struct {
        // Email Email of user
        Email string `json:"email"`

        // Id Unique id of the user
        Id int64 `json:"id"`

        // Name Username of user. Must be alphanumeric.
        Name string `json:"name"`

        // NewLanguageId Id of language to learn
        NewLanguageId int16 `json:"newLanguageId"`

        // OgLanguageId Id of native language
        OgLanguageId int16 `json:"ogLanguageId"`

        // Password Password of user
        Password string `json:"password"`

        // TitleId Id of title to learn
        TitleId int64 `json:"titleId"`
}

// UserLogin defines model for UserLogin.
type UserLogin struct {
        // Password Password of user
        Password string `json:"password"`

        // Username Username of user
        Username string `json:"username"`
}

// UserLoginResponse defines model for UserLoginResponse.
type UserLoginResponse struct {
        // Jwt token of user
        Jwt string `json:"jwt"`
}

// UserPermissionResponse defines model for UserPermissionResponse.
type UserPermissionResponse struct {
        // Id Unique id of the user permission
        Id int16 `json:"id"`

        // PermissionId Permission id of permission
        PermissionId int16 `json:"permissionId"`

        // UserId User id of user
        UserId int64 `json:"userId"`
}

// UsersPhrases defines model for UsersPhrases.
type UsersPhrases struct {
        // LanguageId id of language
        LanguageId int16 `json:"languageId"`

        // PhraseCorrect id of language
        PhraseCorrect int16 `json:"phraseCorrect"`

        // PhraseId id of phrase
        PhraseId int64 `json:"phraseId"`

        // TitleId id of title
        TitleId int64 `json:"titleId"`

        // UserId id of user
        UserId int64 `json:"userId"`
}

// Voice defines model for Voice.
type Voice struct {
        // Id id of voice
        Id int16 `json:"id"`

        // LanguageId id of language
        LanguageId int16 `json:"languageId"`

        // Name the name of the voice
        Name string `json:"name"`

        // NaturalSampleRateHertz the natural sample rate of the voice in hertz
        NaturalSampleRateHertz int16 `json:"naturalSampleRateHertz"`

        // SsmlGender gender of voice MALE|FEMALE
        SsmlGender string `json:"ssmlGender"`
}

// AudioFromFileMultipartBody defines parameters for AudioFromFile.
type AudioFromFileMultipartBody struct {
        // FileLanguageId the original language of the file you are uploading
        FileLanguageId string             `json:"fileLanguageId"`
        FilePath       openapi_types.File `json:"filePath"`

        // FromVoiceId the language you know
        FromVoiceId string `json:"fromVoiceId"`

        // Pattern pattern is the pattern used to construct the audio files. You have 3 choices:
        // 1 is standard and should be used if you are at a beginner or intermediate level of language learning
        // 2 is advanced and repeats phrases less often and should only be used if you are at an advanced level
        // 3 is review and only repeats each phrase one time and can be used to review already learned phrases
        Pattern *string `json:"pattern,omitempty"`

        // Pause the pause in seconds between phrases in the audiofile (default is 4)
        Pause *string `json:"pause,omitempty"`

        // TitleName choose a descriptive title that includes to and from languages
        TitleName string `json:"titleName"`

        // ToVoiceId the language you want to learn
        ToVoiceId string `json:"toVoiceId"`
}

// GetLanguagesParams defines parameters for GetLanguages.
type GetLanguagesParams struct {
        // Similarity find titles similar to
        Similarity *string `form:"similarity,omitempty" json:"similarity,omitempty"`
}

// GetPhrasesParams defines parameters for GetPhrases.
type GetPhrasesParams struct {
        // Limit maximum number of results to return
        Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// FindTitlesParams defines parameters for FindTitles.
type FindTitlesParams struct {
        // Similarity find titles similar to
        Similarity string `form:"similarity" json:"similarity"`

        // Limit maximum number of results to return
        Limit int32 `form:"limit" json:"limit"`
}

// AddTitleMultipartBody defines parameters for AddTitle.
type AddTitleMultipartBody struct {
        FilePath   openapi_types.File `json:"filePath"`
        LanguageId string             `json:"languageId"`
        TitleName  string             `json:"titleName"`
}

// GetVoicesParams defines parameters for GetVoices.
type GetVoicesParams struct {
        // LanguageId filter by languageId
        LanguageId *int16 `form:"languageId,omitempty" json:"languageId,omitempty"`
}

// AudioFromFileMultipartRequestBody defines body for AudioFromFile for multipart/form-data ContentType.
type AudioFromFileMultipartRequestBody AudioFromFileMultipartBody

// AudioFromTitleJSONRequestBody defines body for AudioFromTitle for application/json ContentType.
type AudioFromTitleJSONRequestBody = AudioFromTitle

// AddTitleMultipartRequestBody defines body for AddTitle for multipart/form-data ContentType.
type AddTitleMultipartRequestBody AddTitleMultipartBody

// TitlesTranslateJSONRequestBody defines body for TitlesTranslate for application/json ContentType.
type TitlesTranslateJSONRequestBody = TitlesTranslateRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = NewUser

// LoginUserJSONRequestBody defines body for LoginUser for application/json ContentType.
type LoginUserJSONRequestBody = UserLogin

// UpdateUserApplicationJSONPatchPlusJSONRequestBody defines body for UpdateUser for application/json-patch+json ContentType.
type UpdateUserApplicationJSONPatchPlusJSONRequestBody = PatchRequest

// AddUserPermissionJSONRequestBody defines body for AddUserPermission for application/json ContentType.
type AddUserPermissionJSONRequestBody = NewUserPermission

// UpdateUsersPhrasesApplicationJSONPatchPlusJSONRequestBody defines body for UpdateUsersPhrases for application/json-patch+json ContentType.
type UpdateUsersPhrasesApplicationJSONPatchPlusJSONRequestBody = PatchRequest

// AsPatchRequestAddReplaceTest returns the union data inside the PatchRequest_Item as a PatchRequestAddReplaceTest
func (t PatchRequest_Item) AsPatchRequestAddReplaceTest() (PatchRequestAddReplaceTest, error) <span class="cov0" title="0">{
        var body PatchRequestAddReplaceTest
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromPatchRequestAddReplaceTest overwrites any union data inside the PatchRequest_Item as the provided PatchRequestAddReplaceTest
func (t *PatchRequest_Item) FromPatchRequestAddReplaceTest(v PatchRequestAddReplaceTest) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergePatchRequestAddReplaceTest performs a merge with any union data inside the PatchRequest_Item, using the provided PatchRequestAddReplaceTest
func (t *PatchRequest_Item) MergePatchRequestAddReplaceTest(v PatchRequestAddReplaceTest) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t PatchRequest_Item) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *PatchRequest_Item) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>

// ServerInterface represents all server handlers.
type ServerInterface interface {

        // (POST /audio/fromfile)
        AudioFromFile(ctx echo.Context) error

        // (POST /audio/fromtitle)
        AudioFromTitle(ctx echo.Context) error
        // Returns list of all available languages
        // (GET /languages)
        GetLanguages(ctx echo.Context, params GetLanguagesParams) error
        // Returns phrases by title_id
        // (GET /phrases)
        GetPhrases(ctx echo.Context, params GetPhrasesParams) error
        // Returns all titles
        // (GET /titles)
        FindTitles(ctx echo.Context, params FindTitlesParams) error
        // Creates a new title
        // (POST /titles)
        AddTitle(ctx echo.Context) error

        // (POST /titles/translate)
        TitlesTranslate(ctx echo.Context) error
        // Deletes a title by ID
        // (DELETE /titles/{id})
        DeleteTitle(ctx echo.Context, id int64) error
        // Returns a title by ID
        // (GET /titles/{id})
        FindTitleByID(ctx echo.Context, id int64) error
        // Creates a new user
        // (POST /users)
        CreateUser(ctx echo.Context) error
        // Login a user
        // (POST /users/login)
        LoginUser(ctx echo.Context) error
        // Deletes a user by ID
        // (DELETE /users/{id})
        DeleteUser(ctx echo.Context, id int64) error
        // Returns a user by ID
        // (GET /users/{id})
        FindUserByID(ctx echo.Context, id int64) error
        // Patch an existing user
        // (PATCH /users/{id})
        UpdateUser(ctx echo.Context, id int64) error

        // (POST /userspermissions)
        AddUserPermission(ctx echo.Context) error
        // patches usersphrases resource
        // (PATCH /usersphrases/{phraseId}/{languageId})
        UpdateUsersPhrases(ctx echo.Context, phraseId int64, languageId int16) error
        // Returns list of all available voices
        // (GET /voices)
        GetVoices(ctx echo.Context, params GetVoicesParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// AudioFromFile converts echo context to params.
func (w *ServerInterfaceWrapper) AudioFromFile(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{"titles:w"})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AudioFromFile(ctx)
        return err
}</span>

// AudioFromTitle converts echo context to params.
func (w *ServerInterfaceWrapper) AudioFromTitle(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{"titles:w"})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AudioFromTitle(ctx)
        return err
}</span>

// GetLanguages converts echo context to params.
func (w *ServerInterfaceWrapper) GetLanguages(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params GetLanguagesParams
        // ------------- Optional query parameter "similarity" -------------

        err = runtime.BindQueryParameter("form", true, false, "similarity", ctx.QueryParams(), &amp;params.Similarity)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter similarity: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov8" title="1">err = w.Handler.GetLanguages(ctx, params)
        return err</span>
}

// GetPhrases converts echo context to params.
func (w *ServerInterfaceWrapper) GetPhrases(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params GetPhrasesParams
        // ------------- Optional query parameter "limit" -------------

        err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &amp;params.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov8" title="1">err = w.Handler.GetPhrases(ctx, params)
        return err</span>
}

// FindTitles converts echo context to params.
func (w *ServerInterfaceWrapper) FindTitles(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params FindTitlesParams
        // ------------- Required query parameter "similarity" -------------

        err = runtime.BindQueryParameter("form", true, true, "similarity", ctx.QueryParams(), &amp;params.Similarity)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter similarity: %s", err))
        }</span>

        // ------------- Required query parameter "limit" -------------

        <span class="cov8" title="1">err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &amp;params.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov8" title="1">err = w.Handler.FindTitles(ctx, params)
        return err</span>
}

// AddTitle converts echo context to params.
func (w *ServerInterfaceWrapper) AddTitle(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{"titles:w"})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AddTitle(ctx)
        return err
}</span>

// TitlesTranslate converts echo context to params.
func (w *ServerInterfaceWrapper) TitlesTranslate(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{"titles:w"})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.TitlesTranslate(ctx)
        return err
}</span>

// DeleteTitle converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTitle(ctx echo.Context) error <span class="cov8" title="1">{
        var err error
        // ------------- Path parameter "id" -------------
        var id int64

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov8" title="1">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteTitle(ctx, id)
        return err</span>
}

// FindTitleByID converts echo context to params.
func (w *ServerInterfaceWrapper) FindTitleByID(ctx echo.Context) error <span class="cov8" title="1">{
        var err error
        // ------------- Path parameter "id" -------------
        var id int64

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov8" title="1">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.FindTitleByID(ctx, id)
        return err</span>
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.CreateUser(ctx)
        return err
}</span>

// LoginUser converts echo context to params.
func (w *ServerInterfaceWrapper) LoginUser(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.LoginUser(ctx)
        return err
}</span>

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id int64

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteUser(ctx, id)
        return err</span>
}

// FindUserByID converts echo context to params.
func (w *ServerInterfaceWrapper) FindUserByID(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id int64

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.FindUserByID(ctx, id)
        return err</span>
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id int64

        err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &amp;id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateUser(ctx, id)
        return err</span>
}

// AddUserPermission converts echo context to params.
func (w *ServerInterfaceWrapper) AddUserPermission(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{"global:admin"})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.AddUserPermission(ctx)
        return err
}</span>

// UpdateUsersPhrases converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUsersPhrases(ctx echo.Context) error <span class="cov8" title="1">{
        var err error
        // ------------- Path parameter "phraseId" -------------
        var phraseId int64

        err = runtime.BindStyledParameterWithOptions("simple", "phraseId", ctx.Param("phraseId"), &amp;phraseId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter phraseId: %s", err))
        }</span>

        // ------------- Path parameter "languageId" -------------
        <span class="cov8" title="1">var languageId int16

        err = runtime.BindStyledParameterWithOptions("simple", "languageId", ctx.Param("languageId"), &amp;languageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter languageId: %s", err))
        }</span>

        <span class="cov8" title="1">ctx.Set(BearerAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.UpdateUsersPhrases(ctx, phraseId, languageId)
        return err</span>
}

// GetVoices converts echo context to params.
func (w *ServerInterfaceWrapper) GetVoices(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(BearerAuthScopes, []string{})

        // Parameter object where we will unmarshal all parameters from the context
        var params GetVoicesParams
        // ------------- Optional query parameter "languageId" -------------

        err = runtime.BindQueryParameter("form", true, false, "languageId", ctx.QueryParams(), &amp;params.LanguageId)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter languageId: %s", err))
        }</span>

        // Invoke the callback with all the unmarshaled arguments
        <span class="cov8" title="1">err = w.Handler.GetVoices(ctx, params)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov8" title="1">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.POST(baseURL+"/audio/fromfile", wrapper.AudioFromFile)
        router.POST(baseURL+"/audio/fromtitle", wrapper.AudioFromTitle)
        router.GET(baseURL+"/languages", wrapper.GetLanguages)
        router.GET(baseURL+"/phrases", wrapper.GetPhrases)
        router.GET(baseURL+"/titles", wrapper.FindTitles)
        router.POST(baseURL+"/titles", wrapper.AddTitle)
        router.POST(baseURL+"/titles/translate", wrapper.TitlesTranslate)
        router.DELETE(baseURL+"/titles/:id", wrapper.DeleteTitle)
        router.GET(baseURL+"/titles/:id", wrapper.FindTitleByID)
        router.POST(baseURL+"/users", wrapper.CreateUser)
        router.POST(baseURL+"/users/login", wrapper.LoginUser)
        router.DELETE(baseURL+"/users/:id", wrapper.DeleteUser)
        router.GET(baseURL+"/users/:id", wrapper.FindUserByID)
        router.PATCH(baseURL+"/users/:id", wrapper.UpdateUser)
        router.POST(baseURL+"/userspermissions", wrapper.AddUserPermission)
        router.PATCH(baseURL+"/usersphrases/:phraseId/:languageId", wrapper.UpdateUsersPhrases)
        router.GET(baseURL+"/voices", wrapper.GetVoices)

}</span>

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "H4sIAAAAAAAC/+xcfXPbOHP/Kiif6zROaEm2kzx3mukkvji5xze+nCdxrtNauitErkRcQIABQMk6W/3s",
        "nQX4KpEy5cSp0/YfxSLAxWL3h32Fcu0FMk6kAGG0N7z2dBBBTO2fx2nI5Bsl4wtmOOCTRMkElGFgx6dK",
        "xr9JFsBpaL9KFVPjDT0mzMFzz/fMMgH3FWagvJXvJdQYUAJnh6ADxRLDpPCG+QBhmpgISP411RASI0kg",
        "hTYqDYwdpcgXmTIOukf+XaYkonMgRySIkBk9JCNxgJS0oSKkKiRUhERHMuUhmYAjyqZkKVNCFRBqCCUT",
        "mDEhQBGpCDKsYggZNUA4zIETOSWcillKZ/iEKsHEbCQOcRUazqkIwK2iIAFqNEkiRTVowkFrIqcGRJUJ",
        "KfiyjRNRErRLj8QRrqJgzmBhidi384WABlG2GpECiGEx2FkBFcUSRhbvcwU0XLo9QJjzORKe78X0isVp",
        "7A2PfC9mwv190KzGVMOmEp3mUg2ECaIhkCLUZAJmASAKiTCxpkPyKIQpTbnBbT7da8SNQQBuouz50+bZ",
        "chdUrnxPwaeUKQi94WWxlF+Dd5XouKAhJ39CYHDJ10pJtXlCAhk2yMlOJnbMr/F3dNi4nxi0prNWQvlw",
        "8ao2ionZxs6yBfPp45XvnWWY3uSchZvLsbB6DtZ4bznxvLJCnZrjco3i2g58z9DZ5qvFUTR05hA+lYrM",
        "pJxxKM9pDCaSob5VLgzVW+WBzqxw3sKizfAxDoLGLUfAgtpIkiZc0rAqpgkTVC2btilnuSpOGwSfjxGn",
        "AQvRbuI3+QbqBN/SGCylCApq24WUz6ox6peSyAT2QUPDMYCYMt4AX3yMbKT4lu/BFY0TZDf/66V9sRfI",
        "2Kv4Du/Ri+El3f9rsP/DP/3tu38epYPB4fN/efyk/68vfv/jP69vVv+1P37y6MVwNOrdOm3v8c3I0huN",
        "rgYH+/j5PX5M8CPAD8CHB9PR6OrwAD+O8PszHH8W4p9/n45vRqPRqELhhwYKf5+O9x6PvL2Xj14MS/7H",
        "5Z/748f5w70Xo1Fv78ktc25Go0tH7PDZ5WD/2fjm8HKw/3R8icM3l4OD8Qv7p/14sYckr49WHaffbK44",
        "7CwmKyGKH0c7SujJ3mg03ms6IM3HDeEmMiwjiHrkl1Qb9HuUJxEVaQyKBb0attLsHefxzkDMTOQNDwfW",
        "6eVfn1Xx9juK4Hj/P1AKj79r5A4W287vac1wom2w/rfK1v5Bp/O83U64dQQ1bA5Vq7rrKgnVeiFVwwrn",
        "2UjjqU3os2eLl6pm8gpS26T9fZPhL11+0ybtcCdJNgYJa9Ytw4OzU36V6TIcWLN8dZVXzN85qJhpbZld",
        "N4RJMda0s/LNzNCX07tZe9RIE2FkKyOZKW1XAWWU/foOcNfn1ATRO/iUgjY2cDAQ271KAb9OveHltfed",
        "gqk39P7WLzONfpZm9KuvH4fhO0g4DeACia2QfMYXVYouvbXl1uYPrz0ahgz3TPl5Re5TyjX4a6qQyaac",
        "LiIgOIfidwRXAgolZQ2IwHD4EpfwUDZ2XRQcLj2uHgMahj7JJviYT9gpDRBPKIJ/nYlj8vP7X9+Sc2nT",
        "EEyForoB6+cw3SA4pzyF5m3ZIdxSlbucuTp9AQu7QsX7rsPBLeSjELNtNAXF5zbk3yW2dElCF3xuMRCO",
        "VCznDO6AdFY99YjAIgaknHcAdBE1rvwu+/4g2Ke0COwq4dgd+B6vCn71haJCc2qgcjTr3Nzis9iGzzI5",
        "SWLkDtFnE3FnvVndkpf0MfO6gwhKW71pnAt56E1J8JoYuvjHAtibZ9oO/YMJs2W4Yya7tr3iXb/KccFN",
        "bW3cch6Ld8atfeGOsL2jXylQi2ufyRlrcpr3Eo1sqKaIC2+NMtvCye0ZVGViwUZt5+9AJ1I0Gcw/F6bh",
        "DMmPICosbV8dSeSrlXFGdcmdYFIJcj4DMDsGONuwo52zufV0f35Fw52yV1IpdHNfkOTp13CLnd1LezT5",
        "ZQLJ0lhvt2u5oFHRtgK3Szwxty/sVKj6UjBprw+JSvElZ7Ah3zWpovy9NTPvqIF/gDJ/tRG0c4m2k4lC",
        "F1qlT5ggkX29E+dax/wnEKHzHvXlZvZ5IVryy/HZ65s3r/Gf3epsNXW/kiFor7ayn+dkLYIYI3UNQaqY",
        "Wb5H4+Sw8CNQBeo4dZH1xH57k+/553+7wFXsbG+YjZZ8R8Yk3goJMzGVrn4rDHWnPKtheWGqzXJBlwJe",
        "BjIOqDY9ASbnd+id4Dh5Tz86Ya5F4pR/PGMf4eI32znY7CkQmiScBS4BCUGzmXD1+wh4Ys+cJnIOKpAx",
        "uE4JxjQ0JVmTAUQgU8wbICQLZiIiTQSqXIcmie6RU0PkdIq0KJpgjQkT+8t2HDI24CoBxUAEQMhkSSjn",
        "coHPHQdGkiCSUjsWdAIBm7KgKPGbCJZkQYXBiVMZpJpI0SPWTNu+hKuMEkKJgSvjCqaW20qTIKGKzhRN",
        "IoKQ9W1zI+tzJLgjJlxyBXPbWyHv311YQr7tfrgeQ0WWC8Y5mYEAezoo0YAyIL+cH1XbSZZhGjDOjOv9",
        "ZOIwkZLpLCKcaQP4pEfIcZFr8qVPKFnApLYis9sIYQ5cJjEI45NFBAoyGVqGtJS2S0MnWTFDzgi+hVsA",
        "EVGUv4mAVTSoPzLOdcGRAhpa3IiwCKDxO4bQ2atZPagey2OmQdUMTPG4Z5tAnAWQBQQZoI8TGkRADnsD",
        "z/dSxbODoof9/mKx6FE73JNq1s/e1f2z01ev375/vX/YG/QiE/NKJbo8AnPP9+agXKHEO+gNegNb4UpA",
        "0IR5Q+/IPnL5pT3bfaupPm4NtWUdgdQNPjhQ4LTccL7KvpMVkYMinrErg3DSyuGxZx/YeVknrYpJjVMb",
        "EGlFWFQQ0JWUTdQ3zDpe5fKxH2W4zC0MuGQhTrlhCVWmj4jfD6mhZUO2uQmxLYFDFUvFZkxQXgoi8wt2",
        "Y3nb0ckATXY1sH36Q5NfwhfPs7pFh77GWot4k8OCMWTmo5CLGg8Hzw9bCif/30Z+qG3kivaadfdlesfN",
        "rePK4gOvrar8tjE0yzwaJcXjOeTFiYgawkTA09D5CJSMNR+5NnXjYrI79HN3uVHO9g4H33frzr11AdOa",
        "XWjvY1cO82b1brURuyCZki5KfCnTwrsYKWYpWk1Zn7N9oz2CUQH56fUF6ReitM1can1t7cCwUDsfVe7c",
        "qBSsKFwaa+3i4WCwZlgrXrn/p3Z1+dKqFgXrbWlvpXy0UZTeFFVmWRAgFqY5fy4gtIjdicVtnLmbBw1M",
        "pAKDuMBASCCbU0bMNs+vxsoZhvRwYZPqlV/1tkUX+bPdbdFGbvaRF9lwu5O8u6DWFmlBeHY42uFdmXAL",
        "tr91rO4Il9IUDq+9GTTg5B2YVAldnGzKOaFzyrgNf6umtA6Pn8CcVQYxCovBgNKWrTUdMgyELW9Es5hx",
        "qly5ujSo2WMP0zxv6H1KwcYuWbibjeKm/Yrk1+3v+Gtosrie00GPZYqHMx6SyUnjGKPD7vq3cErKet5W",
        "MAnMIC85i5kZF4HCZOkw8AfL0mAuF6ANCVwxiehAKhtp2FzsjyJxRUaa4JcXF28BX3aDjog0nrgqiQKd",
        "cqNd6IQMV5F4MGiGoN1MDX23XhL7OnjMGnod0JiFkg8ZhQ1Ycchz1uNW4CF6M0OTJ9tEL7WB2MWLRZE7",
        "oprQIMAQ3lqiOrreMBG6lt3XNW11x7TN1Pn3DPN2Th4I7PN+7q2od9nCQwZ9CVqbizWGc69sOKcJJQIW",
        "bnaPnKSOZbSSDoKYaQppXG0Qws2gLgxvD+fuUPPYofpQr+lvTwa7J1h8/QJk5xTqIm9155dIvmRs2AHB",
        "3wBiuwWcVWg3wLVqx/vFtYL2BKaYUnoFa9Kby2fFzbP8YaLknIUQYkCRQZ1MEOvrR2LtasY9JTotF0Da",
        "tH8a1i9fUBFWc+72WyDMOPfz4FMci4tSxd9mNp6h+ZqFKwdgDqahiuWe42nQTMx4XsGaUA0hka5+dnpC",
        "dIpbbLDaJ/b93HBvjUdOT2rHIeMo8/X2Uljh6lnY2c83N5E3/fzTtltFjo/wIXnfk0IpmTaW5PQEGdwe",
        "YK7rrtDp6Ul7GPnj0o7uorkpmCD6aor7v+jVNuOwOhLwgNtUtN1H1d2cu+xeBGXEdqet6c6vGa3HZ72R",
        "sL+38O39A9clze8h2bm5lnsNTSy3+Ad35eM+fFZx+2xTovbycueY6eCLsdTGj83pXMnTGpmnDtFrJ0zM",
        "KWchyZxvj9hf3MSNP054SG5oS2SV6uw6j0Nqnxe39RrxCiJMJMvqoTi1lyNMVzBaAeEG6OyluHvEXHnl",
        "sEXLTSx+vZh9815gGxiteB9mWFPDk90NoRtI2jmmsbveMaTJgNTBL6aZwfmfD2gsJw86nnGa6BjO1NV2",
        "WzSDCusezORK+1Zjma3e5mFHMnUMJBQV0HBV2wQRoYLAFdMmv0q2ofgPSUjvclbdqveo9q7uZ99y8mQ3",
        "HdR+Q7Vare7TrWyJtB4s1lrAU7qQ8h75lgj6OAzzWKacbyPL6m9H7SWgGZcTygkNYyZIoticcZhBU4lz",
        "7TL8vUbH1Uv3LXHyeX1j4dcPWRp+XNAGtYoWvomajEPF0KKiqMs4/LmqYf86v8u+6l+XZeKV+xVLo11U",
        "mRmtkiFZBbndOOqODcmcndxUFitsN5mVG/mfYzj9tv+3YWeGaiX3biw1/4Lkf5ctr0Gh5ZQVEn6Iht0K",
        "GNbQr0DLVAVZFd/+zqD7nRI3vUfOAO247TiSCafio7tVVrtx4OYSqciUceOCmErlu9d0E+A3x86trdp1",
        "eha5jV3Q6oSdoXzfhXb3i5sONXb3c5Bv9e5JBrLVdgeAJv+/AwAA///BLHikL0sAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov8" title="1">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov8" title="1">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov8" title="1">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov8" title="1">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov8" title="1">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov8" title="1">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov8" title="1">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov8" title="1">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov8" title="1">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package test

import (
        "fmt"
        "github.com/stretchr/testify/require"
        "math"
        "math/rand"
        "path/filepath"
        "reflect"
        "runtime"
        "slices"
        "strings"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/oapi"
        "testing"
)

var (
        AudioBasePath = GetProjectRoot() + "/../tmp/test/audio/"
)

func GetProjectRoot() string <span class="cov8" title="1">{
        _, filename, _, _ := runtime.Caller(0)
        return filepath.Dir(filepath.Dir(filename))
}</span>

func RequireMatchAnyExcept(t *testing.T, model any, response any, skip []string, except string, shouldEqual any) <span class="cov8" title="1">{

        v := reflect.ValueOf(response)
        u := reflect.ValueOf(model)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                // Check if field name is the one that should be different
                if v.Type().Field(i).Name == except </span><span class="cov8" title="1">{
                        // Check if type is int32 or int64
                        if v.Field(i).CanInt() </span><span class="cov8" title="1">{
                                // check if equal as int64
                                require.Equal(t, shouldEqual, v.Field(i).Int())
                        }</span> else<span class="cov8" title="1"> {
                                // if not check if equal as string
                                require.Equal(t, shouldEqual, v.Field(i).String())
                        }</span>
                } else<span class="cov8" title="1"> if slices.Contains(skip, v.Type().Field(i).Name) </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        if v.Field(i).CanInt() </span><span class="cov8" title="1">{
                                require.Equal(t, u.Field(i).Int(), v.Field(i).Int())
                        }</span> else<span class="cov8" title="1"> {
                                require.Equal(t, u.Field(i).String(), v.Field(i).String())
                        }</span>
                }
        }
}

const (
        ValidTitleId       = -1
        ValidOgLanguageId  = -1
        ValidNewLanguageId = -1
        alphabet           = "abcdefghijklmnopqrstuvwxyz"
)

// RandomInt64 generates a random integer between min and max
func RandomInt64() int64 <span class="cov8" title="1">{
        return rand.Int63n(math.MaxInt64 - 1)
}</span>

// RandomInt32 generates a random integer between min and max
func RandomInt32() int32 <span class="cov0" title="0">{
        return rand.Int31n(math.MaxInt32 - 1)
}</span>

// RandomInt16 generates a random integer between min and max
func RandomInt16() int16 <span class="cov8" title="1">{
        return int16(rand.Int())
}</span>

// RandomString generates a random string of length n
func RandomString(n int) string <span class="cov8" title="1">{
        var sb strings.Builder
        k := len(alphabet)

        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                c := alphabet[rand.Intn(k)]
                sb.WriteByte(c)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// RandomEmail generates a random email
func RandomEmail() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s@email.com", RandomString(6))
}</span>

func RandomPhrase() oapi.Phrase <span class="cov8" title="1">{
        return oapi.Phrase{
                Id:      RandomInt64(),
                TitleId: RandomInt64(),
        }
}</span>

// RandomVoice creates a random db Voice for testing
func RandomVoice() (voice db.Voice) <span class="cov8" title="1">{
        return db.Voice{
                ID:                     RandomInt16(),
                LanguageID:             RandomInt16(),
                LanguageCodes:          []string{RandomString(8), RandomString(8)},
                SsmlGender:             "FEMALE",
                Name:                   RandomString(8),
                NaturalSampleRateHertz: 24000,
        }
}</span>

func RandomTitle() (title db.Title) <span class="cov8" title="1">{

        return db.Title{
                ID:           RandomInt64(),
                Title:        RandomString(8),
                NumSubs:      RandomInt16(),
                OgLanguageID: ValidOgLanguageId,
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package token

import (
        "crypto/ecdsa"
        "encoding/json"
        "fmt"
        "github.com/lestrrat-go/jwx/jwa"
        "github.com/lestrrat-go/jwx/jwk"
        "github.com/lestrrat-go/jwx/jws"
        "github.com/lestrrat-go/jwx/jwt"
        "github.com/oapi-codegen/oapi-codegen/v2/pkg/ecdsafile"
        db "talkliketv.click/tltv/db/sqlc"
        "time"
)

// PrivateKey is an ECDSA private key which was generated with the following
// command:
//
//        openssl ecparam -name prime256v1 -genkey -noout -out ecprivatekey.pem
//
// We are using a hard coded key here in this example, but in real applications,
// you would never do this. Your JWT signing key must never be in your application,
// only the public key.
const PrivateKey = `-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIN2dALnjdcZaIZg4QuA6Dw+kxiSW502kJfmBN3priIhPoAoGCCqGSM49
AwEHoUQDQgAE4pPyvrB9ghqkT1Llk0A42lixkugFd/TBdOp6wf69O9Nndnp4+HcR
s9SlG/8hjB2Hz42v4p3haKWv3uS1C6ahCQ==
-----END EC PRIVATE KEY-----`

const (
        KeyID            = "fake-key-id"
        Issuer           = "tltv"
        FakeAudience     = "example-users"
        PermissionsClaim = "perm"
        Expiration       = "exp"
        IssuedAt         = "iat"
        UserContextKey   = "user"
        UserIdContextKey = "userid"
)

type FakeAuthenticator struct {
        PrivateKey *ecdsa.PrivateKey
        KeySet     jwk.Set
        // duration of JWS key in hours
        duration *time.Duration
}

var _ JWSValidator = (*FakeAuthenticator)(nil)

// NewFakeAuthenticator creates an authenticator example which uses a hard coded
// ECDSA key to validate JWT's that it has signed itself.
func NewFakeAuthenticator(d *time.Duration) (*FakeAuthenticator, error) <span class="cov8" title="1">{
        privKey, err := ecdsafile.LoadEcdsaPrivateKey([]byte(PrivateKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("loading PEM private key: %w", err)
        }</span>

        <span class="cov8" title="1">set := jwk.NewSet()
        pubKey := jwk.NewECDSAPublicKey()

        err = pubKey.FromRaw(&amp;privKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing jwk key: %w", err)
        }</span>

        <span class="cov8" title="1">err = pubKey.Set(jwk.AlgorithmKey, jwa.ES256)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting key algorithm: %w", err)
        }</span>

        <span class="cov8" title="1">err = pubKey.Set(jwk.KeyIDKey, KeyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting key ID: %w", err)
        }</span>

        <span class="cov8" title="1">set.Add(pubKey)

        return &amp;FakeAuthenticator{PrivateKey: privKey, KeySet: set, duration: d}, nil</span>
}

// ValidateJWS ensures that the critical JWT claims needed to ensure that we
// trust the JWT are present and with the correct values.
func (f *FakeAuthenticator) ValidateJWS(jwsString string) (jwt.Token, error) <span class="cov8" title="1">{
        return jwt.Parse([]byte(jwsString), jwt.WithKeySet(f.KeySet),
                jwt.WithAudience(FakeAudience), jwt.WithIssuer(Issuer))
}</span>

// SignToken takes a JWT and signs it with our private key, returning a JWS.
func (f *FakeAuthenticator) SignToken(t jwt.Token) ([]byte, error) <span class="cov8" title="1">{
        hdr := jws.NewHeaders()
        if err := hdr.Set(jws.AlgorithmKey, jwa.ES256); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting algorithm: %w", err)
        }</span>
        <span class="cov8" title="1">if err := hdr.Set(jws.TypeKey, "JWT"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting type: %w", err)
        }</span>
        <span class="cov8" title="1">if err := hdr.Set(jws.KeyIDKey, KeyID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting Key ID: %w", err)
        }</span>
        <span class="cov8" title="1">return jwt.Sign(t, jwa.ES256, f.PrivateKey, jwt.WithHeaders(hdr))</span>
}

// CreateJWSWithClaims is a helper function to create JWT's with the specified
// claims.
func (f *FakeAuthenticator) CreateJWSWithClaims(claims []string, user db.User) ([]byte, error) <span class="cov8" title="1">{
        t := jwt.New()
        err := t.Set(jwt.IssuerKey, Issuer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting issuer: %w", err)
        }</span>
        <span class="cov8" title="1">err = t.Set(jwt.AudienceKey, FakeAudience)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting audience: %w", err)
        }</span>
        <span class="cov8" title="1">err = t.Set(PermissionsClaim, claims)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting permissions: %w", err)
        }</span>
        <span class="cov8" title="1">err = t.Set(Expiration, time.Now().Add(time.Hour**f.duration))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting expiration: %w", err)
        }</span>
        <span class="cov8" title="1">err = t.Set(IssuedAt, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting issued at: %w", err)
        }</span>
        <span class="cov8" title="1">jsonUser, err := json.Marshal(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling user: %w", err)
        }</span>
        <span class="cov8" title="1">err = t.Set(jwt.SubjectKey, string(jsonUser))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting subject key: %w", err)
        }</span>
        <span class="cov8" title="1">return f.SignToken(t)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package token

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/getkin/kin-openapi/openapi3filter"
        "github.com/labstack/echo/v4"
        "github.com/lestrrat-go/jwx/jwt"
        mw "github.com/oapi-codegen/echo-middleware"
        "net/http"
        "strconv"
        "strings"
        db "talkliketv.click/tltv/db/sqlc"
)

// JWSValidator is used to validate JWS payloads and return a JWT if they're
// valid
type JWSValidator interface {
        ValidateJWS(jws string) (jwt.Token, error)
}

var (
        ErrNoAuthHeader      = errors.New("authorization header is missing")
        ErrInvalidAuthHeader = errors.New("authorization header is malformed")
        ErrClaimsInvalid     = errors.New("provided claims do not match expected scopes")
        ErrUnauthorizedUser  = errors.New("provided id does not match user id")
        ErrInvalidToken      = errors.New("provided token is invalid. please login again")
)

// GetJWSFromRequest extracts a JWS string from an Authorization: Bearer &lt;jws&gt; header
func GetJWSFromRequest(req *http.Request) (string, error) <span class="cov8" title="1">{
        authHdr := req.Header.Get("Authorization")
        // Check for the Authorization header.
        if authHdr == "" </span><span class="cov0" title="0">{
                return "", ErrNoAuthHeader
        }</span>
        // We expect a header value of the form "Bearer &lt;token&gt;", with 1 space after
        // Bearer, per spec.
        <span class="cov8" title="1">prefix := "Bearer "
        if !strings.HasPrefix(authHdr, prefix) </span><span class="cov0" title="0">{
                return "", ErrInvalidAuthHeader
        }</span>
        <span class="cov8" title="1">return strings.TrimPrefix(authHdr, prefix), nil</span>
}

func NewAuthenticator(v JWSValidator) openapi3filter.AuthenticationFunc <span class="cov8" title="1">{
        return func(ctx context.Context, input *openapi3filter.AuthenticationInput) error </span><span class="cov8" title="1">{
                return Authenticate(v, ctx, input)
        }</span>
}

// Authenticate uses the specified validator to ensure a JWT is valid, then makes
// sure that the claims provided by the JWT match the scopes as required in the API.
func Authenticate(v JWSValidator, ctx context.Context, input *openapi3filter.AuthenticationInput) error <span class="cov8" title="1">{
        // Our security scheme is named BearerAuth, ensure this is the case
        if input.SecuritySchemeName != "BearerAuth" </span><span class="cov0" title="0">{
                return fmt.Errorf("security scheme %s != 'BearerAuth'", input.SecuritySchemeName)
        }</span>

        // Now, we need to get the JWS from the request, to match the request expectations
        // against request contents.
        <span class="cov8" title="1">jws, err := GetJWSFromRequest(input.RequestValidationInput.Request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("getting jws: %w", err)
        }</span>

        // if the JWS is valid, we have a JWT, which will contain a bunch of claims.
        <span class="cov8" title="1">token, err := v.ValidateJWS(jws)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validating JWS: %w", err)
        }</span>

        // We've got a valid token now, and we can look into its claims to see whether
        // they match. Every single scope must be present in the claims.
        <span class="cov8" title="1">err = CheckTokenClaims(input.Scopes, token)

        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("token claims don't match: %w", err)
        }</span>

        // Set the property on the echo context so the handler is able to
        // access the claims data we generate in here.
        <span class="cov8" title="1">user, found := token.Get(jwt.SubjectKey)
        if !found </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        <span class="cov8" title="1">var dbUser db.User
        err = json.Unmarshal([]byte(user.(string)), &amp;dbUser)
        if err != nil </span><span class="cov0" title="0">{
                return ErrInvalidToken
        }</span>

        // Set the property on the echo context so the handler is able to
        // access the claims data we generate in here.
        <span class="cov8" title="1">eCtx := mw.GetEchoContext(ctx)
        eCtx.Set(UserContextKey, user)
        eCtx.Set(UserIdContextKey, dbUser.ID)

        return nil</span>
}

// GetClaimsFromToken returns a list of claims from the token. We store these
// as a list under the "perms" claim, short for permissions, to keep the token
// shorter.
func GetClaimsFromToken(t jwt.Token) ([]string, error) <span class="cov8" title="1">{
        rawPerms, found := t.Get(PermissionsClaim)
        if !found </span><span class="cov0" title="0">{
                // If the perms aren't found, it means that the token has none, but it has
                // passed signature validation by now, so it's a valid token, so we return
                // the empty list.
                return make([]string, 0), nil
        }</span>

        // rawPerms will be an untyped JSON list, so we need to convert it to
        // a string list.
        <span class="cov8" title="1">rawList, ok := rawPerms.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'%s' claim is unexpected type'", PermissionsClaim)
        }</span>

        <span class="cov8" title="1">claims := make([]string, len(rawList))

        for i, rawClaim := range rawList </span><span class="cov8" title="1">{
                var ok bool
                claims[i], ok = rawClaim.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s[%d] is not a string", PermissionsClaim, i)
                }</span>
        }
        <span class="cov8" title="1">return claims, nil</span>
}

func CheckTokenClaims(expectedClaims []string, t jwt.Token) error <span class="cov8" title="1">{
        claims, err := GetClaimsFromToken(t)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("getting claims from token: %w", err)
        }</span>
        // Put the claims into a map, for quick access.
        <span class="cov8" title="1">claimsMap := make(map[string]bool, len(claims))
        for _, c := range claims </span><span class="cov8" title="1">{
                claimsMap[c] = true
        }</span>

        <span class="cov8" title="1">for _, e := range expectedClaims </span><span class="cov8" title="1">{
                if !claimsMap[e] </span><span class="cov8" title="1">{
                        return ErrClaimsInvalid
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func GetValueFromContext(eCtx echo.Context, key string) (string, error) <span class="cov8" title="1">{
        value := eCtx.Get(key)
        if value == nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("GetValueFromContext: %s not found in context: Please login again", key))
        }</span>

        <span class="cov8" title="1">return value.(string), nil</span>
}

func CheckJWTUserIDFromRequest(eCtx echo.Context, id int64) error <span class="cov8" title="1">{
        value, err := GetValueFromContext(eCtx, UserIdContextKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if i != id </span><span class="cov8" title="1">{
                return ErrUnauthorizedUser
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func GetUserFromContext(eCtx echo.Context) (*db.User, error) <span class="cov8" title="1">{
        user, err := GetValueFromContext(eCtx, UserContextKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">var dbUser db.User
        err = json.Unmarshal([]byte(user), &amp;dbUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return &amp;dbUser, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package translates

import (
        "cloud.google.com/go/texttospeech/apiv1/texttospeechpb"
        "cloud.google.com/go/translate"
        "context"
        "errors"
        "fmt"
        "github.com/googleapis/gax-go/v2"
        "github.com/labstack/echo/v4"
        "golang.org/x/text/language"
        "os"
        "strconv"
        "strings"
        "sync"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/util"
        "time"
        "unicode"
)

// TranslateClientX creates an interface for google translate.Translate so it can
// be mocked for testing
type TranslateClientX interface {
        Translate(context.Context, []string, language.Tag, *translate.Options) ([]translate.Translation, error)
}

// TTSClientX creates an interface for google texttospeechpb.SynthesizeSpeech so
// it can be mocked for testing
type TTSClientX interface {
        SynthesizeSpeech(context.Context, *texttospeechpb.SynthesizeSpeechRequest, ...gax.CallOption) (*texttospeechpb.SynthesizeSpeechResponse, error)
}

// TranslateX creates an interface for Translate methods that deal with creating/inserting
// translates and phrases
type TranslateX interface {
        InsertNewPhrases(echo.Context, db.Title, db.Querier, []string) ([]db.Translate, error)
        InsertTranslates(echo.Context, db.Querier, int16, []util.TranslatesReturn) ([]db.Translate, error)
        CreateTTS(echo.Context, db.Querier, db.Title, int16, string) error
        TranslatePhrases(echo.Context, []db.Translate, db.Language) ([]util.TranslatesReturn, error)
}

type Translate struct {
        translateClient TranslateClientX
        ttsClient       TTSClientX
}

func New(trc TranslateClientX, ttsc TTSClientX) *Translate <span class="cov8" title="1">{
        return &amp;Translate{
                translateClient: trc,
                ttsClient:       ttsc,
        }
}</span>

// TranslatePhrases takes a slice of db.Translate{} and a db.Language and returns a slice
// of util.TranslatesReturn to be inserted into the db
func (t *Translate) TranslatePhrases(e echo.Context, ts []db.Translate, dbLang db.Language) ([]util.TranslatesReturn, error) <span class="cov8" title="1">{

        // get language tag to translate to
        langTag, err := language.Parse(dbLang.Tag)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        // concurrently get all the responses from Google Translate
        <span class="cov8" title="1">var wg sync.WaitGroup
        responses := make([]util.TranslatesReturn, len(ts)) // create string slice to hold all the responses
        // create context with cancel, so you can cancel all other requests after any error
        newCtx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        for i, nextTranslate := range ts </span><span class="cov8" title="1">{
                // added intermittent sleep to fix TLS handshake errors on the client side
                if i%50 == 0 &amp;&amp; i != 0 </span><span class="cov0" title="0">{
                        time.Sleep(2 * time.Second)
                }</span>
                <span class="cov8" title="1">wg.Add(1)
                //get responses concurrently with go routines
                go t.GetTranslate(e, newCtx, cancel, nextTranslate, &amp;wg, langTag, responses, i)</span>
        }
        <span class="cov8" title="1">wg.Wait()

        if newCtx.Err() != nil </span><span class="cov0" title="0">{
                e.Logger().Error(newCtx.Err())
                return nil, newCtx.Err()
        }</span>

        <span class="cov8" title="1">return responses, nil</span>
}

// GetTranslate is a helper function for TranslatePhrases that allows concurrent calls to
// google translate.Translate.
// It receives a context.CancelFunc that is invoked on an error so all subsequent calls to
// google translate.Translate can be aborted
func (t *Translate) GetTranslate(e echo.Context,
        ctx context.Context,
        cancel context.CancelFunc,
        phrase db.Translate,
        wg *sync.WaitGroup,
        lang language.Tag,
        responses []util.TranslatesReturn,
        i int,
) <span class="cov8" title="1">{

        defer wg.Done()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span> // Error somewhere, terminate
        default:<span class="cov8" title="1"> // Default to avoid blocking

                resp, err := t.translateClient.Translate(ctx, []string{phrase.Phrase}, lang, nil)
                if err != nil </span><span class="cov0" title="0">{
                        switch </span>{
                        case errors.Is(err, context.Canceled):<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                e.Logger().Error(fmt.Errorf("error translating text: %s", err))
                                cancel()</span>
                        }
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">if len(resp) == 0 </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("translate returned empty response to text: %s", err))
                        cancel()
                }</span>

                //app.Logger.PrintInfo(fmt.Sprintf("response is: %s", resp[0].Text), nil)
                <span class="cov8" title="1">responses[i] = util.TranslatesReturn{
                        PhraseId: phrase.PhraseID,
                        Text:     resp[0].Text,
                }</span>
        }
}

// CreateTTS is called from api.createAudioFromTitle.
// It checks if the mp3 audio files exist and if not it creates them.
func (t *Translate) CreateTTS(e echo.Context, q db.Querier, title db.Title, voiceId int16, basePath string) error <span class="cov0" title="0">{

        voice, err := q.SelectVoiceById(e.Request().Context(), voiceId)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        <span class="cov0" title="0">lang, err := q.SelectLanguagesById(e.Request().Context(), voice.LanguageID)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        // if the audio files already exist no need to request them again
        <span class="cov0" title="0">skip, err := util.PathExists(basePath)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return err
        }</span>

        // if they do not exist, then request them
        <span class="cov0" title="0">if !skip </span><span class="cov0" title="0">{
                fromTranslates, err := t.GetOrCreateTranslates(e, q, title, lang)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = os.MkdirAll(basePath, 0777)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return err
                }</span>

                <span class="cov0" title="0">if err = t.TextToSpeech(e, fromTranslates, voice, basePath); err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// TextToSpeech takes a slice of db.Translate and get the speech mp3's adding them
// to the machines local file system
func (t *Translate) TextToSpeech(e echo.Context, ts []db.Translate, voice db.Voice, bp string) error <span class="cov8" title="1">{

        // set the texttospeec params from the db voice sent in the request
        voiceSelectionParams := &amp;texttospeechpb.VoiceSelectionParams{
                LanguageCode: voice.LanguageCodes[0],
                SsmlGender:   texttospeechpb.SsmlVoiceGender_MALE,
                Name:         voice.Name,
        }
        if voice.SsmlGender == "FEMALE" </span><span class="cov0" title="0">{
                voiceSelectionParams.SsmlGender = texttospeechpb.SsmlVoiceGender_FEMALE
        }</span>
        // concurrently get all the audio content from Google text-to-speech
        <span class="cov8" title="1">var wg sync.WaitGroup
        // create context with cancel, so you can cancel all other requests after any error
        newCtx, cancel := context.WithCancel(context.Background())
        defer cancel() // Make sure it's called to release resources even if no errors

        for i, nextText := range ts </span><span class="cov8" title="1">{
                // added intermittent sleep to fix TLS handshake errors on the client side
                if i%50 == 0 &amp;&amp; i != 0 </span><span class="cov0" title="0">{
                        time.Sleep(2 * time.Second)
                }</span>
                <span class="cov8" title="1">wg.Add(1)
                //get responses concurrently with go routines
                go t.GetSpeech(e, newCtx, cancel, nextText, &amp;wg, voiceSelectionParams, bp)</span>
        }
        <span class="cov8" title="1">wg.Wait()

        if newCtx.Err() != nil </span><span class="cov0" title="0">{
                e.Logger().Error(newCtx.Err())
                return newCtx.Err()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetSpeech is a helper function for TextToSpeech that is run concurrently.
// it is passed a cancel context, so if one routine fails, the following routines can
// be canceled
func (t *Translate) GetSpeech(
        e echo.Context,
        ctx context.Context,
        cancel context.CancelFunc,
        translate db.Translate,
        wg *sync.WaitGroup,
        params *texttospeechpb.VoiceSelectionParams,
        basePath string) <span class="cov8" title="1">{
        defer wg.Done()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span> // Error somewhere, terminate
        default:<span class="cov8" title="1">
                // Perform the text-to-speech request on the text input with the selected
                // voice parameters and audio file type.
                req := texttospeechpb.SynthesizeSpeechRequest{
                        // Set the text input to be synthesized.
                        Input: &amp;texttospeechpb.SynthesisInput{
                                InputSource: &amp;texttospeechpb.SynthesisInput_Text{Text: translate.Phrase},
                        },
                        // Build the voice request, select the language code ("en-US") and the SSML
                        // voice gender ("neutral").
                        Voice: params,
                        // Select the type of audio file you want returned.
                        AudioConfig: &amp;texttospeechpb.AudioConfig{
                                AudioEncoding: texttospeechpb.AudioEncoding_MP3,
                        },
                }

                resp, err := t.ttsClient.SynthesizeSpeech(ctx, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("error creating Synthesize Speech client: %s", err))
                        cancel()
                        return
                }</span>

                // The resp AudioContent is binary.
                <span class="cov8" title="1">filename := basePath + strconv.FormatInt(translate.PhraseID, 10)
                err = os.WriteFile(filename, resp.AudioContent, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(fmt.Errorf("error creating translate client: %s", err))
                        cancel()
                        return
                }</span>
        }
}

// GetOrCreateTranslates checks if the translates for the title already exists in the db.
// If they do not exist, then it creates and returns them.
func (t *Translate) GetOrCreateTranslates(e echo.Context, q db.Querier, title db.Title, lang db.Language) ([]db.Translate, error) <span class="cov0" title="0">{
        // see if translates exist for title for language
        exists, err := q.SelectExistsTranslates(
                e.Request().Context(),
                db.SelectExistsTranslatesParams{
                        LanguageID: lang.ID,
                        ID:         title.ID,
                })

        // if exists get translates for language
        if exists </span><span class="cov0" title="0">{
                params := db.SelectTranslatesByTitleIdLangIdParams{
                        LanguageID: lang.ID,
                        ID:         title.ID,
                }
                translates, err := q.SelectTranslatesByTitleIdLangId(e.Request().Context(), params)
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger().Error(err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return translates, nil</span>
        }

        // if not exists get translates for title original language
        <span class="cov0" title="0">fromTranslates, err := q.SelectTranslatesByTitleIdLangId(
                e.Request().Context(),
                db.SelectTranslatesByTitleIdLangIdParams{
                        LanguageID: title.OgLanguageID,
                        ID:         title.ID,
                })
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        // create translates for title and to language and return
        <span class="cov0" title="0">translatesReturn, err := t.TranslatePhrases(e, fromTranslates, lang)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">dbTranslates, err := t.InsertTranslates(e, q, lang.ID, translatesReturn)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger().Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return dbTranslates, nil</span>
}

// InsertNewPhrases accepts a slice of phrases and inserts them into the db as translates
func (t *Translate) InsertNewPhrases(e echo.Context, title db.Title, q db.Querier, stringsSlice []string) ([]db.Translate, error) <span class="cov8" title="1">{
        dbTranslates := make([]db.Translate, len(stringsSlice))
        for i, str := range stringsSlice </span><span class="cov8" title="1">{

                phrase, err := q.InsertPhrases(e.Request().Context(), title.ID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">insertTranslate, err := q.InsertTranslates(
                        e.Request().Context(),
                        db.InsertTranslatesParams{
                                PhraseID:   phrase.ID,
                                LanguageID: title.OgLanguageID,
                                Phrase:     str,
                                PhraseHint: makeHintString(str),
                        })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">dbTranslates[i] = insertTranslate</span>
        }

        <span class="cov8" title="1">return dbTranslates, nil</span>
}

// InsertTranslates accepts a slice of util.TranslatedReturns and inserts them into the db
func (t *Translate) InsertTranslates(e echo.Context, q db.Querier, langId int16, trr []util.TranslatesReturn) ([]db.Translate, error) <span class="cov8" title="1">{
        dbTranslates := make([]db.Translate, len(trr))
        for i, row := range trr </span><span class="cov8" title="1">{

                // apostrophe's are replaced with &amp;#39; in the response from google translate
                replacedText := strings.ReplaceAll(row.Text, "&amp;#39;", "'")
                insertTranslate, err := q.InsertTranslates(
                        e.Request().Context(),
                        db.InsertTranslatesParams{
                                PhraseID:   row.PhraseId,
                                LanguageID: langId,
                                Phrase:     replacedText,
                                PhraseHint: makeHintString(replacedText),
                        })
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">dbTranslates[i] = insertTranslate</span>
        }

        <span class="cov8" title="1">return dbTranslates, nil</span>
}

// makeHintString creates a hint string that is the first character of each word of a phrase
// and an underscore for every following character giving the user help when requested.
func makeHintString(s string) string <span class="cov8" title="1">{
        hintString := ""
        words := strings.Fields(s)
        for _, word := range words </span><span class="cov8" title="1">{
                punctuation := false
                hintString += string(word[0])
                if unicode.IsPunct(rune(word[0])) </span><span class="cov0" title="0">{
                        punctuation = true
                }</span>
                <span class="cov8" title="1">for i := 1; i &lt; len(word); i++ </span><span class="cov8" title="1">{
                        if punctuation </span><span class="cov0" title="0">{
                                hintString += string(word[i])
                                punctuation = false
                        }</span> else<span class="cov8" title="1"> if unicode.IsLetter(rune(word[i])) </span><span class="cov8" title="1">{
                                hintString += "_"
                        }</span> else<span class="cov8" title="1"> {
                                hintString += string(word[i])
                        }</span>
                }
                <span class="cov8" title="1">hintString += " "</span>
        }
        <span class="cov8" title="1">return hintString</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package util

import (
        "errors"
        "fmt"
)

var (
        ErrVoiceLangIdNoMatch = errors.New("voice id does not match chosen language id")
        ErrOneFile            = errors.New("no need to zip one file")
        ErrUnableToParseFile  = func(err error) error <span class="cov8" title="1">{
                return errors.New(fmt.Sprintf("unable to parse file: %s", err))
        }</span>
        ErrTooManyPhrases = errors.New("too many phrases")
        ErrIntConversion  = errors.New("conversion failed: The interface does not hold an int")
        ErrVoiceIdInvalid = errors.New("voice id invalid")
)
</pre>
		
		<pre class="file" id="file29" style="display: none">package util

import (
        "fmt"
        "golang.org/x/crypto/bcrypt"
        "os"
        "strconv"
)

// TranslatesReturn avoiding cycle between mock/translates and translates/translates
type TranslatesReturn struct {
        PhraseId int64
        Text     string
}

// HashPassword returns the bcrypt hash of the password
func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash password: %w", err)
        }</span>
        <span class="cov8" title="1">return string(hashedPassword), nil</span>
}

// CheckPassword checks if the provided password is correct or not
func CheckPassword(password string, hashedPassword string) error <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span>

// PathExists returns whether the given file or directory exists
func PathExists(path string) (bool, error) <span class="cov8" title="1">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

func ConvertStringInt16(s string) (int16, error) <span class="cov8" title="1">{
        i, err := strconv.ParseInt(s, 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">return int16(i), nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">//go:build go1.22

package main

import (
        "database/sql"
        "flag"
        "github.com/labstack/echo/v4"
        "net"
        "os/exec"
        "strings"
        "talkliketv.click/tltv/api"
        db "talkliketv.click/tltv/db/sqlc"
        "talkliketv.click/tltv/internal/config"
)

func main() <span class="cov0" title="0">{

        e := echo.New()
        var cfg config.Config
        err := config.SetConfigs(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Fatal(err)
        }</span>
        <span class="cov0" title="0">flag.Parse()

        // if ffmpeg is not installed and in PATH of host machine fail immediately
        cmd := exec.Command("ffmpeg", "-version")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Fatal("Please make sure ffmep is installed and in PATH\n: %s", err)
        }</span>
        <span class="cov0" title="0">if !strings.Contains(string(output), "ffmpeg version") </span><span class="cov0" title="0">{
                e.Logger.Fatal("Please make sure ffmep is installed and in PATH\n: %s", string(output))
        }</span>

        // open db connection. if err fail immediately
        <span class="cov0" title="0">conn, err := cfg.OpenDB()
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Fatal("Error connecting to DB\n: %s", err)
        }</span>
        <span class="cov0" title="0">defer func(db *sql.DB) </span><span class="cov0" title="0">{
                err = db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        e.Logger.Fatal("Error connecting to DB\n: %s", err)
                }</span>
        }(conn)

        <span class="cov0" title="0">e.Logger.Info("database connection pool established")

        // create db connection
        q := db.New(conn)

        // create dependencies
        t, af := api.Depends(e)

        // create new server
        api.NewServer(e, cfg, q, t, af)

        e.Logger.Fatal(e.Start(net.JoinHostPort("0.0.0.0", cfg.Port)))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
